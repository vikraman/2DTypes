\AgdaHide{
\begin{code}
{-# OPTIONS --without-K #-}

module opsem where

open import Level using () renaming (zero to l0; suc to lsuc)
open import Universe using (Universe)
open import Data.Bool
open import Data.Sum hiding ([_,_])
open import Data.Product hiding (<_,_>)
open import Categories.Category using (Category)
open import Categories.Groupoid using (Groupoid)
open import Data.Unit using (âŠ¤; tt)
open import Data.Nat using (â„•; suc)
open import Data.Integer
  using (â„¤; +_; -[1+_])
  renaming (-_ to â„¤-; suc to â„¤suc; _+_ to _â„¤+_)
open import Rational+ renaming (_+_ to _â„š+_; _*_ to _â„š*_)
  hiding (_â‰¤_; _â‰¤?_)
open import Relation.Binary.PropositionalEquality
  using (_â‰¡_; refl; trans; subst)
open import Categories.Groupoid.Sum using () renaming (Sum to GSum)
open import Categories.Groupoid.Product using () renaming (Product to GProduct)
open import Function using (case_of_)

open import pifrac

\end{code}
}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{$\Pi^/$: Operational Semantics} 

% when we compute with a value x : A we are computing up to the 
% equivalences generated by the loop space x ==A x

% Need to show: 
% v,w : A,  v ~ w,  and c : A <-> B implies eval(c,v) ~ eval(c,w) 

% still need to make sense of eta/epsilon 

% %%%%%%%
% \subsection{Values}

% Values of types FT/ are a pair of a point and automorphism on that
% point. Note that the values of $\order{p}$ are things that represent
% ``apply this program $i$ times''

% When we have a discrete category, the objects are values and we want a
% morphism from every value to itself so the morphisms are propositional
% equalities; when we have the category 1 over hash p, there is only a
% trivial object and the morphisms are combinators; when we have the
% category hash p, the objects are combinators and the morphisms are
% 2-combinators. So we have a progression of objects: values, tt,
% combinators and a corresponding progression of morphisms: refl,
% combinators, and 2-combinators. And then we have sums and products of
% these things.

% \medskip

% \begin{code}
% -- V : (T : FT/) â†’ Set
% -- V T = let â„‚ , _ = âŸ¦ T âŸ§/
% --           open Category â„‚
% --       in Î£[ v âˆˆ Obj ] (v â‡’ v)

% -- -- Examples:

% -- -- Abbreviations: 

% -- -- discrete values

% -- dv : {Ï„ : FT} â†’ Universe.El UFT Ï„ â†’ V (â‡‘ Ï„)
% -- dv v = (v , refl)

% -- -- fractional values

% -- fv : {Ï„ : FT} â†’ (p : Ï„ âŸ· Ï„) (i : â„¤) â†’ V (1/# p)
% -- fv p i = (tt , perm i (p ^ i) idâ‡”)

% -- -- combinator values

% -- cv : {Ï„ : FT} â†’ (p : Ï„ âŸ· Ï„) (i : â„¤) â†’ V (# p)
% -- cv p i = (perm i (p ^ i) idâ‡” , idâ‡”)

% -- -- left and right injections

% -- injâ‚/ : {Tâ‚ Tâ‚‚ : FT/} â†’ V Tâ‚ â†’ V (Tâ‚ âŠ Tâ‚‚)
% -- injâ‚/ (v , av) = (injâ‚ v , av)

% -- injâ‚‚/ : {Tâ‚ Tâ‚‚ : FT/} â†’ V Tâ‚‚ â†’ V (Tâ‚ âŠ Tâ‚‚)
% -- injâ‚‚/ (v , av) = (injâ‚‚ v , av)

% -- -- pairing

% -- [_,_] : {Tâ‚ Tâ‚‚ : FT/} â†’ V Tâ‚ â†’ V Tâ‚‚ â†’ V (Tâ‚ âŠ  Tâ‚‚)
% -- [ (vâ‚ , avâ‚) , (vâ‚‚ , avâ‚‚) ] = ((vâ‚ , vâ‚‚) , (avâ‚ , avâ‚‚))

% -- --

% -- vâ‚ : V (â‡‘ BOOL)
% -- vâ‚ = dv (injâ‚ tt)

% -- vâ‚‚ vâ‚ƒ : V (# NOT)
% -- vâ‚‚ = cv NOT (+ 0)
% -- vâ‚ƒ = cv NOT (+ 1)

% -- vâ‚„ vâ‚… : V (1/# NOT)
% -- vâ‚„ = fv NOT (+ 0)
% -- vâ‚… = fv NOT (+ 1)

% -- vâ‚† vâ‚‡ : V (# NOT âŠ â‡‘ BOOL)
% -- vâ‚† = injâ‚/ {Tâ‚ = # NOT} {Tâ‚‚ = â‡‘ BOOL} vâ‚‚
% -- vâ‚‡ = injâ‚‚/ {Tâ‚ = # NOT} {Tâ‚‚ = â‡‘ BOOL} vâ‚

% -- vâ‚ˆ : V (# NOT âŠ  â‡‘ BOOL)
% -- vâ‚ˆ = [_,_] {Tâ‚ = # NOT} {Tâ‚‚ = â‡‘ BOOL} vâ‚‚ vâ‚

% -- vâ‚‰ : V (# NOT âŠ  1/# NOT) -- mismatched pair
% -- vâ‚‰ = [_,_] {Tâ‚ = # NOT} {Tâ‚‚ = 1/# NOT} vâ‚‚ vâ‚… 

% \end{code}

%%%%%%%
\subsection{Interpreter}

\AgdaHide{
\begin{code}
postulate 
  prim : {Tâ‚ Tâ‚‚ : U} â†’ (PrimâŸ· Tâ‚ Tâ‚‚) â†’ Val Tâ‚ â†’ Val Tâ‚‚
  ğ“ğ“¹â»Â¹ : {Tâ‚ Tâ‚‚ : U} â†’ (Tâ‚ âŸ· Tâ‚‚) â†’ Val Tâ‚‚ â†’ Val Tâ‚
\end{code}
}

{\setlength{\mathindent}{0cm}
\medskip
{\footnotesize{
\begin{code}
ğ“ğ“¹ : {Tâ‚ Tâ‚‚ : U} â†’ (Tâ‚ âŸ· Tâ‚‚) â†’ Val Tâ‚ â†’ Val Tâ‚‚
ğ“ğ“¹ (Prim x) v = prim x v
ğ“ğ“¹ idâŸ· v = v 
ğ“ğ“¹ (câ‚ â— câ‚‚) v = let x = ğ“ğ“¹ câ‚ v in ğ“ğ“¹ câ‚‚ x
ğ“ğ“¹ (câ‚ âŠ• câ‚‚) (inl v) = inl (ğ“ğ“¹ câ‚ v)
ğ“ğ“¹ (câ‚ âŠ• câ‚‚) (inr v) = inr (ğ“ğ“¹ câ‚‚ v)
ğ“ğ“¹ (câ‚ âŠ— câ‚‚) [ v , w ] = [ ğ“ğ“¹ câ‚ v , ğ“ğ“¹ câ‚‚ w ]
ğ“ğ“¹ (Î·- c) â‹† = {!!}
ğ“ğ“¹ (Î·+ c) â‹† = {!!} 
ğ“ğ“¹ (Îµ+ c) [ comb < kâ‚ , qâ‚ , Î±â‚ > , 1/comb < kâ‚‚ , qâ‚‚ , Î±â‚‚ > ] = {!!} 
ğ“ğ“¹ (Îµ- c) [ 1/comb < kâ‚ , qâ‚ , Î±â‚ > , comb < kâ‚‚ , qâ‚‚ , Î±â‚‚ > ] = {!!} 
\end{code}}}}


% \begin{code}
% -- Context T1 T2 T3 : missing T1 â‡¿ T2 combinator;
% -- returns T3 as final answer

% -- data Context : FT/ â†’ FT/ â†’ FT/ â†’ Set where
% --   Empty : {T : FT/} â†’ Context T T T
% --   Fst : {Tâ‚ Tâ‚‚ Tâ‚ƒ T : FT/} â†’
% --     (C : Context Tâ‚ Tâ‚ƒ T) â†’ (Pâ‚‚ : Tâ‚‚ â‡¿ Tâ‚ƒ) â†’ Context Tâ‚ Tâ‚‚ T
% --   Snd : {Tâ‚ Tâ‚‚ Tâ‚ƒ T : FT/} â†’
% --     (Pâ‚ : Tâ‚ â‡¿ Tâ‚‚) â†’ (C : Context Tâ‚ Tâ‚ƒ T) â†’ Context Tâ‚‚ Tâ‚ƒ T
% --   LÃ— : {Tâ‚ Tâ‚‚ Tâ‚ƒ Tâ‚„ T : FT/} â†’
% --     (C : Context (Tâ‚ âŠ  Tâ‚‚) (Tâ‚ƒ âŠ  Tâ‚„) T) â†’
% --     (Pâ‚‚ : Tâ‚‚ â‡¿ Tâ‚„) â†’ V Tâ‚‚ â†’ Context Tâ‚ Tâ‚ƒ T
% --   RÃ— : {Tâ‚ Tâ‚‚ Tâ‚ƒ Tâ‚„ T : FT/} â†’
% --     (Pâ‚ : Tâ‚ â‡¿ Tâ‚ƒ) â†’ V Tâ‚ƒ â†’
% --     (C : Context (Tâ‚ âŠ  Tâ‚‚) (Tâ‚ƒ âŠ  Tâ‚„) T) â†’ Context Tâ‚‚ Tâ‚„ T
% --   L+ : {Tâ‚ Tâ‚‚ Tâ‚ƒ Tâ‚„ T : FT/} â†’
% --     (C : Context (Tâ‚ âŠ Tâ‚‚) (Tâ‚ƒ âŠ Tâ‚„) T) â†’ (Pâ‚‚ : Tâ‚‚ â‡¿ Tâ‚„) â†’ 
% --     Context Tâ‚ Tâ‚ƒ T
% --   R+ : {Tâ‚ Tâ‚‚ Tâ‚ƒ Tâ‚„ T : FT/} â†’
% --     (Pâ‚ : Tâ‚ â‡¿ Tâ‚ƒ) â†’ (C : Context (Tâ‚ âŠ Tâ‚‚) (Tâ‚ƒ âŠ Tâ‚„) T) â†’ 
% --     Context Tâ‚‚ Tâ‚„ T

% -- data State : FT/ â†’ Set where
% --   Enter : {Tâ‚ Tâ‚‚ T : FT/} â†’
% --     (P : Tâ‚ â‡¿ Tâ‚‚) â†’ V Tâ‚ â†’ Context Tâ‚ Tâ‚‚ T â†’ State T
% --   Exit : {Tâ‚ Tâ‚‚ T : FT/} â†’
% --     (P : Tâ‚ â‡¿ Tâ‚‚) â†’ V Tâ‚‚ â†’ Context Tâ‚ Tâ‚‚ T â†’ State T

% -- data Dir : Set where
% --   Fwd : Dir
% --   Bck : Dir
% --   Done : Dir

% -- -- stepForward 

% -- postulate
% --   _â‡”?_ : {Ï„ : FT} â†’ (Ï„ âŸ· Ï„) â†’ (Ï„ âŸ· Ï„) â†’ Bool

% -- ap/ : {T : FT/} â†’ State T â†’ Dir Ã— State T
% -- ap/ (Enter (lift p) (v , _) C) = Fwd , Exit (lift p) (ap p v , refl) C 
% -- ap/ (Enter (Î· p) (tt , av) C) =
% --    Fwd , Exit (Î· p) (((perm (+ 1) p idrâ—r) , tt) , (idâ‡” , (perm (+ 1) p idrâ—r))) C
% -- ap/ (Enter (Îµ p) (((perm i q Î±) , tt) , (Î² , (perm j r Î³))) C) =
% --   if (q â‡”? r)
% --   then Fwd , Exit (Îµ p) (tt , refl) C
% --   else Bck , Enter (Îµ p) (((perm i q Î±) , tt) , (Î² , (perm j r Î³))) C
% -- ap/ (Enter uniteâ‚Šl/ (injâ‚ () , av) C) 
% -- ap/ (Enter uniteâ‚Šl/ (injâ‚‚ v , av) C) = Fwd , Exit uniteâ‚Šl/ (v , av) C
% -- ap/ (Enter unitiâ‚Šl/ (v , av) C) = Fwd , Exit unitiâ‚Šl/ (injâ‚‚ v , av) C
% -- ap/ (Enter uniteâ‚Šr/ (injâ‚ v , av) C) = Fwd , Exit uniteâ‚Šr/ (v , av) C
% -- ap/ (Enter uniteâ‚Šr/ (injâ‚‚ () , av) C)
% -- ap/ (Enter unitiâ‚Šr/ (v , av) C) = Fwd , Exit unitiâ‚Šr/ (injâ‚ v , av) C
% -- ap/ (Enter swapâ‚Š/ (injâ‚ v , av) C) = Fwd , Exit swapâ‚Š/ (injâ‚‚ v , av) C
% -- ap/ (Enter swapâ‚Š/ (injâ‚‚ v , av) C) = Fwd , Exit swapâ‚Š/ (injâ‚ v , av) C
% -- ap/ (Enter assoclâ‚Š/ (injâ‚ v , av) C) = Fwd , Exit assoclâ‚Š/ (injâ‚ (injâ‚ v) , av) C
% -- ap/ (Enter assoclâ‚Š/ (injâ‚‚ (injâ‚ v) , av) C) = Fwd , Exit assoclâ‚Š/ (injâ‚ (injâ‚‚ v) , av) C
% -- ap/ (Enter assoclâ‚Š/ (injâ‚‚ (injâ‚‚ v) , av) C) = Fwd , Exit assoclâ‚Š/ (injâ‚‚ v , av) C
% -- ap/ (Enter assocrâ‚Š/ (injâ‚ (injâ‚ v) , av) C) = Fwd , Exit assocrâ‚Š/ (injâ‚ v , av) C
% -- ap/ (Enter assocrâ‚Š/ (injâ‚ (injâ‚‚ v) , av) C) = Fwd , Exit assocrâ‚Š/ (injâ‚‚ (injâ‚ v) , av) C
% -- ap/ (Enter assocrâ‚Š/ (injâ‚‚ v , av) C) = Fwd , Exit assocrâ‚Š/ (injâ‚‚ (injâ‚‚ v) , av) C
% -- ap/ (Enter uniteâ‹†l/ ((tt , v) , (_ , av)) C) = Fwd , Exit uniteâ‹†l/ (v , av) C
% -- ap/ (Enter unitiâ‹†l/ (v , av) C) = Fwd , Exit unitiâ‹†l/ ((tt , v) , (refl , av)) C
% -- ap/ (Enter uniteâ‹†r/ ((v , tt) , (av , att)) C) = Fwd , Exit uniteâ‹†r/ (v , av) C
% -- ap/ (Enter unitiâ‹†r/ (v , av) C) = Fwd , Exit unitiâ‹†r/ ((v , tt) , (av , refl)) C
% -- ap/ (Enter swapâ‹†/ ((vâ‚ , vâ‚‚) , (avâ‚ , avâ‚‚)) C) = Fwd , Exit swapâ‹†/ ((vâ‚‚ , vâ‚) , (avâ‚‚ , avâ‚)) C
% -- ap/ (Enter assoclâ‹†/ ((vâ‚ , (vâ‚‚ , vâ‚ƒ)) , ((avâ‚ , (avâ‚‚ , avâ‚ƒ)))) C) =
% --   Fwd , Exit assoclâ‹†/ (((vâ‚ , vâ‚‚) , vâ‚ƒ) , ((avâ‚ , avâ‚‚) , avâ‚ƒ)) C
% -- ap/ (Enter assocrâ‹†/ (((vâ‚ , vâ‚‚) , vâ‚ƒ) , ((avâ‚ , avâ‚‚) , avâ‚ƒ)) C) =
% --   Fwd , Exit assocrâ‹†/ ((vâ‚ , (vâ‚‚ , vâ‚ƒ)) , ((avâ‚ , (avâ‚‚ , avâ‚ƒ)))) C
% -- ap/ (Enter absorbr/ ((v , _) , (av , _)) C) = Fwd , Exit absorbr/ (v , av) C
% -- ap/ (Enter absorbl/ ((_ , v) , (_ , av)) C) = Fwd , Exit absorbl/ (v , av) C
% -- ap/ (Enter factorzr/ (() , _) C) 
% -- ap/ (Enter factorzl/ (() , _) C)
% -- ap/ (Enter dist/ ((injâ‚ vâ‚ , vâ‚ƒ) , (avâ‚ , avâ‚ƒ)) C) =
% --   Fwd , Exit dist/ (injâ‚ (vâ‚ , vâ‚ƒ) , (avâ‚ , avâ‚ƒ)) C
% -- ap/ (Enter dist/ ((injâ‚‚ vâ‚‚ , vâ‚ƒ) , (avâ‚‚ , avâ‚ƒ)) C) =
% --   Fwd , Exit dist/ (injâ‚‚ (vâ‚‚ , vâ‚ƒ) , (avâ‚‚ , avâ‚ƒ)) C
% -- ap/ (Enter factor/ (injâ‚ (vâ‚ , vâ‚ƒ) , av) C) =
% --   Fwd , Exit factor/ ((injâ‚ vâ‚ , vâ‚ƒ) , av) C
% -- ap/ (Enter factor/ (injâ‚‚ (vâ‚‚ , vâ‚ƒ) , av) C) =
% --   Fwd , Exit factor/ ((injâ‚‚ vâ‚‚ , vâ‚ƒ) , av) C
% -- ap/ (Enter distl/ ((vâ‚ƒ , injâ‚ vâ‚) , (avâ‚ƒ , avâ‚)) C) =
% --   Fwd , Exit distl/ (injâ‚ (vâ‚ƒ , vâ‚) , (avâ‚ƒ , avâ‚)) C
% -- ap/ (Enter distl/ ((vâ‚ƒ , injâ‚‚ vâ‚‚) , (avâ‚ƒ , avâ‚‚)) C) =
% --   Fwd , Exit distl/ (injâ‚‚ (vâ‚ƒ , vâ‚‚) , (avâ‚ƒ , avâ‚‚)) C
% -- ap/ (Enter factorl/ (injâ‚ (vâ‚ƒ , vâ‚) , av) C) =
% --   Fwd , Exit factorl/ ((vâ‚ƒ , injâ‚ vâ‚) , av) C
% -- ap/ (Enter factorl/ (injâ‚‚ (vâ‚ƒ , vâ‚‚) , av) C) =
% --   Fwd , Exit factorl/ ((vâ‚ƒ , injâ‚‚ vâ‚‚) , av) C
% -- ap/ (Enter idâ‡¿ v C) = Fwd , Exit idâ‡¿ v C
% -- ap/ (Enter (Pâ‚ â—/ Pâ‚‚) v C) = Fwd , Enter Pâ‚ v (Fst C Pâ‚‚)
% -- ap/ (Enter (Pâ‚ âŠ•/ Pâ‚‚) (injâ‚ vâ‚ , av) C) = Fwd , Enter Pâ‚ (vâ‚ , av) (L+ C Pâ‚‚) 
% -- ap/ (Enter (Pâ‚ âŠ•/ Pâ‚‚) (injâ‚‚ vâ‚‚ , av) C) = Fwd , Enter Pâ‚‚ (vâ‚‚ , av) (R+ Pâ‚ C) 
% -- ap/ (Enter (Pâ‚ âŠ—/ Pâ‚‚) ((vâ‚ , vâ‚‚) , (avâ‚ , avâ‚‚)) C) =
% --   Fwd , Enter Pâ‚ (vâ‚ , avâ‚) (LÃ— C Pâ‚‚ (vâ‚‚ , avâ‚‚))
% -- ap/ (Exit P v Empty) = Done , Exit P v Empty
% -- ap/ (Exit Pâ‚ v (Fst C Pâ‚‚)) = Fwd , Enter Pâ‚‚ v (Snd Pâ‚ C) 
% -- ap/ (Exit Pâ‚‚ vâ‚‚ (Snd Pâ‚ C)) = Fwd , Exit (Pâ‚ â—/ Pâ‚‚) vâ‚‚ C 
% -- ap/ (Exit Pâ‚ vâ‚ (LÃ— C Pâ‚‚ vâ‚‚)) = Fwd , Enter Pâ‚‚ vâ‚‚ (RÃ— Pâ‚ vâ‚ C) 
% -- ap/ (Exit Pâ‚‚ (vâ‚‚ , avâ‚‚) (RÃ— Pâ‚ (vâ‚ , avâ‚) C)) =
% --   Fwd , Exit (Pâ‚ âŠ—/ Pâ‚‚) (((vâ‚ , vâ‚‚) , (avâ‚ , avâ‚‚))) C 
% -- ap/ (Exit Pâ‚ (vâ‚ , av) (L+ C Pâ‚‚)) = Fwd , Exit (Pâ‚ âŠ•/ Pâ‚‚) (injâ‚ vâ‚ , av) C  
% -- ap/ (Exit Pâ‚‚ (vâ‚‚ , av) (R+ Pâ‚ C)) = Fwd , Exit (Pâ‚ âŠ•/ Pâ‚‚) (injâ‚‚ vâ‚‚ , av) C 

% -- apâ»Â¹/ : {T : FT/} â†’ State T â†’ Dir Ã— State T
% -- apâ»Â¹/ (Exit (lift p) (v , _) C) = Bck , Enter (lift p) (apâ»Â¹ p v , refl) C 
% -- apâ»Â¹/ (Exit (Î· p) (((perm i q Î±) , tt) , (Î² , (perm j r Î³))) C) =
% --   if (q â‡”? r)
% --   then Bck , Enter (Î· p) (tt , refl) C
% --   else Fwd , Exit (Î· p)
% --          (((perm (â„¤suc i) (p â— q) (transâ‡” (idâ‡” âŠ¡ Î±) (
% --              transâ‡” (idrâ—r âŠ¡ idâ‡”) (2! (lower {p = p} (+ 1) i))))) , tt) , (idâ‡” ,
% --            (perm (â„¤suc j) (p â— r) (transâ‡” (idâ‡” âŠ¡ Î³)
% --              (transâ‡” (idrâ—r âŠ¡ idâ‡”) (2! (lower {p = p} (+ 1) j))))))) C
% -- apâ»Â¹/ (Exit (Îµ p) (tt , _) C) =
% --   Bck , Enter (Îµ p) ((((perm (+ 1) p idrâ—r) , tt)) , (idâ‡” , (perm (+ 1) p idrâ—r))) C

% -- apâ»Â¹/ (Exit unitiâ‚Šl/ (injâ‚ () , av) C) 
% -- apâ»Â¹/ (Exit unitiâ‚Šl/ (injâ‚‚ v , av) C) = Bck , Enter unitiâ‚Šl/ (v , av) C
% -- apâ»Â¹/ (Exit uniteâ‚Šl/ (v , av) C) = Bck , Enter uniteâ‚Šl/ (injâ‚‚ v , av) C
% -- apâ»Â¹/ (Exit unitiâ‚Šr/ (injâ‚ v , av) C) = Bck , Enter unitiâ‚Šr/ (v , av) C
% -- apâ»Â¹/ (Exit unitiâ‚Šr/ (injâ‚‚ () , av) C)
% -- apâ»Â¹/ (Exit uniteâ‚Šr/ (v , av) C) = Bck , Enter uniteâ‚Šr/ (injâ‚ v , av) C
% -- apâ»Â¹/ (Exit swapâ‚Š/ (injâ‚ v , av) C) = Bck , Enter swapâ‚Š/ (injâ‚‚ v , av) C
% -- apâ»Â¹/ (Exit swapâ‚Š/ (injâ‚‚ v , av) C) = Bck , Enter swapâ‚Š/ (injâ‚ v , av) C
% -- apâ»Â¹/ (Exit assocrâ‚Š/ (injâ‚ v , av) C) = Bck , Enter assocrâ‚Š/ (injâ‚ (injâ‚ v) , av) C
% -- apâ»Â¹/ (Exit assocrâ‚Š/ (injâ‚‚ (injâ‚ v) , av) C) = Bck , Enter assocrâ‚Š/ (injâ‚ (injâ‚‚ v) , av) C
% -- apâ»Â¹/ (Exit assocrâ‚Š/ (injâ‚‚ (injâ‚‚ v) , av) C) = Bck , Enter assocrâ‚Š/ (injâ‚‚ v , av) C
% -- apâ»Â¹/ (Exit assoclâ‚Š/ (injâ‚ (injâ‚ v) , av) C) = Bck , Enter assoclâ‚Š/ (injâ‚ v , av) C
% -- apâ»Â¹/ (Exit assoclâ‚Š/ (injâ‚ (injâ‚‚ v) , av) C) = Bck , Enter assoclâ‚Š/ (injâ‚‚ (injâ‚ v) , av) C
% -- apâ»Â¹/ (Exit assoclâ‚Š/ (injâ‚‚ v , av) C) = Bck , Enter assoclâ‚Š/ (injâ‚‚ (injâ‚‚ v) , av) C
% -- apâ»Â¹/ (Exit unitiâ‹†l/ ((tt , v) , (_ , av)) C) = Bck , Enter unitiâ‹†l/ (v , av) C
% -- apâ»Â¹/ (Exit uniteâ‹†l/ (v , av) C) = Bck , Enter uniteâ‹†l/ ((tt , v) , (refl , av)) C
% -- apâ»Â¹/ (Exit unitiâ‹†r/ ((v , tt) , (av , att)) C) = Bck , Enter unitiâ‹†r/ (v , av) C
% -- apâ»Â¹/ (Exit uniteâ‹†r/ (v , av) C) = Bck , Enter uniteâ‹†r/ ((v , tt) , (av , refl)) C
% -- apâ»Â¹/ (Exit swapâ‹†/ ((vâ‚ , vâ‚‚) , (avâ‚ , avâ‚‚)) C) = Bck , Enter swapâ‹†/ ((vâ‚‚ , vâ‚) , (avâ‚‚ , avâ‚)) C
% -- apâ»Â¹/ (Exit assocrâ‹†/ ((vâ‚ , (vâ‚‚ , vâ‚ƒ)) , ((avâ‚ , (avâ‚‚ , avâ‚ƒ)))) C) =
% --   Bck , Enter assocrâ‹†/ (((vâ‚ , vâ‚‚) , vâ‚ƒ) , ((avâ‚ , avâ‚‚) , avâ‚ƒ)) C
% -- apâ»Â¹/ (Exit assoclâ‹†/ (((vâ‚ , vâ‚‚) , vâ‚ƒ) , ((avâ‚ , avâ‚‚) , avâ‚ƒ)) C) =
% --   Bck , Enter assoclâ‹†/ ((vâ‚ , (vâ‚‚ , vâ‚ƒ)) , ((avâ‚ , (avâ‚‚ , avâ‚ƒ)))) C
% -- apâ»Â¹/ (Exit factorzl/ ((v , _) , (av , _)) C) = Bck , Enter factorzl/ (v , av) C
% -- apâ»Â¹/ (Exit factorzr/ ((_ , v) , (_ , av)) C) = Bck , Enter factorzr/ (v , av) C
% -- apâ»Â¹/ (Exit absorbl/ (() , _) C) 
% -- apâ»Â¹/ (Exit absorbr/ (() , _) C)
% -- apâ»Â¹/ (Exit factor/ ((injâ‚ vâ‚ , vâ‚ƒ) , (avâ‚ , avâ‚ƒ)) C) =
% --   Bck , Enter factor/ (injâ‚ (vâ‚ , vâ‚ƒ) , (avâ‚ , avâ‚ƒ)) C
% -- apâ»Â¹/ (Exit factor/ ((injâ‚‚ vâ‚‚ , vâ‚ƒ) , (avâ‚‚ , avâ‚ƒ)) C) =
% --   Bck , Enter factor/ (injâ‚‚ (vâ‚‚ , vâ‚ƒ) , (avâ‚‚ , avâ‚ƒ)) C
% -- apâ»Â¹/ (Exit dist/ (injâ‚ (vâ‚ , vâ‚ƒ) , av) C) =
% --   Bck , Enter dist/ ((injâ‚ vâ‚ , vâ‚ƒ) , av) C
% -- apâ»Â¹/ (Exit dist/ (injâ‚‚ (vâ‚‚ , vâ‚ƒ) , av) C) =
% --   Bck , Enter dist/ ((injâ‚‚ vâ‚‚ , vâ‚ƒ) , av) C
% -- apâ»Â¹/ (Exit factorl/ ((vâ‚ƒ , injâ‚ vâ‚) , (avâ‚ƒ , avâ‚)) C) =
% --   Bck , Enter factorl/ (injâ‚ (vâ‚ƒ , vâ‚) , (avâ‚ƒ , avâ‚)) C
% -- apâ»Â¹/ (Exit factorl/ ((vâ‚ƒ , injâ‚‚ vâ‚‚) , (avâ‚ƒ , avâ‚‚)) C) =
% --   Bck , Enter factorl/ (injâ‚‚ (vâ‚ƒ , vâ‚‚) , (avâ‚ƒ , avâ‚‚)) C
% -- apâ»Â¹/ (Exit distl/ (injâ‚ (vâ‚ƒ , vâ‚) , av) C) =
% --   Bck , Enter distl/ ((vâ‚ƒ , injâ‚ vâ‚) , av) C
% -- apâ»Â¹/ (Exit distl/ (injâ‚‚ (vâ‚ƒ , vâ‚‚) , av) C) =
% --   Bck , Enter distl/ ((vâ‚ƒ , injâ‚‚ vâ‚‚) , av) C
% -- apâ»Â¹/ (Exit idâ‡¿ v C) = Bck , Enter idâ‡¿ v C
% -- apâ»Â¹/ (Exit (Pâ‚ â—/ Pâ‚‚) v C) = Bck , Exit Pâ‚‚ v (Snd Pâ‚ C)
% -- apâ»Â¹/ (Exit (Pâ‚ âŠ•/ Pâ‚‚) (injâ‚ vâ‚ , av) C) = Bck , Exit Pâ‚ (vâ‚ , av) (L+ C Pâ‚‚) 
% -- apâ»Â¹/ (Exit (Pâ‚ âŠ•/ Pâ‚‚) (injâ‚‚ vâ‚‚ , av) C) = Bck , Exit Pâ‚‚ (vâ‚‚ , av) (R+ Pâ‚ C) 
% -- apâ»Â¹/ (Exit (Pâ‚ âŠ—/ Pâ‚‚) ((vâ‚ , vâ‚‚) , (avâ‚ , avâ‚‚)) C) =
% --   Bck , Exit Pâ‚‚ (vâ‚‚ , avâ‚‚) (RÃ— Pâ‚ (vâ‚ , avâ‚) C)
% -- apâ»Â¹/ (Enter P v Empty) = Done , Enter P v Empty
% -- apâ»Â¹/ (Enter Pâ‚ v (Fst C Pâ‚‚)) = Bck , Enter (Pâ‚ â—/ Pâ‚‚) v C 
% -- apâ»Â¹/ (Enter Pâ‚‚ vâ‚‚ (Snd Pâ‚ C)) = Bck , Exit Pâ‚ vâ‚‚ (Fst C Pâ‚‚)
% -- apâ»Â¹/ (Enter Pâ‚ (vâ‚ , avâ‚) (LÃ— C Pâ‚‚ (vâ‚‚ , avâ‚‚))) =
% --   Bck , Enter (Pâ‚ âŠ—/ Pâ‚‚) (((vâ‚ , vâ‚‚) , (avâ‚ , avâ‚‚))) C 
% -- apâ»Â¹/ (Enter Pâ‚‚ (vâ‚‚ , avâ‚‚) (RÃ— Pâ‚ (vâ‚ , avâ‚) C)) =
% --   Bck , Exit Pâ‚ (vâ‚ , avâ‚) (LÃ— C Pâ‚‚ (vâ‚‚ , avâ‚‚))
% -- apâ»Â¹/ (Enter Pâ‚ (vâ‚ , av) (L+ C Pâ‚‚)) = Bck , Enter (Pâ‚ âŠ•/ Pâ‚‚) (injâ‚ vâ‚ , av) C  
% -- apâ»Â¹/ (Enter Pâ‚‚ (vâ‚‚ , av) (R+ Pâ‚ C)) = Bck , Enter (Pâ‚ âŠ•/ Pâ‚‚) (injâ‚‚ vâ‚‚ , av) C 

% -- {-# NON_TERMINATING #-}
% -- mutual 
% --   loopFwd : {T : FT/} â†’ State T â†’ V T
% --   loopFwd s with ap/ s
% --   ... | Fwd , s' = loopFwd s'
% --   ... | Bck , s' = loopBck s'
% --   ... | Done , Exit _ v Empty = v
% --   ... | Done , _ = {!!}

% --   loopBck : {T : FT/} â†’ State T â†’ V T
% --   loopBck s with apâ»Â¹/ s
% --   ... | Bck , s' = loopBck s'
% --   ... | Fwd , s' = loopFwd s'
% --   ... | Done , _ = {!!}

% -- -- Credit card example

% -- cc : # NOT â‡¿ # NOT
% -- cc = unitiâ‹†l/ â—/
% --      (((Î· NOT) âŠ—/ idâ‡¿) â—/
% --      ((assocrâ‹†/ â—/
% --      ((idâ‡¿ âŠ—/ swapâ‹†/) â—/
% --      ((idâ‡¿ âŠ—/ (Îµ NOT)) â—/
% --      uniteâ‹†r/)))))

% \end{code}

%%%%%%%
\subsection{Pragmatics}

We have a way to generate programs at run time from eta: it would be
nice to have a way to execute these programs.

name/coname; other diagrams from previous submission; ap; foldswap; other ideas

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%% -- Trivial implementation of eta/epsilon that does
%% -- type check (see below).  Might be interesting to figure out why
%% -- that is:
%% -- ap/ (Î· {Ï„} {p}) (v , av) =
%% --   (((+ 0) , (p , idâ‡”)) , tt) , (idâ‡” , ((+ 0) , (p , idâ‡”)))
%% -- ap/ Îµ (v , av) = tt , refl

