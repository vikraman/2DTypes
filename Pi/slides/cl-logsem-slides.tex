% !TeX root = cl-logsem-slides.tex
% !TeX program = lualatex
\documentclass[lualatex,aspectratio=169,10pt]{beamer}
% \overfullrule=1em

\usefonttheme{professionalfonts}
% \usefonttheme{serif}

\beamertemplatenavigationsymbolsempty
\setbeamertemplate{footline}[frame number]

% \setbeameroption{show notes on second screen}

\usepackage{fontspec}
% \usepackage{unicode-math}

\setmainfont{Baskerville}
\setsansfont{Fira Sans}
\setmonofont{Iosevka}[
  Scale = MatchLowercase
]
% \setmathfont{texgyrepagella-math.otf}[math-style=TeX]

\setbeamersize{text margin left=5mm,text margin right=5mm}
\setbeamerfont{title}{size=\huge}

\setbeamercolor{normal text}{fg=solarized-base03, bg=white}
\setbeamercolor{structure}{fg=solarized-violet}

\usepackage[capitalise,noabbrev]{cleveref}
\usepackage[inline]{enumitem}
\usepackage{extarrows}
\usepackage{longtable}
\usepackage{adjustbox}
\usepackage{url}
\usepackage{multicol}
\usepackage{stmaryrd}
\usepackage{proof}
%\usepackage{bbold}
%\usepackage[bb=boondox]{mathalfa}
\usepackage{subcaption}
\captionsetup[subfigure]{labelformat=empty}
\usepackage[utf8]{inputenc}
\usepackage{newunicodechar}
\usepackage{underoverlap}
\usepackage{eqparbox}

\let\Bbbk\relax
\usepackage{amsmath}
\usepackage{amssymb,amsfonts}
\usepackage{newtxmath}
\usepackage{bbm}

\usepackage[utf8]{inputenc}
\usepackage{newunicodechar}

\newunicodechar{âŠ¸}{$\multimap$}
\newunicodechar{ð•}{$\mathbb{V}$}
\newunicodechar{ð•ƒ}{$\mathbb{L}$}
\newunicodechar{ð•„}{$\mathbb{M}$}
\newunicodechar{â„}{$\mathbb{R}$}
\newunicodechar{ð•Œ}{$\mathbb{U}$}
\newunicodechar{ð”¹}{$\mathbb{B}$}
\newunicodechar{ð•}{$\mathbb{Y}$}
\newunicodechar{ð”¼}{$\mathbb{E}$}
\newunicodechar{ð”½}{$\mathbb{F}$}
\newunicodechar{ð•‹}{$\mathbb{T}$}
\newunicodechar{ð•š}{$\mathbb{i}$}
\newunicodechar{ðŸ˜}{$\mathbb{0}$}
\newunicodechar{ðŸ™}{$\mathbb{1}$}
\newunicodechar{ðŸš}{$\mathbb{2}$}
\newunicodechar{ðŸ›}{$\mathbb{3}$}
\newunicodechar{ðŸ }{$\mathbb{8}$}
\newunicodechar{âŸ·}{$\leftrightarrow$}
\newunicodechar{â‚€}{$_{0}$}
\newunicodechar{â‚}{$_{1}$}
\newunicodechar{â‚‚}{$_{2}$}
\newunicodechar{â‚ƒ}{$_{3}$}
\newunicodechar{â‚„}{$_{4}$}
\newunicodechar{Â¹}{$^{1}$}
\newunicodechar{Â²}{$^{2}$}
\newunicodechar{Â³}{$^{3}$}
\newunicodechar{â´}{$^{4}$}
\newunicodechar{â– }{$\blacksquare$}
\newunicodechar{âŠ¡}{$\boxdot$}
\newunicodechar{â‹†}{$\star$}
\newunicodechar{â—Ž}{$\circledcirc$}
\newunicodechar{âŠ—}{$\otimes$}
\newunicodechar{âŠ•}{$\oplus$}
\newunicodechar{â‚Š}{$_{+}$}
\newunicodechar{â†”}{$\leftrightarrow$}
\newunicodechar{â‡”}{$\Leftrightarrow$}
\newunicodechar{âˆ€}{$\forall$}
\newunicodechar{Ï•}{$\phi$}
\newunicodechar{â‹¯}{$\AgdaInductiveConstructor{\ldots}$}

\usepackage[conor]{agda}
\AgdaNoSpaceAroundCode
% \renewcommand{\AgdaCodeStyle}{\footnotesize}
\definecolor{AgdaUnsolvedMeta}{HTML}{FFFFFF}
\newcommand{\AIC}[1]{\AgdaInductiveConstructor{#1}}

\input{\detokenize{ExamplesS.tex}}

\usepackage{tikz}
\usetikzlibrary{decorations.markings}
\usetikzlibrary{quotes,fit,positioning}
\usetikzlibrary{arrows.meta, tikzmark}
\usetikzlibrary{knots}
\tikzstyle{func}=[rectangle,draw,fill=black!20,minimum size=1.9em,text width=2.4em, text centered]
\usetikzlibrary{braids}
\tikzset{>=latex}
\usepackage{tikzit}
\input{tikzit.tikzstyles}
\usepackage{quiver}
\usepackage[nocenter]{qtree}
\usepackage{yquant}
\usepackage[american,siunitx]{circuitikz}

\usepackage[most]{tcolorbox}

\usepackage{macros}
\usepackage{hott}
\usepackage{syntax2}
\usepackage{agda-listings}
\usepackage{microtype}

\newtcolorbox{dblock}[1][Definition]{
  colback=white,
  colframe=solarized-violet,
  colbacktitle=white!90!structure.fg,
  coltitle=black,
  fonttitle=\itshape,
  title={#1},
  enhanced,
  attach boxed title to top left={yshift=-2mm, xshift=0.5cm}
}

\newtcolorbox{tblock}[1][Proposition]{
  colback=white,
  colframe=solarized-blue,
  colbacktitle=white!90!structure.fg,
  coltitle=black,
  fonttitle=\itshape,
  title={#1},
  enhanced,
  attach boxed title to top left={yshift=-2mm, xshift=0.5cm}
}

\newcommand{\astarrow}{\stackrel{\ast}{\smash{\longrightarrow}\rule{0pt}{0.4ex}}}
\newcommand{\btVFill}{\vskip0pt plus 1filll}

\title{Symmetries in Reversible Programming}
\subtitle{From Symmetric Rig Groupoids to Reversible Programming Languages}
% \author{Vikraman Choudhury}
\date{Logic \& Semantics Seminar \\ May 27, 2022}

\begin{document}

\begin{frame}
    \titlepage
\end{frame}

% \begin{frame}[fragile]{Plan}
%     \begin{plist}
%         \item Motivation: Reversible Programming
%         \item Main result: Equivalence between Pi and UFin
%         \begin{plist}
%             \item Pi is the free symmetric rig groupoid on 0
%             \item UFin is the univalent subuniverse of finite types
%         \end{plist}
%         \item First step: Pi to PiPlus
%         \item Second step: PiPlus to PiHat
%         \item Third step: PiHat to UFin
%         \begin{plist}
%             \item Loop space of PiHat(n) is equivalent to Sn
%             \item Sn is equivalent to Lehmer(n)
%             \item Lehmer(n) is equivalent to Aut(Fin(n))
%             \item This is the loopspace of UFin
%         \end{plist}
%         \item What we can do? (reversible circuits, normalisation, theorems transfer)
%         \item Discussion:
%         \begin{plist}
%             \item computing with univalence for finite types
%             \item free symmetric monoidal groupoid on a groupoid
%             \item generalised species
%         \end{plist}
%     \end{plist}
% \end{frame}

% \begin{frame}{Main result}
%     \bigskip
%     {\Huge
%         \[
%             \FSR[0] \eqv \FSM[1] \eqv \UFin
%         \]}
% \end{frame}

\begin{frame}[fragile]{Computation}
    \begin{plist}
        \item What is Computation?
        \begin{plist}
            \item It's the process of calculating functions on natural numbers.
            \item There are well-known models of computation:
            \begin{plist}
                \item Turing machines
                \item Lambda calculi
                \item Boolean circuits
            \end{plist}
        \end{plist}
        \item In reality:
        \begin{plist}
            \item Computation is whatever a computer does.
            \item Computers are implemented as digital/electronic circuits.
            \item The basic building blocks are boolean logic gates.
            \item They manipulate bits (0s and 1s).
        \end{plist}
        \item Shouldn't they follow laws of physics?
    \end{plist}
\end{frame}

\begin{frame}[fragile]{The Physical Nature of Computation}
    \begin{plist}
        \item Computation is a physical process (Landauer 1987).
        \item Computers are physical devices that manipulate bits, they consume
        energy to do computation, and laws of thermodynamics apply.
        \item We can use information-theoretic notions of entropy to understand
        the physical nature of computation.
        \item Landauer's princple: any logically irreversible manipulation of
        information increases the entropy of a system.
        \item A logic gate is simply a boolean function: $\{0,1\}^k \to \{0,1\}$.
        \item This throws away information about its input, and generates
        entropy ($kT\term{ln}(2)$ for each bit).
        \item Conventional models of computation, such as Boolean circuits,
        Turing machines, $\lambda$-calculus, use irreversible primitives for
        computation.
        \item We can have logically-reversible models of computation:
        \begin{plist}
            \item Reversible Turing machines (Bennett 1970)
            \item Reversible Logic gates (Toffoli 1980)
        \end{plist}
        \item What is the $\lambda$-calculus of reversible computing?
    \end{plist}
\end{frame}

\begin{frame}[fragile]{Reversible Computing}
    \begin{plist}
        \item Reversible computing is about programming with sequences of
        reversible operations, which run on (non-existent)
        thermodynamically-reversible computers.
        \item Obviously, we need to:
        \begin{plist}
            \item understand their categorical semantics
            \item design high-level programming languages for them
        \end{plist}
    \end{plist}
\end{frame}

\begin{frame}{Computational View}
    \begin{plist}
        \item G\"{o}del-Church-Turing -- Recursive functions, Turing-computable functions, (Untyped) Lambda Calculus programs
        \item Scwichtenberg, Leivant -- Simply-typed lambda calculus, extended polynomials

        \item Landauer's Principle -- computation is a physical process, any logically irreversible manipulation of information increases the entropy of a system.
        \item Landauer's Limit -- there is a theoretical limit to the energy consumption of computation.
        \item Bennett -- Computation in Turing Machines is logically irreversible. Propose Reversible Turing Machines, partially injective functions
        \item Fredkin, Toffoli -- Conservative Logic

        \item Sabry et. al. -- Simply-typed calculus of isomorphisms ($\PiLang$)
        \item Today -- $\PiLang$, bijective functions~\footnote{the name is
            confusing, also $\PiLang^0$, or Theseus}
    \end{plist}
\end{frame}

\begin{frame}{Logical View}
    \begin{plist}
        \item Curry, Howard, Scott, Lambek:
        \begin{plist}
            \item   Simply-typed lambda calculus $\cox$ Intuitionistic Logic $\cox$ Cartesian Closed Categories
        \end{plist}
        \item Linear Logic, Linear lambda calculi $\cox$ Seely Categories, Linear-Non-Linear Adjunctions
        \item Extensional Type Theory $\cox$ 1-toposes
        \item Homotopy Type Theory $\cox$ $\infty$-toposes
        \item Quantum Computing $\cox$ Dagger Symmetric Monoidal Categories

        \item Today -- $\PiLang$, Symmetric Rig Groupoids
    \end{plist}
\end{frame}

% \begin{frame}{What's really going on?}
%     Bird's-eye view:
%     \begin{plist}
%         \item Reversible Programs (upto equality) are morphisms in the Free Symmetric Rig Groupoid on Zero Generators
%         \item The Free Symmetric Rig Groupoid on Zero Generators is equivalent to the Groupoid of Finite Sets and Bijections (upto homotopy)
%         \item We need a few tricks to prove it, but the proof is quite elegant:
%         \[
%             \FSR[0] \eqv \FSM[1] \eqv \term{PROP} \eqv \sqcup_{n}\B{\Sn} \eqv \sqcup_{n}\B{\term{L_{n}}} \eqv \term{FinBij}
%         \]
%         \begin{plist}
%             \item Use distributivity to turn products into sums
%             \item Strictify sums of units to unary natural numbers, and big swaps to adjacent swaps
%             \item Count adjacent transpositions to produce words in $\Sn$, and decide equality of words
%             \item Normal forms of words in $\Sn$ correspond to codes for permutations
%             \item Run permutation codes to produce bijections between finite sets
%             \item Each step is a coherent equivalence
%         \end{plist}
%     \end{plist}
% \end{frame}

% \begin{frame}{What is a programming language?}
%     Proof theory: a bunch of syntax and rules to generate and manipulate syntax

%     Model theory: mathematical models for syntax
% \end{frame}

\begin{frame}{What makes a programming language good?}
    \begin{plist}
        \item The language has models
        \item The language is logically consistent
        \item The language is complete with respect to a class of models
        \item The syntactic and mathematical models (strongly) agree
        \item Programs have normal forms
        \item Equivalence of programs is decidable/axiomatisable
    \end{plist}

    I'm going to describe a good reversible programming language.
\end{frame}

\begin{frame}[fragile]{Boolean Circuits}
    A boolean gate computes a function $f : \Set{0,1}^{k} \to \Set{0,1}$.

    \bigskip

    \begin{figure}
        \begin{subfigure}[b]{0.3\textwidth}
            \centering
            \begin{circuitikz}
                \draw (0,0) node[xor port](xor1){}
                (xor1.in 1) node[anchor=east] {$q_{1}$}
                (xor1.in 2) node[anchor=east] {$q_{0}$}
                ;
            \end{circuitikz}
        \end{subfigure}
        \begin{subfigure}[b]{0.3\textwidth}
            \[
                \begin{array}{c|c|c}
                    \term{q_0} & \term{q_1} & \term{q_1 + q_0} \\
                    \hline
                    0          & 0          & 0                \\
                    0          & 1          & 1                \\
                    1          & 0          & 1                \\
                    1          & 1          & 0
                \end{array}
            \]
        \end{subfigure}
    \end{figure}
\end{frame}

\begin{frame}[fragile]{Reversible Boolean Circuits: CNOT}
    A reversible boolean gate computes a permutation $f : \Set{0,1}^{k} \to \Set{0,1}^{k}$.

    \bigskip

    CNOT

    \begin{figure}
        \begin{subfigure}[b]{0.3\textwidth}
            \centering
            \begin{tikzpicture}
                \begin{yquant}
                    qubit {${\term{q_{\idx}}}$} q[2];
                    cnot q[1] | q[0];
                \end{yquant}
            \end{tikzpicture}
        \end{subfigure}
        \begin{subfigure}[b]{0.3\textwidth}
            \centering
            \[
                \begin{array}{c|c|c|c}
                    \term{q_0} & \term{q_1} & \term{q_0} & \term{q_1 + q_0} \\
                    \hline
                    0          & 0          & 0          & 0                \\
                    0          & 1          & 0          & 1                \\
                    1          & 0          & 1          & 1                \\
                    1          & 1          & 1          & 0
                \end{array}
            \]
        \end{subfigure}
        \begin{subfigure}[b]{0.3\textwidth}
            \centering
            \[
                \begin{pmatrix}
                    0 & 1 & 2 & 3 \\
                    0 & 1 & 3 & 2
                \end{pmatrix}
            \]
        \end{subfigure}
    \end{figure}
\end{frame}

\begin{frame}[fragile]{Reversible Boolean Circuits: TOFFOLI/CCNOT}
    TOFFOLI

    \begin{figure}
        \begin{subfigure}[b]{0.2\textwidth}
            \centering
            \begin{tikzpicture}
                \begin{yquant}
                    qubit {${\term{q_{\idx}}}$} q[3];
                    cnot q[2] | q[1, 0];
                \end{yquant}
            \end{tikzpicture}
        \end{subfigure}
        \begin{subfigure}[b]{0.4\textwidth}
            \centering
            \[
                \begin{array}{c|c|c|c|c|c}
                    \term{q_0} & \term{q_1} & \term{q_2} & \term{q_0} & \term{q_1} & \term{q_2 + q_0 \cdot q_1} \\
                    \hline
                    0          & 0          & 0          & 0          & 0          & 0                          \\
                    0          & 0          & 1          & 0          & 0          & 1                          \\
                    0          & 1          & 0          & 0          & 1          & 0                          \\
                    0          & 1          & 1          & 0          & 1          & 1                          \\
                    1          & 0          & 0          & 1          & 0          & 0                          \\
                    1          & 0          & 1          & 1          & 0          & 1                          \\
                    1          & 1          & 0          & 1          & 1          & 1                          \\
                    1          & 1          & 1          & 1          & 1          & 0
                \end{array}
            \]
        \end{subfigure}
        \begin{subfigure}[b]{0.3\textwidth}
            \centering
            \[
                \begin{pmatrix}
                    0 & 1 & 2 & 3 & 4 & 5 & 6 & 7 \\
                    0 & 1 & 2 & 3 & 4 & 5 & 7 & 6
                \end{pmatrix}
            \]
        \end{subfigure}
    \end{figure}
\end{frame}

\begin{frame}[fragile]{Reversible Boolean Circuits: FREDKIN}
    FREDKIN

    \begin{figure}
        \begin{subfigure}[b]{0.2\textwidth}
            \centering
            \begin{tikzpicture}
                \begin{yquant}
                    qubit {${\term{q_{\idx}}}$} q[3];
                    swap (q[1, 2]);
                \end{yquant}
            \end{tikzpicture}
        \end{subfigure}
        \begin{subfigure}[b]{0.4\textwidth}
            \centering
            \[
                \begin{array}{c|c|c|c|c|c}
                    \term{q_0} & \term{q_1} & \term{q_2} & \term{q_0} & \term{q_0} & \term{q_2 + q_0 \cdot q_1} \\
                    \hline
                    0          & 0          & 0          & 0          & 0          & 0                          \\
                    0          & 0          & 1          & 0          & 0          & 1                          \\
                    0          & 1          & 0          & 0          & 1          & 0                          \\
                    0          & 1          & 1          & 0          & 1          & 1                          \\
                    1          & 0          & 0          & 1          & 0          & 0                          \\
                    1          & 0          & 1          & 1          & 0          & 1                          \\
                    1          & 1          & 0          & 1          & 1          & 1                          \\
                    1          & 1          & 1          & 1          & 1          & 0
                \end{array}
            \]
        \end{subfigure}
        \begin{subfigure}[b]{0.3\textwidth}
            \centering
            \[
                \begin{pmatrix}
                    0 & 1 & 2 & 3 & 4 & 5 & 6 & 7 \\
                    0 & 1 & 2 & 3 & 4 & 5 & 7 & 6
                \end{pmatrix}
            \]
        \end{subfigure}
    \end{figure}
\end{frame}

% \begin{frame}[fragile]{Motivation: Reversible Computing}
% \bigskip
% \begin{agda-code}
% add : Int -> Int -> Int
% add = lambda x. lambda y. x + y
% \end{agda-code}
% \bigskip
% \[
%     \tikzmarknode{A}{\mathsf{add}}\;
%     \tikzmarknode{B}{2}\;
%     \tikzmarknode{C}{2}\;
%     \astarrow\;
%     \tikzmarknode{D}{4}
%     \begin{tikzpicture}[overlay, remember picture,shorten <=1mm,
%             nodes={inner sep=1pt, align=center, font=\footnotesize}]
%         \draw (B.south) -- ++ (-1,-1) node[below] {2 bits};
%         \draw (C.south) -- ++ (-.5,-1) node[below] {2 bits};
%         \draw (D.south) -- ++ (.5,-1) node[below] {3 bits};
%     \end{tikzpicture}
%     \vspace{3ex}
% \]
% \pause
% \btVFill
% We can make it reversible by adding ancilla bits!
% \end{frame}

\begin{frame}{A reversible programming language with finite types: $\PiLang$}
    \bigskip

    {\scalebox{\scalef}{$%
                \begin{array}{lrcl}
                    \textit{Value types}   & A,B & ::= & \zerot \alts \onet \alts A+B \alts A\times B        \\
                    \textit{Values}        & v,w & ::= & \Acon{tt} \alts \inlv{v} \alts \inrv{v} \alts (v,w) \\
                    \textit{Program types} &     &     & A \isoone B                                         \\
                    \textit{Programs}      & c   & ::= &
                \end{array}$}}

    \begin{figure}
        {\scalebox{\scalef}{$%
                    %%\noindent\begin{minipage}{.7\linewidth}
                    \begin{array}{rrcll}
                        \idc :     & A                     & \isoone & A                            & : \idc      \\ [1.5ex]
                        \identlp : & \zerot + A            & \isoone & A                            & : \identrp  \\
                        \swapp :   & A + B                 & \isoone & B + A                        & : \swapp    \\
                        \assoclp : & A + (B + C)           & \isoone & (A + B) + C                  & : \assocrp  \\ [1.5ex]
                        \identlt : & \onet \times A        & \isoone & A                            & : \identrt  \\
                        \swapt :   & A \times B            & \isoone & B \times A                   & : \swapt    \\
                        \assoclt : & A \times (B \times C) & \isoone & (A \times B) \times C        & : \assocrt  \\ [1.5ex]
                        \absorbr : & ~ \zerot \times A     & \isoone & \zerot ~                     & : \factorzl \\
                        \dist :    & ~ (A + B) \times C    & \isoone & (A \times C) + (B \times C)~ & : \factor
                    \end{array}$}}

        \bigskip

        {\scalebox{\scalef}{%
                \Rule{}
                {\jdg{}{}{c_1 : A \isoone B} \quad \vdash c_2 : B \isoone C}
                {\jdg{}{}{c_1 \circledcirc c_2 : A \isoone C}}
                {}

                \Rule{}
                {\jdg{}{}{c_1 : A \isoone B} \quad \vdash c_2 : C \isoone D}
                {\jdg{}{}{c_1 \oplus c_2 : A + C \isoone B + D}}
                {}

                \Rule{}
                {\jdg{}{}{c_1 : A \isoone B} \quad \vdash c_2 : C \isoone D}
                {\jdg{}{}{c_1 \otimes c_2 : A \times C \isoone B \times D}}
                {}
            }}
        \caption{$\PiLang$ syntax}
        \label{fig:pi}
    \end{figure}
\end{frame}

\begin{frame}[fragile]{Reversible Boolean Circuits: 3-bit Toffoli gate}
    \bigskip

    \controlled{}
    \medskip
    \cnot{}
    \medskip
    \toffolithree{}
\end{frame}

\begin{frame}{Semantics of $\PiLang$}
    \begin{center}
        \begin{tabular}[t]{c @{\hspace{5em}} c}
            {\scalebox{\scalef}{
                    \begin{tabular}[t]{>{$}r<{$} @{\hspace{4pt}} >{$}l<{$} >{$}c<{$} >{$}l<{$}}
                        \denotbox{\identlp} & (\inl{v})         & = & v               \\
                        \denotbox{\identrp} & v                 & = & \inl{v}         \\
                        \denotbox{\swapp}   & (\inl{v})         & = & \inr{v}         \\
                        \denotbox{\swapp}   & (\inr{v})         & = & \inl{v}         \\
                        \denotbox{\assoclp} & (\inl{v})         & = & \inl{(\inl{v})} \\
                        \denotbox{\assoclp} & (\inr{(\inl{v})}) & = & \inl{(\inr{v})} \\
                        \denotbox{\assoclp} & (\inr{(\inr{v})}) & = & \inr{v}         \\
                        \denotbox{\assocrp} & (\inl{(\inl{v})}) & = & \inl{v}         \\
                        \denotbox{\assocrp} & (\inl{(\inr{v})}) & = & \inr{(\inl{v})} \\
                        \denotbox{\assocrp} & (\inr{v})         & = & \inr{(\inr{v})}
                    \end{tabular}}}
             &
            {\scalebox{\scalef}{
                        \begin{tabular}[t]{>{$}r<{$} @{\hspace{4pt}} >{$}l<{$} >{$}c<{$} >{$}l<{$}}
                            \denotbox{\identlt} & (\ttt , v)          & = & v                   \\
                            \denotbox{\identrt} & v                   & = & (\ttt , v)          \\
                            \denotbox{\swapt}   & (v_1 , v_2)         & = & (v_2 , v_1)         \\
                            \denotbox{\assoclt} & (v_1 , (v_2 , v_3)) & = & ((v_1 , v_2) , v_3) \\
                            \denotbox{\assocrt} & ((v_1 , v_2) , v_3) & = & (v_1 , (v_2 , v_3)) \\
                            \denotbox{\dist}    & (\inl{v_1} , v_3)   & = & \inl{(v_1 , v_3)}   \\
                            \denotbox{\dist}    & (\inr{v_2 , v_3})   & = & \inr{(v_2 , v_3)}   \\
                            \denotbox{\factor}  & (\inl{(v_1 , v_3)}) & = & (\inl{v_1} , v_3)   \\
                            \denotbox{\factor}  & (\inr{(v_2 , v_3)}) & = & (\inr{v_2} , v_3)   \\
                            \denotbox{\idc}     & v                   & = & v
                        \end{tabular}}}
        \end{tabular}
    \end{center}

    \begin{center}
        {\scalebox{\scalef}{
                \begin{tabular}[t]{>{$}r<{$} @{\hspace{4pt}} >{$}l<{$} >{$}c<{$} >{$}l<{$}}
                    \denotbox{(c_1 \circledcirc c_2)} & v           & = & \denot{c_2} (\denot{c_1}~v)         \\
                    \denotbox{(c_1 \oplus c_2)}       & (\inl{v})   & = & \inl{(\denot{c_1}~v)}               \\
                    \denotbox{(c_1 \oplus c_2)}       & (\inr{v})   & = & \inr{(\denot{c_2}~v)}               \\
                    \denotbox{(c_1 \otimes c_2)}      & (v_1 , v_2) & = & (\denot{c_1}~v_1 , \denot{c_2}~v_2)
                \end{tabular}}}
    \end{center}
    \pause
    \btVFill
    Does it compute every bijection?
\end{frame}

\begin{frame}[fragile]{Permutations as tree transformations}
    \bigskip

    \begin{figure}
        \begin{subfigure}[b]{0.95\textwidth}
            \centering
            \[
                \Tree [ {\tiny A} [ {\tiny B} {\tiny C} ] ] ~\xrightarrow{\assoclp}~
                \Tree [ [ {\tiny A} {\tiny B} ] {\tiny C} ] ~\xrightarrow{\swapp}~
                \Tree [ {\tiny C} [ {\tiny A} {\tiny B} ] ] ~\xrightarrow[\phantom{xx}\swapp]{\idc\phantom{xx}}~
                \Tree [ {\tiny C} [ {\tiny B} {\tiny A} ] ] ~
            \]
            \caption{$p_1$}
        \end{subfigure}
        \btVFill
        \begin{subfigure}[b]{0.95\textwidth}
            \centering
            \[
                \Tree [ {\tiny A} [ {\tiny B} {\tiny C} ] ] ~\xrightarrow[\phantom{xx}\swapp]{\idc\phantom{xx}}~
                \Tree [ {\tiny A} [ {\tiny C} {\tiny B} ] ] ~\xrightarrow{\assoclp}~
                \Tree [ [ {\tiny A} {\tiny C} ] {\tiny B} ] ~\xrightarrow[\swapp\phantom{x}]{\phantom{x}\idc}~
                \Tree [ [ {\tiny C} {\tiny A} ] {\tiny B} ] ~\xrightarrow{\assocrp}~
                \Tree [ {\tiny C} [ {\tiny A} {\tiny B} ] ] ~\xrightarrow[\phantom{xx}\swapp]{\idc\phantom{xx}}~
                \Tree [ {\tiny C} [ {\tiny B} {\tiny A} ] ] ~
            \]
            \caption{$p_2$}
        \end{subfigure}
    \end{figure}
    \pause
    \btVFill
    Can we find a sound and complete set of equations to decide when two programs are equal?
\end{frame}

\begin{frame}[fragile]{Equational theory: Examples of 2-combinators}
    \bigskip

    \begin{figure}
        {\scalebox{\scalef}{
                \Rule{}
                {\jdg{}{}{c_1 : A \isoone B} \quad {\vdash c_2 : A \isoone B}}
                {\jdg{}{}{c_1 \isotwo c_2}}
                {}
            }}
    \end{figure}
    \pause
    \medskip

    \begin{figure}
        {\scalebox{\scalef}{$%
                    %%\noindent\begin{minipage}{.7\linewidth}
                    \begin{array}{rrcll}
                        \AIC{idâŸ·â‚‚} :     & c                                       & \isotwo & c                                       & : \AIC{idâŸ·â‚‚}     \\ [1.5ex]
                        \AIC{assocâ—Žl} :  & c_1 \circledcirc (c_2 \circledcirc c_3) & \isotwo & (c_1 \circledcirc c_2) \circledcirc c_3 & : \AIC{assocâ—Žr}  \\ [1.5ex]
                        \AIC{idlâ—Žl} :    & \idc \circledcirc c                     & \isotwo & c                                       & : \AIC{idlâ—Žr}    \\
                        \AIC{idrâ—Žl} :    & c \circledcirc \idc                     & \isotwo & c                                       & : \AIC{idrâ—Žr}    \\
                        \AIC{linvâ—Žl} :   & c \circledcirc \AIC{!âŸ·â‚} c              & \isotwo & \idc                                    & : \AIC{linvâ—Žr}   \\
                        \AIC{swaplâ‚ŠâŸ·â‚‚} : & \swapp \circledcirc (c_1 \oplus c_2)    & \isotwo & (c_2 \oplus c_1) \circledcirc \swapp    & : \AIC{swaprâ‚ŠâŸ·â‚‚}
                    \end{array}$}}

        \bigskip

        {\scalebox{\scaleff}{$%
                    %%\noindent\begin{minipage}{.7\linewidth}
                    \begin{array}{rrcll}
                        \AIC{pentagonâ‚Šl} : & \assocrp \circledcirc \assocrp                       & \isotwo & ((\assocrp \oplus \idc) \circledcirc \assocrp) \circledcirc (\idc \oplus \assocrp) & : \AIC{pentagonâ‚Šr} \\
                        \AIC{hexagonlâ‚Šl} : & (\assoclp \circledcirc \swapp) \circledcirc \assoclp & \isotwo & ((\idc \oplus \swapp) \circledcirc \assoclp) \circledcirc (\swapp \oplus \idc)     & : \AIC{hexagonlâ‚Šr}
                    \end{array}$}}

        \bigskip

        {\scalebox{\scalef}{%
                \Rule{}
                {\jdg{}{}{\alpha_1 : c_1 \isotwo c_2} \quad \vdash \alpha_2 : c_2 \isotwo c_3}
                {\jdg{}{}{\alpha_1\;\blacksquare\;\alpha_2 : c_1 \isotwo c_3}}
                {}

                \Rule{}
                {\jdg{}{}{\alpha_1 : c_1 \isotwo c_3} \quad \vdash \alpha_2 : c_2 \isotwo c_4}
                {\jdg{}{}{\alpha_1\;\boxdot\;\alpha_2 : (c_1 \circledcirc c_2) \isotwo (c_3 \circledcirc c_4)}}
                {}
            }}
    \end{figure}
\end{frame}

\begin{frame}[fragile]{Solving the example}
    \leveltwoexample{}

    % https://q.uiver.app/?q=WzAsOCxbMCwwLCJBICsgKEIgKyBDKSJdLFsyLDAsIihBICsgQikgKyBDIl0sWzQsMCwiQyArIChBICsgQikiXSxbNiwwLCJDICsgKEIgKyBBKSJdLFswLDIsIkEgKyAoQyArIEIpIl0sWzIsMiwiKEEgKyBDKSArIEIiXSxbNCwyLCIoQyArIEEpICsgQiJdLFs2LDIsIkMgKyAoQSArIEIpIl0sWzAsMSwiXFxhc3NvY2xwIl0sWzEsMiwiXFxzd2FwcCJdLFsyLDMsIlxcaWRjflxcb3BsdXN+XFxzd2FwcCJdLFswLDQsIlxcaWRjflxcb3BsdXN+XFxzd2FwcCIsMl0sWzQsNSwiXFxhc3NvY2xwIiwyXSxbNSw2LCJcXHN3YXBwflxcb3BsdXN+XFxpZGMiLDJdLFs2LDcsIlxcYXNzb2NycCIsMl0sWzMsNywiXFxpZGN+XFxvcGx1c35cXHN3YXBwIl0sWzIsNiwiXFxhc3NvY2xwIiwyXV0=
    \[\begin{tikzcd}[ampersand replacement=\&]
            {A + (B + C)} \&\& {(A + B) + C} \&\& {C + (A + B)} \&\& {C + (B + A)} \\
            \\
            {A + (C + B)} \&\& {(A + C) + B} \&\& {(C + A) + B} \&\& {C + (A + B)}
            \arrow["\assoclp", from=1-1, to=1-3]
            \arrow["\swapp", from=1-3, to=1-5]
            \arrow["{\idc~\oplus~\swapp}", from=1-5, to=1-7]
            \arrow["{\idc~\oplus~\swapp}"', from=1-1, to=3-1]
            \arrow["\assoclp"', from=3-1, to=3-3]
            \arrow["{\swapp~\oplus~\idc}"', from=3-3, to=3-5]
            \arrow["\assocrp"', from=3-5, to=3-7]
            \arrow["{\idc~\oplus~\swapp}", from=1-7, to=3-7]
            \arrow["\assoclp"', from=1-5, to=3-5]
        \end{tikzcd}\]
\end{frame}

\begin{frame}
    This language is too complicated, let's start from a very simple language.
\end{frame}

\begin{frame}[fragile]{A reversible language with 2 bits, $\PiLang_2$}
    {\scalebox{\scalef}{$%
                \begin{array}{lrcl}
                    \textit{Value types}   & A,B & ::= & \boolt                    \\
                    \textit{Values}        & v,w & ::= & \Acon{ff} \alts \Acon{tt} \\
                    \textit{Program types} &     &     & A \isoone B               \\
                    \textit{Programs}      & c   & ::= &
                \end{array}$}}

    \begin{figure}
        {\scalebox{\scalef}{$%
                    %%\noindent\begin{minipage}{.7\linewidth}
                    \begin{array}{rrcll}
                        \idc :   & A      & \isoone & A      & : \idc   \\ [1.5ex]
                        \swapb : & \boolt & \isoone & \boolt & : \swapp \\
                    \end{array}$}}

        \bigskip

        {\scalebox{\scalef}{%
                \Rule{}
                {\jdg{}{}{c_1 : A \isoone B} \quad \vdash c_2 : B \isoone C}
                {\jdg{}{}{c_1 \circledcirc c_2 : A \isoone C}}
                {}
            }}
    \end{figure}

    \begin{figure}
        {\scalebox{\scalef}{$%
                    %%\noindent\begin{minipage}{.7\linewidth}
                    \begin{array}{rrcll}
                        \AIC{idâŸ·â‚‚} :        & c                                       & \isotwo & c                                       & : \AIC{idâŸ·â‚‚}        \\ [1.5ex]
                        \AIC{assocâ—Žl} :     & c_1 \circledcirc (c_2 \circledcirc c_3) & \isotwo & (c_1 \circledcirc c_2) \circledcirc c_3 & : \AIC{assocâ—Žr}     \\ [1.5ex]
                        \AIC{idlâ—Žl} :       & \idc \circledcirc c                     & \isotwo & c                                       & : \AIC{idlâ—Žr}       \\
                        \AIC{idrâ—Žl} :       & c \circledcirc \idc                     & \isotwo & c                                       & : \AIC{idrâ—Žr}       \\
                        \AIC{linvâ—Žl} :      & c \circledcirc \AIC{!âŸ·â‚} c              & \isotwo & \idc                                    & : \AIC{linvâ—Žr}      \\
                        \AIC{swapâ‚‚â—Žswapâ‚‚} : & \swapb \circledcirc \swapb              & \isotwo & \idc                                    & : \AIC{swapâ‚‚â—Žswapâ‚‚}
                    \end{array}$}}

        \bigskip

        {\scalebox{\scalef}{%
                \Rule{}
                {\jdg{}{}{\alpha_1 : c_1 \isotwo c_2} \quad \vdash \alpha_2 : c_2 \isotwo c_3}
                {\jdg{}{}{\alpha_1\;\blacksquare\;\alpha_2 : c_1 \isotwo c_3}}
                {}

                \Rule{}
                {\jdg{}{}{\alpha_1 : c_1 \isotwo c_3} \quad \vdash \alpha_2 : c_2 \isotwo c_4}
                {\jdg{}{}{\alpha_1\;\boxdot\;\alpha_2 : (c_1 \circledcirc c_2) \isotwo (c_3 \circledcirc c_4)}}
                {}
            }}
    \end{figure}
\end{frame}

\begin{frame}[fragile]{Semantics of $\PiLang_2$}
    \begin{plist}
        \item Obviously, there should only be two reversible programs on $\boolt$, upto equivalence.
        \item For every $p : \boolt \isoone \boolt$, either $p \isotwo \idc$ or $p \isotwo \swapb$.
        \item How can we prove it?
    \end{plist}
\end{frame}

\begin{frame}[fragile]{Semantics of $\PiLang_2$}
    \begin{plist}
        \item Idea: we're simply describing the groupoid $\B{\mathbb{Z}_2}$, where $\mathbb{Z}_2$ is the automorphism group of $\boolt$.
        \item In HoTT, automorphism groups and their deloopings have a special encoding.
        \item The automorphism group of $T$ is $\Aut[T] \defeq T \eqv T$.
        \item The delooping of the automorphism group of $T$ is $\BAut[T] \defeq \Sub{T}$.
    \end{plist}
    \begin{tblock}
        \begin{plist}
            \item $\pi_1 : \BAut[T] \to \UU$ is a univalent fibration.
            \item If $T$ is an n-type, then $\BAut[T]$ is an (n+1)-type.
            \item $\BAut[T]$ is 0-connected.
            \item $\loopspace[\BAut[T],T_0 \jdgeq (T,\refl)] \eqv \Aut[T]$.
        \end{plist}
    \end{tblock}
\end{frame}

\begin{frame}[fragile]{Semantics of $\PiLang_2$}
    \begin{plist}
        \item Now, we can use this to do NbE.
        \item Interpret 1-combinators as 1-paths in $\BAut[\boolt]$.
        \item Interpret 2-combinators as 2-paths in $\BAut[\boolt]$.
        \item For every $p : (\boolt_0 \id_{\BAut[\boolt]} \boolt_0)$,
        either $p \id \refl$, or $p \id \term{ua}(\term{not} : \boolt \eqv \boolt)$.
    \end{plist}
    \medskip
    What really happened?
    \[
        \loopspace[\BAut[\boolt],\boolt_0] \eqv \Aut[\boolt] \eqv \boolt
    \]
    But,
    \[
        \begin{array}{rcl}
            \Aut[\mathbb{3}] & \eqv   & \mathbb{6}  \\
            \Aut[\mathbb{4}] & \eqv   & \mathbb{24} \\
                             & \ldots &             \\
            \Aut[[n]]        & \eqv   & [n!]        \\
        \end{array}
    \]
    How do we go to $n$-bit languages?
\end{frame}

\begin{frame}{Several steps}
    We will go from $\PiLang$ to $\UFin$, the groupoid of finite sets and
    bijections, and back.
    \bigskip
    \bigskip
    \[
        \PiLang \eqv \PiPlusLang \eqv \PiHatLang \eqv \sqcup_n \B{\Sn} \eqv \sqcup_n \B{\mathcal{L}_n} \eqv \sqcup_n \BAut[\Fin[n]] \eqv \UFin
    \]
\end{frame}

\begin{frame}{$\PiLang$, or $\FSR[0]$}
    \bigskip

    {\scalebox{\scalef}{$%
                \begin{array}{lrcl}
                    \textit{Value types}   & A,B & ::= & \zerot \alts \onet \alts A+B \alts A\times B        \\
                    \textit{Values}        & v,w & ::= & \Acon{tt} \alts \inlv{v} \alts \inrv{v} \alts (v,w) \\
                    \textit{Program types} &     &     & A \isoone B                                         \\
                    \textit{Programs}      & c   & ::= &
                \end{array}$}}

    \begin{figure}
        {\scalebox{\scalef}{$%
                    %%\noindent\begin{minipage}{.7\linewidth}
                    \begin{array}{rrcll}
                        \idc :     & A                     & \isoone & A                            & : \idc      \\ [1.5ex]
                        \identlp : & \zerot + A            & \isoone & A                            & : \identrp  \\
                        \swapp :   & A + B                 & \isoone & B + A                        & : \swapp    \\
                        \assoclp : & A + (B + C)           & \isoone & (A + B) + C                  & : \assocrp  \\ [1.5ex]
                        \identlt : & \onet \times A        & \isoone & A                            & : \identrt  \\
                        \swapt :   & A \times B            & \isoone & B \times A                   & : \swapt    \\
                        \assoclt : & A \times (B \times C) & \isoone & (A \times B) \times C        & : \assocrt  \\ [1.5ex]
                        \absorbr : & ~ \zerot \times A     & \isoone & \zerot ~                     & : \factorzl \\
                        \dist :    & ~ (A + B) \times C    & \isoone & (A \times C) + (B \times C)~ & : \factor
                    \end{array}$}}

        \bigskip

        {\scalebox{\scalef}{%
                \Rule{}
                {\jdg{}{}{c_1 : A \isoone B} \quad \vdash c_2 : B \isoone C}
                {\jdg{}{}{c_1 \circledcirc c_2 : A \isoone C}}
                {}

                \Rule{}
                {\jdg{}{}{c_1 : A \isoone B} \quad \vdash c_2 : C \isoone D}
                {\jdg{}{}{c_1 \oplus c_2 : A + C \isoone B + D}}
                {}

                \Rule{}
                {\jdg{}{}{c_1 : A \isoone B} \quad \vdash c_2 : C \isoone D}
                {\jdg{}{}{c_1 \otimes c_2 : A \times C \isoone B \times D}}
                {}
            }}
    \end{figure}
    The 2-combinators are: groupoid laws, naturality, and coherence conditions of symmetric rig categories.
\end{frame}

% \begin{frame}[fragile]{$\PiLang$ or $\FSR[0]$}
%     \medskip
%     Points:
%     \begin{plist}
%         \item $\zero, \term{1} : \PiLang$
%         \item $\blank+\blank, \blank\times\blank : \PiLang \to \PiLang \to \PiLang$
%     \end{plist}
%     \medskip
%     1-paths:
%     \begin{plist}
%         \item $\term{\lambda_+} : x + 0 \id x$
%         \item $\term{\rho_+} : 0 + x \id x$
%         \item $\term{\alpha_+} : x + (y + z) \id (x + y) + z$
%         \item $\swap_+ : x + y \id y + x$
%         \item $\term{\lambda_\times} : x \times 1 \id x$
%         \item $\term{\rho_\times} : 1 \times x \id x$
%         \item $\term{\alpha_\times} : x \times (y \times z) \id (x \times y) \times z$
%         \item $\swap_\times : x \times y \id y \times x$
%     \end{plist}
%     \medskip
%     2-paths:
%     \begin{plist}
%         \item $\term{triangle}, \term{pentagon}, \term{hexagon}, \term{sym}, \term{dist}$
%     \end{plist}
% \end{frame}

% \begin{frame}[fragile]{$\PiPlusLang$ or $\FSM[1]$}
%     \medskip
%     Points:
%     \begin{plist}
%         \item $\zero, \term{1} : \PiPlusLang$
%         \item $\blank+\blank : \PiPlusLang \to \PiPlusLang \to \PiPlusLang$
%     \end{plist}
%     \medskip
%     1-paths:
%     \begin{plist}
%         \item $\term{\lambda} : x + 0 \id x$
%         \item $\term{\rho} : 0 + x \id x$
%         \item $\term{\alpha} : x + (y + z) \id (x + y) + z$
%         \item $\swap : x + y \id y + x$
%     \end{plist}
%     \medskip
%     2-paths:
%     \begin{plist}
%         \item $\term{triangle}, \term{pentagon}, \term{hexagon}, \term{sym}$
%     \end{plist}
% \end{frame}

\begin{frame}[fragile]{$\PiPlusLang$ or $\FSM[1]$}
    \medskip

    {\scalebox{\scalef}{$%
                \begin{array}{lrcl}
                    \textit{Value types}   & A,B & ::= & \zerot \alts \onet \alts A+B            \\
                    \textit{Values}        & v,w & ::= & \Acon{tt} \alts \inlv{v} \alts \inrv{v} \\
                    \textit{Program types} &     &     & A \isoone B                             \\
                    \textit{Programs}      & c   & ::= &
                \end{array}$}}

    \begin{figure}[t]
        {\scalebox{\scalef}{$
                    \begin{array}{rrcll}
                        \idc :     & A           & \isop & A           & : \idc     \\
                        \identlp : & \zerot + A  & \isop & A           & : \identrp \\
                        \swapp :   & A + B       & \isop & B + A       & : \swapp   \\
                        \assoclp : & A + (B + C) & \isop & (A + B) + C & : \assocrp \\ [1.5ex]
                    \end{array}$}}

        {\scalebox{\scalef}{
                \Rule{}
                {\jdg{}{}{c_1 : A \isop B} \quad \vdash c_2 : B \isop C}
                {\jdg{}{}{c_1 \circledcirc c_2 : A \isop C}}
                {}

                \Rule{}
                {\jdg{}{}{c_1 : A \isop B} \quad \vdash c_2 : C \isop D}
                {\jdg{}{}{c_1 \oplus c_2 : A + C \isop B + D}}
                {}
            }}
    \end{figure}
    The 2-combinators are: groupoid laws, naturality, and coherence conditions of symmetric monoidal categories.
\end{frame}

\begin{frame}{Step 1: $\PiLang$ to $\PiPlusLang$}
    \begin{plist}
        \item We show that $\PiPlusLang$ is a symmetric rig, then construct a
        symmetric rig functor $\PiLang$ \to $\PiPlusLang$.
        \item On types, build multiplication using iterated addition:
        \begin{align*}
            \zerot \times Y      & \defeq \zerot                      \\
            \onet \times Y       & \defeq Y                           \\
            (X_1 + X_2) \times Y & \defeq X_1 \times Y + X_2 \times Y
        \end{align*}
        \item On 1-combinators, use distributivity.
        \item To go back, use Laplaza coherence conditions for distributivity.
    \end{plist}
    \bigskip
    \begin{plist}
        \item We get a symmetric rig equivalence: $\PiLang \eqv \PiPlusLang$.
    \end{plist}
\end{frame}

% \begin{frame}[fragile]{$\PiHatLang$ or $\term{PROP}$}
%     \medskip
%     \begin{plist}
%         \item $\zero : \PiHatLang$
%         \item $\suc : \PiHatLang \to \PiHatLang$
%         \item $\swap : \suc[\suc[n]] \id \suc[\suc[n]]$
%         \item $\term{sym} : \swap \comp \swap \id \refl$
%         \item $\term{hexagon} : \swap \comp \ap{\suc}{\swap} \comp \swap \id \ap{\suc}{\swap} \comp \swap \comp \ap{\suc}{\swap}$
%     \end{plist}
% \end{frame}

\begin{frame}[fragile]{$\PiHatLang$, or the minimal $\term{PROP}$}
    \medskip

    {\scalebox{\scalef}{$%
                \begin{array}{lrcl}
                    \textit{Value types}   & A,B & ::= & \zerot \alts \suc[A]    \\
                    \textit{Values}        & v,w & ::= & \Acon{tt} \alts \suc[v] \\
                    \textit{Program types} &     &     & A \isoone B             \\
                    \textit{Programs}      & c   & ::= &
                \end{array}$}}

    \begin{figure}[t]
        {\scalebox{\scalef}{$
                    \begin{array}{rrcll}
                        \idc :   & n             & \isoh & n             & : \idc   \\
                        \swapc : & \suc[\suc[n]] & \isoh & \suc[\suc[n]] & : \swapc \\[1.5ex]
                    \end{array}
                $}}

        {\scalebox{\scalef}{
                \Rule{}
                {\jdg{}{}{c_1 : n \isoh m} \quad \vdash c_2 : m \isoh o}
                {\jdg{}{}{c_1 \circledcirc c_2 : n \isoh o}}
                {}

                \Rule{}
                {\jdg{}{}{c : n \isoh m}}
                {\jdg{}{}{\oplus(c) : \suc[n] \isoh \suc[m]}}
                {}
            }}
    \end{figure}

    The 2-combinators are: groupoid laws, naturality, a symmetry, and a minimal hexagon.

    \[
        \begin{array}{rcl}
            \term{\AIC{swapÂ²}} :   & \swapc \circledcirc \swapc \isotwo \idc                                                                                       & : \term{\AIC{swapÂ²}}   \\
            \term{\AIC{hexagon}} : & \swapc \circledcirc \suc[\swapc] \circledcirc \suc[\swapc] \isotwo \suc[\swapc] \circledcirc \swapc \circledcirc \suc[\swapc] & : \term{\AIC{hexagon}}
        \end{array}
    \]
\end{frame}

\begin{frame}[fragile]{$\PiHatLang$, or the minimal $\term{PROP}$}
    This is symmetric monoidal, small swaps inductively generate big swaps.

    \begin{plist}
        \item $\alpha : (n + m) + o \isoone n + (m + o)$
        \item $\lambda : 0 + n \isoone n$
        \item $\rho : n + 0 \isoone n$
        \item $\beta : n + m \isoone m + n$
        \item triangle, pentagon, and (big) hexagon
    \end{plist}

    \begin{figure}
        \[
            \Tree [ [ {\tiny 1} {\tiny n} ] {\tiny m} ] ~\xrightarrow{}~
            \Tree [ {\tiny 1} [ {\tiny n} {\tiny m} ] ] ~\xrightarrow{}~
            \Tree [ [ {\tiny n} {\tiny m} ] {\tiny 1} ] ~\xrightarrow{}~
            \Tree [ [ {\tiny m} {\tiny n} ] {\tiny 1} ] ~\xrightarrow{}~
            \Tree [ {\tiny m} [ {\tiny n} {\tiny 1} ] ] ~\xrightarrow{}~
            \Tree [ {\tiny m} [ {\tiny 1} {\tiny n} ] ] ~
        \]
    \end{figure}

    Hence we get $\PiPlusLang \to \PiHatLang$.
\end{frame}

\begin{frame}[fragile]{Step 2: $\PiPlusLang$ to $\PiHatLang$}
    To go back, use a big $\swap$ to produce a small swap (an adjacent transposition).
    \begin{figure}
        \[
            \Tree [ {\tiny $\onet$} [ {\tiny $\onet$} {\tiny X} ] ] ~\xrightarrow{\assoclp}~
            \Tree [ [ {\tiny $\onet$} {\tiny $\onet$} ] {\tiny X} ] ~\xrightarrow[\swapp\phantom{xx}]{\phantom{xx}\idc}~
            \Tree [ [ {\tiny $\onet$} {\tiny $\onet$} ] {\tiny X} ] ~\xrightarrow{\assocrp}~
            \Tree [ {\tiny $\onet$} [ {\tiny $\onet$} {\tiny X} ] ] ~
        \]
    \end{figure}
    \bigskip
    This gives a symmetric monoidal equivalence $\PiLang \eqv \PiPlusLang$.
\end{frame}

\begin{frame}[fragile]{Step 3: $\Omega(\PiHatLang,n)$}
    \begin{plist}
        \item Now, the loopspace of $\PiHatLang$ at each $n : \Nat$,
        $\Omega(\PiHatLang,n)$ has all the permutations, upto coherences.
        \item We will show that the loopspace of $\PiHatLang$ at $n : \Nat$ is
        equivalent to a presentation of the symmetric group $\Sn$.
        \item The generators will be sequences of adjacent transpositions, and
        relations will be Coxeter relations.
    \end{plist}
\end{frame}

\begin{frame}[fragile]{Step 3: $\Omega(\PiHatLang,n)$ to $\Sn$}
    The generators are encoded as $\List[\Fin[n]]$, and the relations are on $\List[\Fin[n]]$.
    \bigskip
    \begin{figure}
        \centering
        \begin{subfigure}[b]{0.25\textwidth}
            \centering
            \begin{tikzpicture}
                \pic[local bounding box=my braid,braid/.cd,
                    number of strands = 2,
                    width = 0.4cm,
                    height = 0.4cm,
                    border height = 0.3cm,
                    thick] at (0, 0)
                {braid={ s_1, s_1}};
                \node[font=\large] at (1, 0.7) {\(=\)};
                \pic[local bounding box=my braid,braid/.cd,
                    number of strands = 2,
                    width = 0.4cm,
                    height = 0.4cm,
                    border height = 0.3cm,
                    thick] at (1.6, 0)
                {braid={ 1, 1}};
            \end{tikzpicture}
            \caption{$\cancel$}
        \end{subfigure}
        \begin{subfigure}[b]{0.4\textwidth}
            \centering
            \begin{tikzpicture}
                \pic[local bounding box=my braid,braid/.cd,
                    number of strands = 2,
                    width = 0.4cm,
                    height = 0.4cm,
                    border height = 0.3cm,
                    thick] at (0, 0)
                {braid={ s_1, 1}};
                \node[] at (0.7, 0.7) {\(\dots\)};
                \pic[local bounding box=my braid,braid/.cd,
                    number of strands = 2,
                    width = 0.4cm,
                    height = 0.4cm,
                    border height = 0.3cm,
                    thick] at (1, 0)
                {braid={ 1, s_1 }};
                \node[font=\large] at (1.9, 0.7) {\(=\)};
                \pic[local bounding box=my braid,braid/.cd,
                    number of strands = 2,
                    width = 0.4cm,
                    height = 0.4cm,
                    border height = 0.3cm,
                    thick] at (2.4, 0)
                {braid={ 1, s_1}};
                \node[] at (3.1, 0.7) {\(\dots\)};
                \pic[local bounding box=my braid,braid/.cd,
                    number of strands = 2,
                    width = 0.4cm,
                    height = 0.4cm,
                    border height = 0.3cm,
                    thick] at (3.4, 0)
                {braid={ s_1, 1}};
            \end{tikzpicture}
            \caption{$\swap$}
        \end{subfigure}
        \begin{subfigure}[b]{0.25\textwidth}
            \centering
            \begin{tikzpicture}
                \pic[local bounding box=my braid,braid/.cd,
                    number of strands = 3,
                    width = 0.4cm,
                    height = 0.4cm,
                    border height = 0.1cm,
                    thick] at (0, 0)
                {braid={ s_2, s_1, s_2}};
                \node[font=\large] at (1.4, 0.7) {\(=\)};
                \pic[local bounding box=my braid,braid/.cd,
                    number of strands = 3,
                    width = 0.4cm,
                    height = 0.4cm,
                    border height = 0.1cm,
                    thick] at (2, 0)
                {braid={ s_1, s_2, s_1}};
            \end{tikzpicture}
            \caption{$\braid$}
        \end{subfigure}
    \end{figure}
    \begin{plist}[leftmargin=*]
        \item Swapping the same two elements twice in a row does nothing.
        \item When swapping two distinct pairs of elements, the order of
        swapping doesn't matter.
        \item Two ways of swapping the first and last elements in a sequence of
        three elements are the same.
    \end{plist}
    \bigskip
    They're not directed, but we can tweak them.
\end{frame}

\begin{frame}[fragile]{Step 3: $\Omega(\PiHatLang,n)$ to $\Sn$}
    \begin{dblock}[$\longcox : {\List[\Fin[n]]} \to {\List[\Fin[n]]} \to {\UU}$]
        \begin{align*}
            \longcancel
             & : \forall n, l, r \to (l \append n \cons n \cons r) \longcox (l \append r)                                                                      \\
            \longswap
             & : \forall n, k, l, r \to (\suc[k] < n) \to (l \append n \cons k \cons r) \longcox (l \append k \cons n \append r)                               \\
            \longbraid
             & : \forall n, k, l, r \to (l \append (n \downf 2 + k) \append (1 + k + n) \cons r) \longcox (l \append (k + n) \cons (n \downf 2 + k) \append r)
        \end{align*}
    \end{dblock}
    \bigskip
    \begin{plist}
        \item This gives a confluent and terminating rewriting system.
        \item For every $w$, there exists a unique normal form $v$ such that $w \longcoxstar v$.
        \item We get a unique choice function $\normf : \List[\Fin[n]] \to \List[\Fin[n]]$.
        \item For all $l : \List[\Fin[n]]$, we have that $l \longcoxstar \normf[l]$.
        \item We can choose a word in each equivalence class, giving \(\Sn \defeq \quot{\List(\Fin[n])}{\cox*} \eqv \im{\normf}\).
    \end{plist}
\end{frame}

\begin{frame}[fragile]{Example: permutations as braid diagrams}

    \begin{figure}
        \begin{subfigure}[b]{0.45\textwidth}
            \centering
            \begin{tikzpicture}
                \def\nstrandsdf{3}
                \pic[local bounding box=my braid,braid/.cd,
                    number of strands = \nstrandsdf,
                    width = 0.8cm,
                    height = 0.3cm,
                    border height = 0.1cm,
                    thick,
                    name prefix=braid]
                {braid={s_2, s_2, s_2, s_1, s_2}};
                %   \draw[thick] % draws the top/bottom bars
                % ([xshift=-1ex]my braid.north west) --  ([xshift=1ex]my braid.north east)
                % ([xshift=-1ex]my braid.south west) --  ([xshift=1ex]my braid.south east);
                \node at (braid-1-s)[yshift = 2.0cm] {\tiny A};
                \node at (braid-2-s)[yshift = 2.0cm] {\tiny B};
                \node at (braid-3-s)[yshift = 2.0cm] {\tiny C};

                % labels the bottom bar
                \node at (braid-1-e)[yshift = -2.0cm] {\tiny A};
                \node at (braid-2-e)[yshift = -2.0cm] {\tiny B};
                \node at (braid-3-e)[yshift = -2.0cm] {\tiny C};
            \end{tikzpicture}
            \caption{$p_1 \mapsto [1,0,1,1,1]$}
        \end{subfigure}
        \begin{subfigure}[b]{0.45\textwidth}
            \centering
            \begin{tikzpicture}
                \def\nstrandsdf{3}
                \pic[local bounding box=my braid,braid/.cd,
                    number of strands = \nstrandsdf,
                    width = 0.8cm,
                    height = 0.3cm,
                    border height = 0.1cm,
                    thick,
                    name prefix=braid]
                {braid={1, s_2,, s_1, s_2, 1}};
                %   \draw[thick] % draws the top/bottom bars
                % ([xshift=-1ex]my braid.north west) --  ([xshift=1ex]my braid.north east)
                % ([xshift=-1ex]my braid.south west) --  ([xshift=1ex]my braid.south east);
                \node at (braid-1-s)[yshift = 2.0cm] {\tiny A};
                \node at (braid-2-s)[yshift = 2.0cm] {\tiny B};
                \node at (braid-3-s)[yshift = 2.0cm] {\tiny C};

                % labels the bottom bar
                \node at (braid-1-e)[yshift = -2.0cm] {\tiny A};
                \node at (braid-2-e)[yshift = -2.0cm] {\tiny B};
                \node at (braid-3-e)[yshift = -2.0cm] {\tiny C};
            \end{tikzpicture}
            \caption{$p_2 \mapsto [1,0,1]$}
        \end{subfigure}
        \pause
        \begin{subfigure}[b]{0.3\textwidth}
            \centering
            \begin{tikzpicture}
                \def\nstrandsdf{3}
                \pic[local bounding box=my braid,braid/.cd,
                    number of strands = \nstrandsdf,
                    width = 0.8cm,
                    height = 0.3cm,
                    border height = 0.1cm,
                    thick,
                    name prefix=braid]
                {braid={1, s_1,, s_2, s_1, 1}};
                %   \draw[thick] % draws the top/bottom bars
                % ([xshift=-1ex]my braid.north west) --  ([xshift=1ex]my braid.north east)
                % ([xshift=-1ex]my braid.south west) --  ([xshift=1ex]my braid.south east);
                \node at (braid-1-s)[yshift = 2.0cm] {\tiny A};
                \node at (braid-2-s)[yshift = 2.0cm] {\tiny B};
                \node at (braid-3-s)[yshift = 2.0cm] {\tiny C};

                % labels the bottom bar
                \node at (braid-1-e)[yshift = -2.0cm] {\tiny A};
                \node at (braid-2-e)[yshift = -2.0cm] {\tiny B};
                \node at (braid-3-e)[yshift = -2.0cm] {\tiny C};
            \end{tikzpicture}
            \caption{Normal form: $[0,1,0]$}
        \end{subfigure}
    \end{figure}
\end{frame}

\begin{frame}{Step 4: $\Sn$ to $\Lehmer[n]$}
    These normal forms are precisely permutation codes in a factorial number
    system.
    \bigskip
    \begin{dblock}[$\Lehmer : \Nat \to \UU$]
        \begin{align*}
            \Lehmer[\zero]   & \defeq \Fin[\suc[\zero]]                     \\
            \Lehmer[\suc[n]] & \defeq \Lehmer[n] \times \Fin[\suc[\suc[n]]]
        \end{align*}
    \end{dblock}

    \begin{dblock}[$\immersion_{n} : {\Lehmer[n]} \to {\List[\Fin[\suc[n]]]}$]
        \begin{align*}
            \immersion_{\zero}(\zero)    & \defeq \nil                                               \\
            \immersion_{\suc[n]}((r, l)) & \defeq \immersion_{n}(l) \append ((\suc[n] - r) \downf r)
        \end{align*}
    \end{dblock}
    \bigskip
    \begin{plist}
        \item $\immersion_{n} : \Lehmer[n] \to {\im{\normf}}$ has contractible fibers.
        \item $\Sn \eqv {\im{\normf}} \eqv \Lehmer[n]$.
    \end{plist}
\end{frame}

\begin{frame}{Transpositions to Permutations}
    \bigskip
    \[
        \begin{array}[]{ccccccc}
            (a\;b\;c) & \mapsto & (b\;a\;c) & \mapsto & (b\;c\;a) & \mapsto & (c\;b\;a) \\
                      &         &           &         &           &         &           \\
                      & 0       &           & 1       &           & 0                   \\
        \end{array}
    \]
    \btVFill
    \pause
    \begin{center}
        This produces a Lehmer code: $(0\;1\;2)$
    \end{center}
    \pause
    \bigskip
    \[
        \begin{array}[]{ccccccc}
            0 & (a\;b\;c) \mapsto (a\;b\;c) \\
            1 & (a\;b\;c) \mapsto (b\;a\;c) \\
            2 & (b\;a\;c) \mapsto (c\;b\;a) \\
        \end{array}
    \]
    \btVFill
\end{frame}

\begin{frame}[fragile]{Step 5: $\Lehmer[n]$ to $\Aut[\Fin[\suc[n]]]$}
    Finally, run the Lehmer code to get:
    \[
        \Sn \eqv {\im{\normf}} \eqv \Lehmer[n] \eqv \Aut[\Fin[\suc[n]]]
    \]
\end{frame}

\begin{frame}{$\UFin$}
    \begin{plist}
        \item $\UFin \jdgeq \dsum*{X:\UU}{\dsum*{n:\Nat}{\Trunc{X \id \Fin[n]}}}$ is a 1-groupoid.
        \item $\UFin[n] \jdgeq \dsum*{X:\UU}{{\Trunc{X \id \Fin[n]}}}$ is a
        pointed, 0-connected, 1-groupoid, for every $n : \Nat$.
        \item $\UFin \eqv \dsum*{X:\UU}{\dsum*{n:\Nat}{\Trunc{X \id \Fin[n]}}} \eqv \dsum*{n:\Nat}{\dsum*{X:\UU}{\Trunc{X \id \Fin[n]}}}$
        \item $\pi_1 : \UFin \to \UU$ is a univalent fibration.
        \item $\Omega(\UFin[n],\Fin[n]) \eqv \Aut[\Fin[n]]$.
    \end{plist}

    Finally, we get the equivalence:
    \[
        \PiLang \eqv \PiPlusLang \eqv \PiHatLang \eqv \UFin
    \]
\end{frame}

\begin{frame}[fragile]{Normalisation by Evaluation}
    \begin{figure}
        \centering
        \scalebox{1.5}{
            % https://q.uiver.app/?q=WzAsNCxbMCwwLCJcXFBpTGFuZyJdLFsyLDAsIlxcUGlQbHVzTGFuZyJdLFs0LDAsIlxcUGlIYXRMYW5nIl0sWzYsMCwiXFxVRmluIl0sWzAsMSwiXFxldmFsdCIsMCx7ImN1cnZlIjotNH1dLFsxLDIsIlxcZXZhbHAiLDAseyJjdXJ2ZSI6LTR9XSxbMiwzLCJcXGV2YWxoIiwwLHsiY3VydmUiOi00fV0sWzIsMSwiXFxxdW90ZXAiLDAseyJjdXJ2ZSI6LTR9XSxbMywyLCJcXHF1b3RlaCIsMCx7ImN1cnZlIjotNH1dLFsxLDAsIlxccXVvdGV0IiwwLHsiY3VydmUiOi00fV1d
            $\begin{tikzcd}[ampersand replacement=\&]
                    \PiLang \&\& \PiPlusLang \&\& \PiHatLang \&\& \UFin
                    \arrow["\evalt", curve={height=-24pt}, from=1-1, to=1-3]
                    \arrow["\evalp", curve={height=-24pt}, from=1-3, to=1-5]
                    \arrow["\evalh", curve={height=-24pt}, from=1-5, to=1-7]
                    \arrow["\quotep", curve={height=-24pt}, from=1-5, to=1-3]
                    \arrow["\quoteh", curve={height=-24pt}, from=1-7, to=1-5]
                    \arrow["\quotet", curve={height=-24pt}, from=1-3, to=1-1]
                \end{tikzcd}$
        }
    \end{figure}

    \bigskip

    \begin{figure}
        \centering
        \scalebox{1.5}{$
                \parbox[c]{2cm}{\centering$\boolt \prodt (\boolt \prodt \boolt)$} \xrightarrow{\evalt}
                \parbox[c]{2.5cm}{\centering$(\boolt \sumt \boolt) \sumt (\boolt \sumt \boolt)$} \xrightarrow{\evalp}
                \parbox[c]{0.5cm}{\centering$8$} \xrightarrow{\evalh}
                \parbox[c]{1cm}{\centering$\Fin[8]$}
            $}
    \end{figure}
\end{frame}

\begin{frame}{Summary}
    \begin{plist}
        \item Curry-Howard-Lambek correspondence:
        \begin{center}
            Reversible Programming Languages $\leftrightsquigarrow$ Symmetric Rig Groupoids
        \end{center}
        \medskip
        \begin{table}
            \begin{center}
                \begin{tabular}{cccc}
                    \hline
                    $\PiLang$     & $\bigsqcup_n \mathcal{B}\Sn $ & $\BFin$     & $\UFin$ \tabularnewline
                    \hline\hline
                    Types         & Natural numbers               & Finite sets & 0-cells \tabularnewline
                    1-combinators & Generators of $\Sn$           & Bijections  & 1-paths \tabularnewline
                    2-combinators & Relations of $\Sn$            & Homotopies  & 2-paths \tabularnewline
                    \hline
                \end{tabular}
            \end{center}
        \end{table}
        \medskip
        \item Full-abstraction and adequacy with respect to operational semantics
        \item Normalisation, equivalence, and synthesis for reversible circuits
        \item Transfer of theorems about permutations between different representations
        \item Agda formalisation using HoTT-Agda
        \begin{plist}
            \item vikraman/2DTypes, vikraman/popl22-symmetries-artifact
        \end{plist}
    \end{plist}
    \vfill
    \begin{center}
        \Large
        \url{https://dl.acm.org/doi/10.1145/3498667}
    \end{center}
\end{frame}

\begin{frame}{Future Work}
    \begin{plist}
        \item Construction of the free symmetric monoidal groupoid over a groupoid.
        \begin{plist}
            \item See: https://arxiv.org/abs/2110.05412
        \end{plist}
        \item Generalised Species of Structures over Groupoids and its differential structure.
        \item Groupoid models of Linear logic
        \item Construction of $A_n/E_n$ operads in HoTT.
    \end{plist}
\end{frame}

\end{document}

%%% mode: latex
%%% TeX-master: t
%%% fill-column: 120
%%% End:
