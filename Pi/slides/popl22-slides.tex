% !TeX root = popl22-slides.tex
% !TeX program = lualatex
\documentclass[lualatex,aspectratio=169,10pt]{beamer}
% \overfullrule=1em

\usefonttheme{professionalfonts}
% \usefonttheme{serif}

\beamertemplatenavigationsymbolsempty
\setbeamertemplate{footline}[frame number]

% \setbeameroption{show notes on second screen}

\usepackage{fontspec}
% \usepackage{unicode-math}

\setmainfont{Baskerville}
\setsansfont{Fira Sans}
\setmonofont{Iosevka}[
  Scale = MatchLowercase
]
% \setmathfont{texgyrepagella-math.otf}[math-style=TeX]

\setbeamersize{text margin left=5mm,text margin right=5mm}
\setbeamerfont{title}{size=\huge}

\setbeamercolor{normal text}{fg=solarized-base03, bg=white}
\setbeamercolor{structure}{fg=solarized-violet}

\usepackage[capitalise,noabbrev]{cleveref}
\usepackage[inline]{enumitem}
\usepackage{extarrows}
\usepackage{longtable}
\usepackage{adjustbox}
\usepackage{url}
\usepackage{multicol}
\usepackage{stmaryrd}
\usepackage{proof}
%\usepackage{bbold}
%\usepackage[bb=boondox]{mathalfa}
\usepackage{subcaption}
\captionsetup[subfigure]{labelformat=empty}
\usepackage[utf8]{inputenc}
\usepackage{newunicodechar}
\usepackage{underoverlap}
\usepackage{eqparbox}

\let\Bbbk\relax
\usepackage{amsmath}
\usepackage{amssymb,amsfonts}
\usepackage{newtxmath}
\usepackage{bbm}

\usepackage[utf8]{inputenc}
\usepackage{newunicodechar}

\newunicodechar{⊸}{$\multimap$}
\newunicodechar{𝕍}{$\mathbb{V}$}
\newunicodechar{𝕃}{$\mathbb{L}$}
\newunicodechar{𝕄}{$\mathbb{M}$}
\newunicodechar{ℝ}{$\mathbb{R}$}
\newunicodechar{𝕌}{$\mathbb{U}$}
\newunicodechar{𝔹}{$\mathbb{B}$}
\newunicodechar{𝕐}{$\mathbb{Y}$}
\newunicodechar{𝔼}{$\mathbb{E}$}
\newunicodechar{𝔽}{$\mathbb{F}$}
\newunicodechar{𝕋}{$\mathbb{T}$}
\newunicodechar{𝕚}{$\mathbb{i}$}
\newunicodechar{𝟘}{$\mathbb{0}$}
\newunicodechar{𝟙}{$\mathbb{1}$}
\newunicodechar{𝟚}{$\mathbb{2}$}
\newunicodechar{𝟛}{$\mathbb{3}$}
\newunicodechar{𝟠}{$\mathbb{8}$}
\newunicodechar{⟷}{$\leftrightarrow$}
\newunicodechar{₀}{$_{0}$}
\newunicodechar{₁}{$_{1}$}
\newunicodechar{₂}{$_{2}$}
\newunicodechar{₃}{$_{3}$}
\newunicodechar{₄}{$_{4}$}
\newunicodechar{¹}{$^{1}$}
\newunicodechar{²}{$^{2}$}
\newunicodechar{³}{$^{3}$}
\newunicodechar{⁴}{$^{4}$}
\newunicodechar{■}{$\blacksquare$}
\newunicodechar{⊡}{$\boxdot$}
\newunicodechar{⋆}{$\star$}
\newunicodechar{◎}{$\circledcirc$}
\newunicodechar{⊗}{$\otimes$}
\newunicodechar{⊕}{$\oplus$}
\newunicodechar{₊}{$_{+}$}
\newunicodechar{↔}{$\leftrightarrow$}
\newunicodechar{⇔}{$\Leftrightarrow$}
\newunicodechar{∀}{$\forall$}
\newunicodechar{ϕ}{$\phi$}
\newunicodechar{⋯}{$\AgdaInductiveConstructor{\ldots}$}
\newunicodechar{ₛ}{$_{S}$}

\usepackage[conor]{agda}
\AgdaNoSpaceAroundCode
% \renewcommand{\AgdaCodeStyle}{\footnotesize}
\definecolor{AgdaUnsolvedMeta}{HTML}{FFFFFF}
\newcommand{\AIC}[1]{\AgdaInductiveConstructor{#1}}

\input{\detokenize{ExamplesS.tex}}

\usepackage{macros}
\usepackage{hott}
\usepackage{syntax2}
\usepackage{microtype}

\usepackage{tikz}
\usetikzlibrary{decorations.markings}
\usetikzlibrary{quotes,fit,positioning}
\usetikzlibrary{arrows.meta, tikzmark}
\usetikzlibrary{knots}
\tikzstyle{func}=[rectangle,draw,fill=black!20,minimum size=1.9em,text width=2.4em, text centered]
\usetikzlibrary{braids}
\tikzset{>=latex}
\usepackage{tikzit}
\input{tikzit.tikzstyles}
\usepackage{quiver}
\usepackage[nocenter]{qtree}

\usepackage[most]{tcolorbox}

\newtcolorbox{dblock}[1][Definition]{
  colback=white,
  colframe=solarized-violet,
  colbacktitle=white!90!structure.fg,
  coltitle=black,
  fonttitle=\itshape,
  title={#1},
  enhanced,
  attach boxed title to top left={yshift=-2mm, xshift=0.5cm}
}

\newtcolorbox{tblock}[1][Proposition]{
  colback=white,
  colframe=solarized-blue,
  colbacktitle=white!90!structure.fg,
  coltitle=black,
  fonttitle=\itshape,
  title={#1},
  enhanced,
  attach boxed title to top left={yshift=-2mm, xshift=0.5cm}
}

\newcommand{\btVFill}{\vskip0pt plus 1filll}

\title{Symmetries in Reversible Programming}
\subtitle{From Symmetric Rig Groupoids to Reversible Programming Languages}
\author{\underline{Vikraman Choudhury}, Jacek Karwowski, Amr Sabry}
\date{POPL 2022}

\begin{document}

\begin{frame}
  \titlepage
\end{frame}

% \begin{frame}[fragile]{Plan}
%   \begin{plist}
%     \item Start with the example of two programs swapping [A, B, C]. Our goal: find sound and complete equations.
%     \item $\PiLang$ slide
%     \item 2-combinators
%     \item The programs from the beginning are equal - how do we prove this for all of them?
%     \item General outline of the proof: an equivalence of groupoids.
%     \item HoTT slide A: Groupoids are easy to talk about in HoTT, types as $\infty$-groupoids.
%     \item HoTT slide B.
%     \item UFin in one slide.
%     \item Factoring of the semantics through $\PiPlusLang$, $\PiHatLang$.
%     \item First step: Pi to PiPlus
%     \item Second step: PiPlus to PiHat
%     \item Third step A: PiHat to UFin
%     \item Third step B: Loop space of PiHat(n) is equivalent to Sn
%     \item Third step C: Sn is equivalent to Lehmer(n)
%     \item Third step D: Lehmer(n) is equivalent to Aut(Fin(n))
%     \item Third step E: This is the loopspace of UFin
%     \item Table Curry-Lambek
%     \item Other discussion items
%     \item Applications A: deciding the equivalence of reversible circuits
%     \item Applications B: Normalisation-by-evaluation
%     \item Applications C: Synthesis
%     \item Applications D: Transfer of theorems
%   \end{plist}
%   \note{
%     Four intervened stories.
%   }
% \end{frame}

\begin{frame}[fragile]{Permutations as tree transformations}
  \bigskip
  \begin{figure}
    \begin{subfigure}[b]{0.95\textwidth}
      \centering
      \[
        \Tree [ {\tiny A} [ {\tiny B} {\tiny C} ] ] ~\xrightarrow{\assoclp}~
        \Tree [ [ {\tiny A} {\tiny B} ] {\tiny C} ] ~\xrightarrow{\swapp}~
        \Tree [ {\tiny C} [ {\tiny A} {\tiny B} ] ] ~\xrightarrow[\phantom{xx}\swapp]{\idc\phantom{xx}}~
        \Tree [ {\tiny C} [ {\tiny B} {\tiny A} ] ] ~
      \]
      \caption{$p_1$}
    \end{subfigure}
    \btVFill
    \begin{subfigure}[b]{0.95\textwidth}
      \centering
      \[
        \Tree [ {\tiny A} [ {\tiny B} {\tiny C} ] ] ~\xrightarrow[\phantom{xx}\swapp]{\idc\phantom{xx}}~
        \Tree [ {\tiny A} [ {\tiny C} {\tiny B} ] ] ~\xrightarrow{\assoclp}~
        \Tree [ [ {\tiny A} {\tiny C} ] {\tiny B} ] ~\xrightarrow[\swapp\phantom{x}]{\phantom{x}\idc}~
        \Tree [ [ {\tiny C} {\tiny A} ] {\tiny B} ] ~\xrightarrow{\assocrp}~
        \Tree [ {\tiny C} [ {\tiny A} {\tiny B} ] ] ~\xrightarrow[\phantom{xx}\swapp]{\idc\phantom{xx}}~
        \Tree [ {\tiny C} [ {\tiny B} {\tiny A} ] ] ~
      \]
      \caption{$p_2$}
    \end{subfigure}
  \end{figure}
  \btVFill
\end{frame}

\begin{frame}{A reversible programming language: $\PiLang$}
  \bigskip

  {\scalebox{\scalef}{$%
        \begin{array}{lrcl}
          \textit{Value types}   & A,B & ::= & \zerot \alts \onet \alts A+B \alts A\times B        \\
          \textit{Values}        & v,w & ::= & \Acon{tt} \alts \inlv{v} \alts \inrv{v} \alts (v,w) \\
          \textit{Program types} &     &     & A \isoone B                                         \\
          \textit{Programs}      & c   & ::= &
        \end{array}$}}

  \begin{figure}
    {\scalebox{\scalef}{$%
          %%\noindent\begin{minipage}{.7\linewidth}
          \begin{array}{rrcll}
            \idc :     & A                     & \isoone & A                            & : \idc      \\ [1.5ex]
            \identlp : & \zerot + A            & \isoone & A                            & : \identrp  \\
            \swapp :   & A + B                 & \isoone & B + A                        & : \swapp    \\
            \assoclp : & A + (B + C)           & \isoone & (A + B) + C                  & : \assocrp  \\ [1.5ex]
            \identlt : & \onet \times A        & \isoone & A                            & : \identrt  \\
            \swapt :   & A \times B            & \isoone & B \times A                   & : \swapt    \\
            \assoclt : & A \times (B \times C) & \isoone & (A \times B) \times C        & : \assocrt  \\ [1.5ex]
            \absorbr : & ~ \zerot \times A     & \isoone & \zerot ~                     & : \factorzl \\
            \dist :    & ~ (A + B) \times C    & \isoone & (A \times C) + (B \times C)~ & : \factor
          \end{array}$}}

    \bigskip

    {\scalebox{\scalef}{%
        \Rule{}
        {\jdg{}{}{c_1 : A \isoone B} \quad \vdash c_2 : B \isoone C}
        {\jdg{}{}{c_1 \circledcirc c_2 : A \isoone C}}
        {}

        \Rule{}
        {\jdg{}{}{c_1 : A \isoone B} \quad \vdash c_2 : C \isoone D}
        {\jdg{}{}{c_1 \oplus c_2 : A + C \isoone B + D}}
        {}

        \Rule{}
        {\jdg{}{}{c_1 : A \isoone B} \quad \vdash c_2 : C \isoone D}
        {\jdg{}{}{c_1 \otimes c_2 : A \times C \isoone B \times D}}
        {}
      }}
  \end{figure}
\end{frame}

\begin{frame}[fragile]{Reversible Boolean Circuits: 3-bit Toffoli gate}
  \bigskip

  \controlled{}
  \cnot{}
  \toffolithree{}
\end{frame}

\begin{frame}{Semantics of $\PiLang$}
  \bigskip
  \begin{center}
    \begin{tabular}[t]{c @{\hspace{5em}} c}
      {\scalebox{\scalef}{
          \begin{tabular}[t]{>{$}r<{$} @{\hspace{4pt}} >{$}l<{$} >{$}c<{$} >{$}l<{$}}
            \denotbox{\identlp} & (\inl{v})         & = & v               \\
            \denotbox{\identrp} & v                 & = & \inl{v}         \\
            \denotbox{\swapp}   & (\inl{v})         & = & \inr{v}         \\
            \denotbox{\swapp}   & (\inr{v})         & = & \inl{v}         \\
            \denotbox{\assoclp} & (\inl{v})         & = & \inl{(\inl{v})} \\
            \denotbox{\assoclp} & (\inr{(\inl{v})}) & = & \inl{(\inr{v})} \\
            \denotbox{\assoclp} & (\inr{(\inr{v})}) & = & \inr{v}         \\
            \denotbox{\assocrp} & (\inl{(\inl{v})}) & = & \inl{v}         \\
            \denotbox{\assocrp} & (\inl{(\inr{v})}) & = & \inr{(\inl{v})} \\
            \denotbox{\assocrp} & (\inr{v})         & = & \inr{(\inr{v})}
          \end{tabular}}}
       &
      {\scalebox{\scalef}{
            \begin{tabular}[t]{>{$}r<{$} @{\hspace{4pt}} >{$}l<{$} >{$}c<{$} >{$}l<{$}}
              \denotbox{\identlt} & (\ttt , v)          & = & v                   \\
              \denotbox{\identrt} & v                   & = & (\ttt , v)          \\
              \denotbox{\swapt}   & (v_1 , v_2)         & = & (v_2 , v_1)         \\
              \denotbox{\assoclt} & (v_1 , (v_2 , v_3)) & = & ((v_1 , v_2) , v_3) \\
              \denotbox{\assocrt} & ((v_1 , v_2) , v_3) & = & (v_1 , (v_2 , v_3)) \\
              \denotbox{\dist}    & (\inl{v_1} , v_3)   & = & \inl{(v_1 , v_3)}   \\
              \denotbox{\dist}    & (\inr{v_2 , v_3})   & = & \inr{(v_2 , v_3)}   \\
              \denotbox{\factor}  & (\inl{(v_1 , v_3)}) & = & (\inl{v_1} , v_3)   \\
              \denotbox{\factor}  & (\inr{(v_2 , v_3)}) & = & (\inr{v_2} , v_3)   \\
              \denotbox{\idc}     & v                   & = & v
            \end{tabular}}}
    \end{tabular}
  \end{center}

  \bigskip

  \begin{center}
    {\scalebox{\scalef}{
        \begin{tabular}[t]{>{$}r<{$} @{\hspace{4pt}} >{$}l<{$} >{$}c<{$} >{$}l<{$}}
          \denotbox{(c_1 \circledcirc c_2)} & v           & = & \denot{c_2} (\denot{c_1}~v)         \\
          \denotbox{(c_1 \oplus c_2)}       & (\inl{v})   & = & \inl{(\denot{c_1}~v)}               \\
          \denotbox{(c_1 \oplus c_2)}       & (\inr{v})   & = & \inr{(\denot{c_2}~v)}               \\
          \denotbox{(c_1 \otimes c_2)}      & (v_1 , v_2) & = & (\denot{c_1}~v_1 , \denot{c_2}~v_2)
        \end{tabular}}}
  \end{center}
  \pause
  \bigskip
  \begin{plist}
    \item Can we encode every permutation?
  \end{plist}
  \btVFill
\end{frame}

\begin{frame}[fragile]{Permutations as tree transformations}
  \bigskip

  \begin{figure}
    \begin{subfigure}[b]{0.95\textwidth}
      \centering
      \[
        \Tree [ {\tiny A} [ {\tiny B} {\tiny C} ] ] ~\xrightarrow{\assoclp}~
        \Tree [ [ {\tiny A} {\tiny B} ] {\tiny C} ] ~\xrightarrow{\swapp}~
        \Tree [ {\tiny C} [ {\tiny A} {\tiny B} ] ] ~\xrightarrow[\phantom{xx}\swapp]{\idc\phantom{xx}}~
        \Tree [ {\tiny C} [ {\tiny B} {\tiny A} ] ] ~
      \]
      \caption{$p_1$}
    \end{subfigure}
    \btVFill
    \begin{subfigure}[b]{0.95\textwidth}
      \centering
      \[
        \Tree [ {\tiny A} [ {\tiny B} {\tiny C} ] ] ~\xrightarrow[\phantom{xx}\swapp]{\idc\phantom{xx}}~
        \Tree [ {\tiny A} [ {\tiny C} {\tiny B} ] ] ~\xrightarrow{\assoclp}~
        \Tree [ [ {\tiny A} {\tiny C} ] {\tiny B} ] ~\xrightarrow[\swapp\phantom{x}]{\phantom{x}\idc}~
        \Tree [ [ {\tiny C} {\tiny A} ] {\tiny B} ] ~\xrightarrow{\assocrp}~
        \Tree [ {\tiny C} [ {\tiny A} {\tiny B} ] ] ~\xrightarrow[\phantom{xx}\swapp]{\idc\phantom{xx}}~
        \Tree [ {\tiny C} [ {\tiny B} {\tiny A} ] ] ~
      \]
      \caption{$p_2$}
    \end{subfigure}
  \end{figure}
  \pause
  \bigskip
  \begin{plist}
    \item Can we find a sound and complete set of equations to decide when two programs are equal?
  \end{plist}
  \btVFill
\end{frame}

\begin{frame}[fragile]{Equational theory: Examples of 2-combinators}
  \bigskip

  \begin{figure}
    {\scalebox{\scalef}{
        \Rule{}
        {\jdg{}{}{c_1 : A \isoone B} \quad {\vdash c_2 : A \isoone B}}
        {\jdg{}{}{c_1 \isotwo c_2}}
        {}
      }}
  \end{figure}
  \pause
  \medskip

  \begin{figure}
    {\scalebox{\scalef}{$%
          %%\noindent\begin{minipage}{.7\linewidth}
          \begin{array}{rrcll}
            \AIC{id⟷₂} :     & c                                       & \isotwo & c                                       & : \AIC{id⟷₂}     \\ [1.5ex]
            \AIC{assoc◎l} :  & c_1 \circledcirc (c_2 \circledcirc c_3) & \isotwo & (c_1 \circledcirc c_2) \circledcirc c_3 & : \AIC{assoc◎r}  \\ [1.5ex]
            \AIC{idl◎l} :    & \idc \circledcirc c                     & \isotwo & c                                       & : \AIC{idl◎r}    \\
            \AIC{idr◎l} :    & c \circledcirc \idc                     & \isotwo & c                                       & : \AIC{idr◎r}    \\
            \AIC{linv◎l} :   & c \circledcirc \AIC{!⟷₁} c              & \isotwo & \idc                                    & : \AIC{linv◎r}   \\
            \AIC{swapl₊⟷₂} : & \swapp \circledcirc (c_1 \oplus c_2)    & \isotwo & (c_2 \oplus c_1) \circledcirc \swapp    & : \AIC{swapr₊⟷₂}
          \end{array}$}}

    \bigskip

    {\scalebox{\scaleff}{$%
          %%\noindent\begin{minipage}{.7\linewidth}
          \begin{array}{rrcll}
            \AIC{pentagon₊l} : & \assocrp \circledcirc \assocrp                       & \isotwo & ((\assocrp \oplus \idc) \circledcirc \assocrp) \circledcirc (\idc \oplus \assocrp) & : \AIC{pentagon₊r} \\
            \AIC{hexagonl₊l} : & (\assoclp \circledcirc \swapp) \circledcirc \assoclp & \isotwo & ((\idc \oplus \swapp) \circledcirc \assoclp) \circledcirc (\swapp \oplus \idc)     & : \AIC{hexagonl₊r}
          \end{array}$}}

    \bigskip

    {\scalebox{\scalef}{%
        \Rule{}
        {\jdg{}{}{\alpha_1 : c_1 \isotwo c_2} \quad \vdash \alpha_2 : c_2 \isotwo c_3}
        {\jdg{}{}{\alpha_1\;\blacksquare\;\alpha_2 : c_1 \isotwo c_3}}
        {}

        \Rule{}
        {\jdg{}{}{\alpha_1 : c_1 \isotwo c_3} \quad \vdash \alpha_2 : c_2 \isotwo c_4}
        {\jdg{}{}{\alpha_1\;\boxdot\;\alpha_2 : (c_1 \circledcirc c_2) \isotwo (c_3 \circledcirc c_4)}}
        {}
      }}
  \end{figure}
\end{frame}

\begin{frame}[fragile]{Solving the example}
  \leveltwoexample{}

  % https://q.uiver.app/?q=WzAsOCxbMCwwLCJBICsgKEIgKyBDKSJdLFsyLDAsIihBICsgQikgKyBDIl0sWzQsMCwiQyArIChBICsgQikiXSxbNiwwLCJDICsgKEIgKyBBKSJdLFswLDIsIkEgKyAoQyArIEIpIl0sWzIsMiwiKEEgKyBDKSArIEIiXSxbNCwyLCIoQyArIEEpICsgQiJdLFs2LDIsIkMgKyAoQSArIEIpIl0sWzAsMSwiXFxhc3NvY2xwIl0sWzEsMiwiXFxzd2FwcCJdLFsyLDMsIlxcaWRjflxcb3BsdXN+XFxzd2FwcCJdLFswLDQsIlxcaWRjflxcb3BsdXN+XFxzd2FwcCIsMl0sWzQsNSwiXFxhc3NvY2xwIiwyXSxbNSw2LCJcXHN3YXBwflxcb3BsdXN+XFxpZGMiLDJdLFs2LDcsIlxcYXNzb2NycCIsMl0sWzMsNywiXFxpZGN+XFxvcGx1c35cXHN3YXBwIl0sWzIsNiwiXFxhc3NvY2xwIiwyXV0=
  \[\begin{tikzcd}[ampersand replacement=\&]
      {A + (B + C)} \&\& {(A + B) + C} \&\& {C + (A + B)} \&\& {C + (B + A)} \\
      \\
      {A + (C + B)} \&\& {(A + C) + B} \&\& {(C + A) + B} \&\& {C + (A + B)}
      \arrow["\assoclp", from=1-1, to=1-3]
      \arrow["\swapp", from=1-3, to=1-5]
      \arrow["{\idc~\oplus~\swapp}", from=1-5, to=1-7]
      \arrow["{\idc~\oplus~\swapp}"', from=1-1, to=3-1]
      \arrow["\assoclp"', from=3-1, to=3-3]
      \arrow["{\swapp~\oplus~\idc}"', from=3-3, to=3-5]
      \arrow["\assocrp"', from=3-5, to=3-7]
      \arrow["{\idc~\oplus~\swapp}", from=1-7, to=3-7]
      \arrow["\assoclp"', from=1-5, to=3-5]
    \end{tikzcd}\]
\end{frame}

\begin{frame}{Denotational Semantics for $\PiLang$}
  \begin{figure}
    \centering
    \scalebox{1.5}{$
        % https://q.uiver.app/?q=WzAsNCxbMCwwLCJcXGJ1bGxldCJdLFsyLDAsIlxcYnVsbGV0Il0sWzYsMCwiXFxidWxsZXQiXSxbOCwwLCJcXGJ1bGxldCJdLFswLDEsIiIsMCx7ImN1cnZlIjo1LCJzdHlsZSI6eyJ0YWlsIjp7Im5hbWUiOiJhcnJvd2hlYWQifX19XSxbMCwxLCIiLDIseyJjdXJ2ZSI6LTUsInN0eWxlIjp7InRhaWwiOnsibmFtZSI6ImFycm93aGVhZCJ9fX1dLFsyLDMsIiIsMCx7ImN1cnZlIjo1LCJzdHlsZSI6eyJ0YWlsIjp7Im5hbWUiOiJhcnJvd2hlYWQifX19XSxbMiwzLCIiLDIseyJjdXJ2ZSI6LTUsInN0eWxlIjp7InRhaWwiOnsibmFtZSI6ImFycm93aGVhZCJ9fX1dLFs0LDUsIiIsMCx7InNob3J0ZW4iOnsic291cmNlIjoyMCwidGFyZ2V0IjoyMH0sInN0eWxlIjp7InRhaWwiOnsibmFtZSI6ImFycm93aGVhZCJ9fX1dLFs2LDcsIiIsMCx7InNob3J0ZW4iOnsic291cmNlIjoyMCwidGFyZ2V0IjoyMH0sInN0eWxlIjp7InRhaWwiOnsibmFtZSI6ImFycm93aGVhZCJ9fX1dXQ==
        \begin{tikzcd}[ampersand replacement=\&]
          \bullet \&\& \bullet \&\&\&\& \bullet \&\& \bullet
          \arrow[""{name=0, anchor=center, inner sep=0}, curve={height=30pt}, tail reversed, from=1-1, to=1-3]
          \arrow[""{name=1, anchor=center, inner sep=0}, curve={height=-30pt}, tail reversed, from=1-1, to=1-3]
          \arrow[""{name=2, anchor=center, inner sep=0}, curve={height=30pt}, tail reversed, from=1-7, to=1-9]
          \arrow[""{name=3, anchor=center, inner sep=0}, curve={height=-30pt}, tail reversed, from=1-7, to=1-9]
          \arrow[shorten <=8pt, shorten >=8pt, Rightarrow, 2tail reversed, from=0, to=1]
          \arrow[shorten <=8pt, shorten >=8pt, Rightarrow, 2tail reversed, from=2, to=3]
        \end{tikzcd}
      $}
  \end{figure}

  \bigskip

  \begin{figure}
    \centering
    \scalebox{1.5}{$
        \parbox[c]{2cm}{\centering{Types Programs Equations}}
        \parbox[c]{4cm}{\centering$\leftrightsquigarrow$}
        \parbox[c]{2cm}{\centering{Finite sets Bijections Homotopies}}
      $}
  \end{figure}
\end{frame}

\begin{frame}[fragile]{Denotational Semantics for $\PiLang$}
  \begin{figure}
    \centering
    \scalebox{1.5}{
      % https://q.uiver.app/?q=WzAsNCxbMCwwLCJcXFBpTGFuZyJdLFsyLDAsIlxcUGlQbHVzTGFuZyJdLFs0LDAsIlxcUGlIYXRMYW5nIl0sWzYsMCwiXFxVRmluIl0sWzAsMSwiXFxldmFsdCIsMCx7ImN1cnZlIjotNH1dLFsxLDIsIlxcZXZhbHAiLDAseyJjdXJ2ZSI6LTR9XSxbMiwzLCJcXGV2YWxoIiwwLHsiY3VydmUiOi00fV0sWzIsMSwiXFxxdW90ZXAiLDAseyJjdXJ2ZSI6LTR9XSxbMywyLCJcXHF1b3RlaCIsMCx7ImN1cnZlIjotNH1dLFsxLDAsIlxccXVvdGV0IiwwLHsiY3VydmUiOi00fV1d
      $\begin{tikzcd}[ampersand replacement=\&]
          \PiLang \&\& \PiPlusLang \&\& \PiHatLang
          \arrow[from=1-1, to=1-3]
          \arrow[from=1-3, to=1-5]
        \end{tikzcd}$
    }
  \end{figure}

  \bigskip

  \begin{figure}
    \centering
    \scalebox{1.5}{$
        \parbox[c]{2cm}{\centering$\boolt \prodt (\boolt \prodt \boolt)$} \xrightarrow{\sim}
        \parbox[c]{2.5cm}{\centering$(\boolt \sumt \boolt) \sumt (\boolt \sumt \boolt)$} \xrightarrow{\sim}
        \parbox[c]{0.5cm}{\centering$\term{S^8(0)}$}
      $}
  \end{figure}

  \bigskip

  \begin{figure}
    \centering
    \scalebox{1.5}{$
        \parbox[c]{3cm}{\centering$\swapp$, $\assoclp$, $\swapt$, $\assoclt$, $\dist$} \rightarrow
        \parbox[c]{3cm}{\centering$\swapp$, $\assoclp$} \rightarrow
        \parbox[c]{3cm}{\centering$\AIC{swapₛ}$}
      $}
  \end{figure}

  \bigskip

  \begin{tblock}
    \[
      \PiLang \eqv \PiPlusLang \eqv \PiHatLang
    \]
  \end{tblock}
  \btVFill
\end{frame}

\begin{frame}[fragile]{Example: permutations as braid diagrams}
  \begin{figure}
    \begin{subfigure}[b]{0.45\textwidth}
      \centering
      \begin{tikzpicture}
        \def\nstrandsdf{3}
        \pic[local bounding box=my braid,braid/.cd,
          number of strands = \nstrandsdf,
          width = 0.8cm,
          height = 0.3cm,
          border height = 0.1cm,
          thick,
          name prefix=braid]
        {braid={s_2, s_2, s_2, s_1, s_2}};
        %   \draw[thick] % draws the top/bottom bars
        % ([xshift=-1ex]my braid.north west) --  ([xshift=1ex]my braid.north east)
        % ([xshift=-1ex]my braid.south west) --  ([xshift=1ex]my braid.south east);
        \node at (braid-1-s)[yshift = 2.0cm] {\tiny A};
        \node at (braid-2-s)[yshift = 2.0cm] {\tiny B};
        \node at (braid-3-s)[yshift = 2.0cm] {\tiny C};

        % labels the bottom bar
        \node at (braid-1-e)[yshift = -2.0cm] {\tiny A};
        \node at (braid-2-e)[yshift = -2.0cm] {\tiny B};
        \node at (braid-3-e)[yshift = -2.0cm] {\tiny C};
      \end{tikzpicture}
      \caption{$p_1 \mapsto [1,0,1,1,1]$}
    \end{subfigure}
    \begin{subfigure}[b]{0.45\textwidth}
      \centering
      \begin{tikzpicture}
        \def\nstrandsdf{3}
        \pic[local bounding box=my braid,braid/.cd,
          number of strands = \nstrandsdf,
          width = 0.8cm,
          height = 0.3cm,
          border height = 0.1cm,
          thick,
          name prefix=braid]
        {braid={1, s_2,, s_1, s_2, 1}};
        %   \draw[thick] % draws the top/bottom bars
        % ([xshift=-1ex]my braid.north west) --  ([xshift=1ex]my braid.north east)
        % ([xshift=-1ex]my braid.south west) --  ([xshift=1ex]my braid.south east);
        \node at (braid-1-s)[yshift = 2.0cm] {\tiny A};
        \node at (braid-2-s)[yshift = 2.0cm] {\tiny B};
        \node at (braid-3-s)[yshift = 2.0cm] {\tiny C};

        % labels the bottom bar
        \node at (braid-1-e)[yshift = -2.0cm] {\tiny A};
        \node at (braid-2-e)[yshift = -2.0cm] {\tiny B};
        \node at (braid-3-e)[yshift = -2.0cm] {\tiny C};
      \end{tikzpicture}
      \caption{$p_2 \mapsto [1,0,1]$}
    \end{subfigure}
  \end{figure}
\end{frame}

\begin{frame}[fragile]{Symmetric groups}
  \begin{figure}
    \centering
    \begin{subfigure}[b]{0.25\textwidth}
      \centering
      \begin{tikzpicture}
        \pic[local bounding box=my braid,braid/.cd,
          number of strands = 2,
          width = 0.4cm,
          height = 0.4cm,
          border height = 0.3cm,
          thick] at (0, 0)
        {braid={ s_1, s_1}};
        \node[font=\large] at (1, 0.7) {\(=\)};
        \pic[local bounding box=my braid,braid/.cd,
          number of strands = 2,
          width = 0.4cm,
          height = 0.4cm,
          border height = 0.3cm,
          thick] at (1.6, 0)
        {braid={ 1, 1}};
      \end{tikzpicture}
      \caption{$\cancel$}
    \end{subfigure}
    \begin{subfigure}[b]{0.4\textwidth}
      \centering
      \begin{tikzpicture}
        \pic[local bounding box=my braid,braid/.cd,
          number of strands = 2,
          width = 0.4cm,
          height = 0.4cm,
          border height = 0.3cm,
          thick] at (0, 0)
        {braid={ s_1, 1}};
        \node[] at (0.7, 0.7) {\(\dots\)};
        \pic[local bounding box=my braid,braid/.cd,
          number of strands = 2,
          width = 0.4cm,
          height = 0.4cm,
          border height = 0.3cm,
          thick] at (1, 0)
        {braid={ 1, s_1 }};
        \node[font=\large] at (1.9, 0.7) {\(=\)};
        \pic[local bounding box=my braid,braid/.cd,
          number of strands = 2,
          width = 0.4cm,
          height = 0.4cm,
          border height = 0.3cm,
          thick] at (2.4, 0)
        {braid={ 1, s_1}};
        \node[] at (3.1, 0.7) {\(\dots\)};
        \pic[local bounding box=my braid,braid/.cd,
          number of strands = 2,
          width = 0.4cm,
          height = 0.4cm,
          border height = 0.3cm,
          thick] at (3.4, 0)
        {braid={ s_1, 1}};
      \end{tikzpicture}
      \caption{$\swap$}
    \end{subfigure}
    \begin{subfigure}[b]{0.25\textwidth}
      \centering
      \begin{tikzpicture}
        \pic[local bounding box=my braid,braid/.cd,
          number of strands = 3,
          width = 0.4cm,
          height = 0.4cm,
          border height = 0.1cm,
          thick] at (0, 0)
        {braid={ s_2, s_1, s_2}};
        \node[font=\large] at (1.4, 0.7) {\(=\)};
        \pic[local bounding box=my braid,braid/.cd,
          number of strands = 3,
          width = 0.4cm,
          height = 0.4cm,
          border height = 0.1cm,
          thick] at (2, 0)
        {braid={ s_1, s_2, s_1}};
      \end{tikzpicture}
      \caption{$\braid$}
    \end{subfigure}
  \end{figure}

  \bigskip

  \begin{tblock}
    \begin{plist}
      \item These relations produce a confluent and terminating rewriting system.
      \item For every $w$, there exists a unique normal form $v$ such that $w \longcoxstar v$.
      \item We get a unique choice function $\normf : \List[\Fin[n]] \to \List[\Fin[n]]$.
      \item For all $l : \List[\Fin[n]]$, we have that $l \longcoxstar \normf[l]$.
    \end{plist}
  \end{tblock}
\end{frame}

\begin{frame}[fragile]{Permutations as braid diagrams}
  \begin{figure}
    \begin{subfigure}[b]{0.45\textwidth}
      \centering
      \begin{tikzpicture}
        \def\nstrandsdf{3}
        \pic[local bounding box=my braid,braid/.cd,
          number of strands = \nstrandsdf,
          width = 0.8cm,
          height = 0.3cm,
          border height = 0.1cm,
          thick,
          name prefix=braid]
        {braid={s_2, s_2, s_2, s_1, s_2}};
        %   \draw[thick] % draws the top/bottom bars
        % ([xshift=-1ex]my braid.north west) --  ([xshift=1ex]my braid.north east)
        % ([xshift=-1ex]my braid.south west) --  ([xshift=1ex]my braid.south east);
        \node at (braid-1-s)[yshift = 2.0cm] {\tiny A};
        \node at (braid-2-s)[yshift = 2.0cm] {\tiny B};
        \node at (braid-3-s)[yshift = 2.0cm] {\tiny C};

        % labels the bottom bar
        \node at (braid-1-e)[yshift = -2.0cm] {\tiny A};
        \node at (braid-2-e)[yshift = -2.0cm] {\tiny B};
        \node at (braid-3-e)[yshift = -2.0cm] {\tiny C};
      \end{tikzpicture}
      \caption{$p_1 \mapsto [1,0,1,1,1]$}
    \end{subfigure}
    \begin{subfigure}[b]{0.45\textwidth}
      \centering
      \begin{tikzpicture}
        \def\nstrandsdf{3}
        \pic[local bounding box=my braid,braid/.cd,
          number of strands = \nstrandsdf,
          width = 0.8cm,
          height = 0.3cm,
          border height = 0.1cm,
          thick,
          name prefix=braid]
        {braid={1, s_2,, s_1, s_2, 1}};
        %   \draw[thick] % draws the top/bottom bars
        % ([xshift=-1ex]my braid.north west) --  ([xshift=1ex]my braid.north east)
        % ([xshift=-1ex]my braid.south west) --  ([xshift=1ex]my braid.south east);
        \node at (braid-1-s)[yshift = 2.0cm] {\tiny A};
        \node at (braid-2-s)[yshift = 2.0cm] {\tiny B};
        \node at (braid-3-s)[yshift = 2.0cm] {\tiny C};

        % labels the bottom bar
        \node at (braid-1-e)[yshift = -2.0cm] {\tiny A};
        \node at (braid-2-e)[yshift = -2.0cm] {\tiny B};
        \node at (braid-3-e)[yshift = -2.0cm] {\tiny C};
      \end{tikzpicture}
      \caption{$p_2 \mapsto [1,0,1]$}
    \end{subfigure}
    \pause
    \begin{subfigure}[b]{0.3\textwidth}
      \centering
      \begin{tikzpicture}
        \def\nstrandsdf{3}
        \pic[local bounding box=my braid,braid/.cd,
          number of strands = \nstrandsdf,
          width = 0.8cm,
          height = 0.3cm,
          border height = 0.1cm,
          thick,
          name prefix=braid]
        {braid={1, s_1,, s_2, s_1, 1}};
        %   \draw[thick] % draws the top/bottom bars
        % ([xshift=-1ex]my braid.north west) --  ([xshift=1ex]my braid.north east)
        % ([xshift=-1ex]my braid.south west) --  ([xshift=1ex]my braid.south east);
        \node at (braid-1-s)[yshift = 2.0cm] {\tiny A};
        \node at (braid-2-s)[yshift = 2.0cm] {\tiny B};
        \node at (braid-3-s)[yshift = 2.0cm] {\tiny C};

        % labels the bottom bar
        \node at (braid-1-e)[yshift = -2.0cm] {\tiny A};
        \node at (braid-2-e)[yshift = -2.0cm] {\tiny B};
        \node at (braid-3-e)[yshift = -2.0cm] {\tiny C};
      \end{tikzpicture}
      \caption{Normal form: $[0,1,0]$}
    \end{subfigure}
  \end{figure}
\end{frame}

% \begin{frame}[fragile]{Step 3: $\Omega(\PiHatLang,n)$ to $\Sn$}
%   \begin{dblock}[$\longcox : {\List[\Fin[n]]} \to {\List[\Fin[n]]} \to {\UU}$]
%     \begin{align*}
%       \longcancel
%        & : \forall n, l, r \to (l \append n \cons n \cons r) \longcox (l \append r)                                                                      \\
%       \longswap
%        & : \forall n, k, l, r \to (\suc[k] < n) \to (l \append n \cons k \cons r) \longcox (l \append k \cons n \append r)                               \\
%       \longbraid
%        & : \forall n, k, l, r \to (l \append (n \downf 2 + k) \append (1 + k + n) \cons r) \longcox (l \append (k + n) \cons (n \downf 2 + k) \append r)
%     \end{align*}
%   \end{dblock}
%   \bigskip
%   \begin{plist}
%     \item This gives a confluent and terminating rewriting system.
%     \item For every $w$, there exists a unique normal form $v$ such that $w \longcoxstar v$.
%     \item We get a unique choice function $\normf : \List[\Fin[n]] \to \List[\Fin[n]]$.
%     \item For all $l : \List[\Fin[n]]$, we have that $l \longcoxstar \normf[l]$.
%     \item \(\Sn \defeq \quot{\List(\Fin[n])}{\cox*} \eqv \im{\normf}\).
%   \end{plist}
% \end{frame}

\begin{frame}{Transpositions to Permutations}
  \bigskip
  \[
    \begin{array}[]{ccccccc}
      (a\;b\;c) & \mapsto & (b\;a\;c) & \mapsto & (b\;c\;a) & \mapsto & (c\;b\;a) \\
                &         &           &         &           &         &           \\
                & 0       &           & 1       &           & 0                   \\
    \end{array}
  \]
  \btVFill
  \pause
  \begin{center}
    This produces a Lehmer code: $(0\;1\;2)$
  \end{center}
  \pause
  \bigskip
  \[
    \begin{array}[]{ccccccc}
      0 & (a\;b\;c) \mapsto (a\;b\;c) \\
      1 & (a\;b\;c) \mapsto (b\;a\;c) \\
      2 & (b\;a\;c) \mapsto (c\;b\;a) \\
    \end{array}
  \]
  \btVFill
\end{frame}

\begin{frame}{Main results}
  \btVFill
  \begin{tblock}
    \begin{plist}
      \item $\Omega(\PiHatLang, n) \eqv \Sn \eqv {\im{\normf}} \eqv \Lehmer[n] \eqv \Aut[\Fin[\suc[n]]]$
      \item $\PiLang \eqv \PiPlusLang \eqv \PiHatLang \eqv \UFin$
    \end{plist}
  \end{tblock}
  \btVFill
\end{frame}

\begin{frame}{Summary}
  \btVFill
  \begin{plist}
    \item Curry-Howard-Lambek correspondence:
    \begin{center}
      Reversible Programming Languages $\leftrightsquigarrow$ Symmetric Rig Groupoids
    \end{center}
    \medskip
    \begin{table}
      \begin{center}
        \begin{tabular}{cccc}
          \hline
          $\PiLang$     & $\bigsqcup_n \mathcal{B}\Sn $ & $\BFin$     & $\UFin$ \tabularnewline
          \hline\hline
          Types         & Natural numbers               & Finite sets & 0-cells \tabularnewline
          1-combinators & Generators of $\Sn$           & Bijections  & 1-paths \tabularnewline
          2-combinators & Relations of $\Sn$            & Homotopies  & 2-paths \tabularnewline
          \hline
        \end{tabular}
      \end{center}
    \end{table}
    \medskip
    \item Full-abstraction and adequacy with respect to operational semantics
    \item Normalisation, equivalence, and synthesis for reversible circuits
    \item Transfer of theorems about permutations between different representations
    \item Agda formalisation using HoTT-Agda
    \begin{plist}
      \item vikraman/2DTypes, vikraman/popl22-symmetries-artifact
    \end{plist}
  \end{plist}
  \btVFill
\end{frame}

\begin{frame}{Future Work}
  \begin{plist}
    \item Study the normalisation algorithm and its efficiency
    \item Extend the semantics to other extensions of $\PiLang$
    \item Construction of the free symmetric monoidal groupoid over a groupoid
    \item Generalised Species of Structures over Groupoids and its differential structure
  \end{plist}
\end{frame}

\begin{frame}{Summary}
  \btVFill
  \begin{plist}
    \item Curry-Howard-Lambek correspondence:
    \begin{center}
      Reversible Programming Languages $\leftrightsquigarrow$ Symmetric Rig Groupoids
    \end{center}
    \medskip
    \begin{table}
      \begin{center}
        \begin{tabular}{cccc}
          \hline
          $\PiLang$     & $\bigsqcup_n \mathcal{B}\Sn $ & $\BFin$     & $\UFin$ \tabularnewline
          \hline\hline
          Types         & Natural numbers               & Finite sets & 0-cells \tabularnewline
          1-combinators & Generators of $\Sn$           & Bijections  & 1-paths \tabularnewline
          2-combinators & Relations of $\Sn$            & Homotopies  & 2-paths \tabularnewline
          \hline
        \end{tabular}
      \end{center}
    \end{table}
    \medskip
    \item Full-abstraction and adequacy with respect to operational semantics
    \item Normalisation, equivalence, and synthesis for reversible circuits
    \item Transfer of theorems about permutations between different representations
    \item Agda formalisation using HoTT-Agda
    \begin{plist}
      \item vikraman/2DTypes, vikraman/popl22-symmetries-artifact
    \end{plist}
  \end{plist}
  \btVFill
  \begin{center}
    \Large
    \url{https://dl.acm.org/doi/10.1145/3498667}
  \end{center}
\end{frame}

\end{document}

%%% Local Variables:
%%% mode: latex
%%% TeX-master: t
%%% fill-column: 120
%%% End: