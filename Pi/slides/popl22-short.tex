\documentclass[aspectratio=169,9pt]{beamer}

\usefonttheme{professionalfonts}
% \usefonttheme{serif}

\beamertemplatenavigationsymbolsempty
\setbeamertemplate{footline}[frame number]

\setbeameroption{show notes on second screen}

% \usepackage{unicode-math}

% \setmainfont{Baskerville}
% \setsansfont{Fira Sans}
% \setmonofont{Iosevka}[
%   Scale = MatchLowercase
% ]
% \setmathfont{texgyrepagella-math.otf}[math-style=TeX]

% \let\oldtextsc\textsc
% \renewcommand{\textsc}[1]{
%   \setmainfont[Ligatures=TeX]{Linux Libertine O}
%   \oldtextsc{#1}
%   \setromanfont{Baskerville}
% }

\setbeamersize{text margin left=7mm,text margin right=7mm}
\setbeamerfont{title}{size=\Huge}

\setbeamercolor{normal text}{fg=solarized-base03, bg=white}
\setbeamercolor{structure}{fg=solarized-violet}

\usepackage[capitalise,noabbrev]{cleveref}
\usepackage[inline]{enumitem}
\usepackage{extarrows}
\usepackage{longtable}
\usepackage{adjustbox}
\usepackage{url}
\usepackage{multicol}
\usepackage{stmaryrd}
\usepackage{proof}
%\usepackage{bbold}
%\usepackage[bb=boondox]{mathalfa}
\usepackage{subcaption}
\usepackage[utf8]{inputenc}
\usepackage{newunicodechar}
\usepackage{underoverlap}

\let\Bbbk\relax
\usepackage{amsmath,amssymb,amsfonts}
\usepackage{newtxmath}
\usepackage{bbm}

\usepackage[utf8]{inputenc}
\usepackage{newunicodechar}

\newunicodechar{⊸}{$\multimap$}
\newunicodechar{𝕍}{$\mathbb{V}$}
\newunicodechar{𝕃}{$\mathbb{L}$}
\newunicodechar{𝕄}{$\mathbb{M}$}
\newunicodechar{ℝ}{$\mathbb{R}$}
\newunicodechar{𝕌}{$\mathbb{U}$}
\newunicodechar{𝔹}{$\mathbb{B}$}
\newunicodechar{𝕐}{$\mathbb{Y}$}
\newunicodechar{𝔼}{$\mathbb{E}$}
\newunicodechar{𝔽}{$\mathbb{F}$}
\newunicodechar{𝕋}{$\mathbb{T}$}
\newunicodechar{𝕚}{$\mathbb{i}$}
\newunicodechar{𝟘}{$\mathbb{0}$}
\newunicodechar{𝟙}{$\mathbb{1}$}
\newunicodechar{𝟚}{$\mathbb{2}$}
\newunicodechar{𝟛}{$\mathbb{3}$}
\newunicodechar{𝟠}{$\mathbb{8}$}
\newunicodechar{⟷}{$\leftrightarrow$}
\newunicodechar{₀}{$_{0}$}
\newunicodechar{₁}{$_{1}$}
\newunicodechar{₂}{$_{2}$}
\newunicodechar{₃}{$_{3}$}
\newunicodechar{₄}{$_{4}$}
\newunicodechar{¹}{$^{1}$}
\newunicodechar{²}{$^{2}$}
\newunicodechar{³}{$^{3}$}
\newunicodechar{⁴}{$^{4}$}
\newunicodechar{■}{$\blacksquare$}
\newunicodechar{⊡}{$\boxdot$}
\newunicodechar{⋆}{$\star$}
\newunicodechar{◎}{$\circledcirc$}
\newunicodechar{⊗}{$\otimes$}
\newunicodechar{⊕}{$\oplus$}
\newunicodechar{₊}{$_{+}$}
\newunicodechar{↔}{$\leftrightarrow$}
\newunicodechar{⇔}{$\Leftrightarrow$}
\newunicodechar{∀}{$\forall$}
\newunicodechar{ϕ}{$\phi$}
\newunicodechar{⋯}{$\AgdaInductiveConstructor{\ldots}$}

\usepackage[conor]{agda}
\AgdaNoSpaceAroundCode
% \renewcommand{\AgdaCodeStyle}{\footnotesize}

\input{\detokenize{ExamplesS.tex}}

\usepackage{macros}
\usepackage{hott}
\usepackage{syntax2}
\usepackage{microtype}

\usepackage{tikz}
\usetikzlibrary{decorations.markings}
\usetikzlibrary{quotes,fit,positioning}
\usetikzlibrary{arrows.meta, tikzmark}
\usetikzlibrary{knots}
\tikzstyle{func}=[rectangle,draw,fill=black!20,minimum size=1.9em,text width=2.4em, text centered]
\usetikzlibrary{braids}
\tikzset{>=latex}
\usepackage{tikzit}
\input{tikzit.tikzstyles}
\usepackage{quiver}
\usepackage[nocenter]{qtree}

\usepackage[most]{tcolorbox}

\newtcolorbox{dblock}[1][Definition]{
  colback=white,
  colframe=solarized-violet,
  colbacktitle=white!90!structure.fg,
  coltitle=black,
  fonttitle=\itshape,
  title={#1},
  enhanced,
  attach boxed title to top left={yshift=-2mm, xshift=0.5cm}
}

\newtcolorbox{tblock}[1][Lemma]{
  colback=white,
  colframe=solarized-blue,
  colbacktitle=white!90!structure.fg,
  coltitle=black,
  fonttitle=\itshape,
  title={#1},
  enhanced,
  attach boxed title to top left={yshift=-2mm, xshift=0.5cm}
}

\title{Symmetries in Reversible Programming}
\subtitle{From Symmetric Rig Groupoids to Reversible Programming Languages}
\author{Vikraman Choudhury, Jacek Karwowski, Amr Sabry}
\date{POPL 2022}

\begin{document}

\begin{frame}
  \titlepage
\end{frame}

\begin{frame}[fragile]{Permutations as tree transformations}
  Consider two programs which permute the elements of a 3-element set.

  \begin{figure}
    \[
      \Tree [ {\tiny A} [ {\tiny B} {\tiny C} ] ] ~\xrightarrow{\assoclp}~
      \Tree [ [ {\tiny A} {\tiny B} ] {\tiny C} ] ~\xrightarrow{\swapp}~
      \Tree [ {\tiny C} [ {\tiny A} {\tiny B} ] ] ~\xrightarrow[\phantom{xx}\swapp]{\idc\phantom{xx}}~
      \Tree [ {\tiny C} [ {\tiny B} {\tiny A} ] ] ~
    \]

    \[
      \Tree [ {\tiny A} [ {\tiny B} {\tiny C} ] ] ~\xrightarrow[\phantom{xx}\swapp]{\idc\phantom{xx}}~
      \Tree [ {\tiny A} [ {\tiny C} {\tiny B} ] ] ~\xrightarrow{\assoclp}~
      \Tree [ [ {\tiny A} {\tiny C} ] {\tiny B} ] ~\xrightarrow[\swapp\phantom{x}]{\phantom{x}\idc}~
      \Tree [ [ {\tiny C} {\tiny A} ] {\tiny B} ] ~\xrightarrow{\assocrp}~
      \Tree [ {\tiny C} [ {\tiny A} {\tiny B} ] ] ~\xrightarrow[\phantom{xx}\swapp]{\idc\phantom{xx}}~
      \Tree [ {\tiny C} [ {\tiny B} {\tiny A} ] ] ~
    \]
  \end{figure}
\end{frame}

\note{They are equal because they produce the same outputs on same inputs.}
\note{Can we design a sound and complete set of equations to decide equivalence of these programs?}

\begin{frame}{A reversible programming language with finite types}
  These combinators are the building blocks for a reversible programming language.
  \note{Formally, the language is presented as follows.}

  \medskip

  {\scalebox{\scalef}{$%
        \begin{array}{lrcl}
          \textit{Value types}   & A,B,C,D & ::= & \zerot \alts \onet \alts A+B \alts A\times B        \\
          \textit{Values}        & v,w,x,y & ::= & \Acon{tt} \alts \inlv{v} \alts \inrv{v} \alts (v,w) \\
          \textit{Program types} &         &     & A \isoone B                                         \\
          \textit{Programs}      & c       & ::= & (\textrm{See figure})
        \end{array}$}}

  \begin{figure}
    {\scalebox{\scalef}{$%
          %%\noindent\begin{minipage}{.7\linewidth}
          \begin{array}{rrcll}
            \idc :     & A                     & \isoone & A                            & : \idc      \\ [1.5ex]
            \identlp : & \zerot + A            & \isoone & A                            & : \identrp  \\
            \swapp :   & A + B                 & \isoone & B + A                        & : \swapp    \\
            \assoclp : & A + (B + C)           & \isoone & (A + B) + C                  & : \assocrp  \\ [1.5ex]
            \identlt : & \onet \times A        & \isoone & A                            & : \identrt  \\
            \swapt :   & A \times B            & \isoone & B \times A                   & : \swapt    \\
            \assoclt : & A \times (B \times C) & \isoone & (A \times B) \times C        & : \assocrt  \\ [1.5ex]
            \absorbr : & ~ \zerot \times A     & \isoone & \zerot ~                     & : \factorzl \\
            \dist :    & ~ (A + B) \times C    & \isoone & (A \times C) + (B \times C)~ & : \factor
          \end{array}$}}

    \medskip

    {\scalebox{\scalef}{%
        \Rule{}
        {\jdg{}{}{c_1 : A \isoone B} \quad \vdash c_2 : B \isoone C}
        {\jdg{}{}{c_1 \circledcirc c_2 : A \isoone C}}
        {}

        \Rule{}
        {\jdg{}{}{c_1 : A \isoone B} \quad \vdash c_2 : C \isoone D}
        {\jdg{}{}{c_1 \oplus c_2 : A + C \isoone B + D}}
        {}

        \Rule{}
        {\jdg{}{}{c_1 : A \isoone B} \quad \vdash c_2 : C \isoone D}
        {\jdg{}{}{c_1 \otimes c_2 : A \times C \isoone B \times D}}
        {}
      }}
  \end{figure}
\end{frame}

\begin{frame}[fragile]{Equational theory}
  \note{The hypothesis by Carette and Sabry is that the equational theory for this language is given by the coherence
    conditions of symmetric rig groupoids. These can be encoded by adding a second level of combinators to the language,
    equating \emph{programs} of Pi.}

  Examples of 2-combinators:

  \medskip

  \leveltwoblockone{}

  \note{There is a large number of such equations!}
  \note{This is a much more complicated equational theory compared to, say, the typed lambda calculus.}
\end{frame}

\begin{frame}[fragile]{Solving the example}

  2-combinator equating the examples:
  TODO.

  \note{How to produce this combinator? Essentially, we formally construct a denotational semantics for the language.
    Types are interpreted as finite sets, and reversible programs are interpreted as bijections between finite sets. Two
    bijections are equal if there is a homotopy between them. We show that this weak groupoid can be presented as the
    free symmetric rig groupoid on zero generators. This gives a sound and complete semantics for Pi, at both levels.}

  \note{Using this semantics, we can normalise Pi programs -- two extensionally equal programs have the same normal
    form. We can construct a 2-combinator relating Pi programs to their normal forms.}
\end{frame}

\begin{frame}[fragile]{Solving the example}

  Normal forms of the combinators:
  TODO.

\end{frame}

\begin{frame}[fragile]{Reversible Boolean Circuits}
  \note{Why is this semantics interesting/non-trivial? First, we can express interesting reversible boolean circuts
    using is language of type isomorphisms, and do normalization/synthesis of these. }

  We can write a 3-bit toffoli gate.

  \medskip

  \controlled{}
  \cnot{}
  \toffolithree{}

  Or, synthesise a reversible adder circuit from its truth table:
  TODO.
\end{frame}

\begin{frame}[fragile]{Contributions}
  \begin{plist}
    \item Curry-Howard-Lambek correspondence:
    Reversible Programming Languages $\leftrightsquigarrow$ Symmetric Rig Groupoids
    \medskip
    \begin{table}
      \begin{center}
        \begin{tabular}{cccc}
          \hline
          $\PiLang$     & $\bigsqcup_n \mathcal{B}\Sn $ & $\BFin$     & $\UFin$ \tabularnewline
          \hline\hline
          Types         & Natural numbers               & Finite sets & 0-cells \tabularnewline
          1-combinators & Generators of $\Sn$           & Bijections  & 1-paths \tabularnewline
          2-combinators & Relations of $\Sn$            & Homotopies  & 2-paths \tabularnewline
          \hline
        \end{tabular}
      \end{center}
      \label{fig:table-summary}
    \end{table}
    \medskip
    \item Full-abstraction and adequacy with respect to operational semantics
    \item Normalisation, equivalence, and synthesis for reversible circuits
    \item Transfer of theorems about permutations between different representations
  \end{plist}
\end{frame}

\appendix

\begin{frame}[fragile]
  We can represent these permutations as braid diagrams.

  \begin{figure}
    \begin{subfigure}[b]{0.3\textwidth}
      \centering
      \begin{tikzpicture}
        \def\nstrandsdf{3}
        \pic[local bounding box=my braid,braid/.cd,
          number of strands = \nstrandsdf,
          width = 0.8cm,
          height = 0.3cm,
          border height = 0.1cm,
          thick,
          name prefix=braid]
        {braid={s_2, s_2, s_2, s_1, s_2}};
        %   \draw[thick] % draws the top/bottom bars
        % ([xshift=-1ex]my braid.north west) --  ([xshift=1ex]my braid.north east)
        % ([xshift=-1ex]my braid.south west) --  ([xshift=1ex]my braid.south east);
        \node at (braid-1-s)[yshift = 2.0cm] {\tiny A};
        \node at (braid-2-s)[yshift = 2.0cm] {\tiny B};
        \node at (braid-3-s)[yshift = 2.0cm] {\tiny C};

        % labels the bottom bar
        \node at (braid-1-e)[yshift = -2.0cm] {\tiny A};
        \node at (braid-2-e)[yshift = -2.0cm] {\tiny B};
        \node at (braid-3-e)[yshift = -2.0cm] {\tiny C};
      \end{tikzpicture}
      \caption{}
      \label{fig:cone-braid}
    \end{subfigure}
    \begin{subfigure}[b]{0.3\textwidth}
      \centering
      \begin{tikzpicture}
        \def\nstrandsdf{3}
        \pic[local bounding box=my braid,braid/.cd,
          number of strands = \nstrandsdf,
          width = 0.8cm,
          height = 0.3cm,
          border height = 0.1cm,
          thick,
          name prefix=braid]
        {braid={1, s_2,, s_1, s_2, 1}};
        %   \draw[thick] % draws the top/bottom bars
        % ([xshift=-1ex]my braid.north west) --  ([xshift=1ex]my braid.north east)
        % ([xshift=-1ex]my braid.south west) --  ([xshift=1ex]my braid.south east);
        \node at (braid-1-s)[yshift = 2.0cm] {\tiny A};
        \node at (braid-2-s)[yshift = 2.0cm] {\tiny B};
        \node at (braid-3-s)[yshift = 2.0cm] {\tiny C};

        % labels the bottom bar
        \node at (braid-1-e)[yshift = -2.0cm] {\tiny A};
        \node at (braid-2-e)[yshift = -2.0cm] {\tiny B};
        \node at (braid-3-e)[yshift = -2.0cm] {\tiny C};
      \end{tikzpicture}
      \caption{}
      \label{fig:ctwo-braid}
    \end{subfigure}
    \begin{subfigure}[b]{0.3\textwidth}
      \centering
      \begin{tikzpicture}
        \def\nstrandsdf{3}
        \pic[local bounding box=my braid,braid/.cd,
          number of strands = \nstrandsdf,
          width = 0.8cm,
          height = 0.3cm,
          border height = 0.1cm,
          thick,
          name prefix=braid]
        {braid={1, s_1,, s_2, s_1, 1}};
        %   \draw[thick] % draws the top/bottom bars
        % ([xshift=-1ex]my braid.north west) --  ([xshift=1ex]my braid.north east)
        % ([xshift=-1ex]my braid.south west) --  ([xshift=1ex]my braid.south east);
        \node at (braid-1-s)[yshift = 2.0cm] {\tiny A};
        \node at (braid-2-s)[yshift = 2.0cm] {\tiny B};
        \node at (braid-3-s)[yshift = 2.0cm] {\tiny C};

        % labels the bottom bar
        \node at (braid-1-e)[yshift = -2.0cm] {\tiny A};
        \node at (braid-2-e)[yshift = -2.0cm] {\tiny B};
        \node at (braid-3-e)[yshift = -2.0cm] {\tiny C};
      \end{tikzpicture}
      \caption{}
      \label{fig:norm-braid}
    \end{subfigure}

    \label{fig:example-braid}
    \caption{Type isomorphisms as braiding diagrams}
  \end{figure}

\end{frame}

\begin{frame}{Denotational Semantics}
  We can give a semantics using the groupoid of finite sets and bijections.

  We use two symmetric monoidal structures.

  The equations can be given using the coherence conditions of symmetric rig groupoids.
\end{frame}

\begin{frame}
  We factor the semantics as follows, and show an equivalence of symmetric rig groupoids.
\end{frame}

\begin{frame}
  From this, we get:
  \begin{plist}
    \item Normalisation for reversible circuits
    \item A decision procedure to decide equivalence of programs.
    \item Transfer of theorems about permutations to theorems about reversible circuits.
    \item Full-abstraction and adequacy for this reversible language.
  \end{plist}
\end{frame}

\end{document}

%%% Local Variables:
%%% mode: latex
%%% TeX-master: t
%%% fill-column: 120
%%% End:
