% !TeX root = popl22-short.tex
% !TeX program = lualatex
\documentclass[lualatex,aspectratio=169,10pt]{beamer}
% \overfullrule=1em

\usefonttheme{professionalfonts}
% \usefonttheme{serif}

\beamertemplatenavigationsymbolsempty
\setbeamertemplate{footline}[frame number]

% \setbeameroption{show notes on second screen}

\usepackage{fontspec}
% \usepackage{unicode-math}

\setmainfont{Baskerville}
\setsansfont{Fira Sans}
\setmonofont{Iosevka}[
  Scale = MatchLowercase
]
% \setmathfont{texgyrepagella-math.otf}[math-style=TeX]

\setbeamersize{text margin left=5mm,text margin right=5mm}
\setbeamerfont{title}{size=\huge}

\setbeamercolor{normal text}{fg=solarized-base03, bg=white}
\setbeamercolor{structure}{fg=solarized-violet}

\usepackage[capitalise,noabbrev]{cleveref}
\usepackage[inline]{enumitem}
\usepackage{extarrows}
\usepackage{longtable}
\usepackage{adjustbox}
\usepackage{url}
\usepackage{multicol}
\usepackage{stmaryrd}
\usepackage{proof}
%\usepackage{bbold}
%\usepackage[bb=boondox]{mathalfa}
\usepackage{subcaption}
\captionsetup[subfigure]{labelformat=empty}
\usepackage[utf8]{inputenc}
\usepackage{newunicodechar}
\usepackage{underoverlap}
\usepackage{eqparbox}

\let\Bbbk\relax
\usepackage{amsmath}
\usepackage{amssymb,amsfonts}
\usepackage{newtxmath}
\usepackage{bbm}

\usepackage[utf8]{inputenc}
\usepackage{newunicodechar}

\newunicodechar{‚ä∏}{$\multimap$}
\newunicodechar{ùïç}{$\mathbb{V}$}
\newunicodechar{ùïÉ}{$\mathbb{L}$}
\newunicodechar{ùïÑ}{$\mathbb{M}$}
\newunicodechar{‚Ñù}{$\mathbb{R}$}
\newunicodechar{ùïå}{$\mathbb{U}$}
\newunicodechar{ùîπ}{$\mathbb{B}$}
\newunicodechar{ùïê}{$\mathbb{Y}$}
\newunicodechar{ùîº}{$\mathbb{E}$}
\newunicodechar{ùîΩ}{$\mathbb{F}$}
\newunicodechar{ùïã}{$\mathbb{T}$}
\newunicodechar{ùïö}{$\mathbb{i}$}
\newunicodechar{ùüò}{$\mathbb{0}$}
\newunicodechar{ùüô}{$\mathbb{1}$}
\newunicodechar{ùüö}{$\mathbb{2}$}
\newunicodechar{ùüõ}{$\mathbb{3}$}
\newunicodechar{ùü†}{$\mathbb{8}$}
\newunicodechar{‚ü∑}{$\leftrightarrow$}
\newunicodechar{‚ÇÄ}{$_{0}$}
\newunicodechar{‚ÇÅ}{$_{1}$}
\newunicodechar{‚ÇÇ}{$_{2}$}
\newunicodechar{‚ÇÉ}{$_{3}$}
\newunicodechar{‚ÇÑ}{$_{4}$}
\newunicodechar{¬π}{$^{1}$}
\newunicodechar{¬≤}{$^{2}$}
\newunicodechar{¬≥}{$^{3}$}
\newunicodechar{‚Å¥}{$^{4}$}
\newunicodechar{‚ñ†}{$\blacksquare$}
\newunicodechar{‚ä°}{$\boxdot$}
\newunicodechar{‚ãÜ}{$\star$}
\newunicodechar{‚óé}{$\circledcirc$}
\newunicodechar{‚äó}{$\otimes$}
\newunicodechar{‚äï}{$\oplus$}
\newunicodechar{‚Çä}{$_{+}$}
\newunicodechar{‚Üî}{$\leftrightarrow$}
\newunicodechar{‚áî}{$\Leftrightarrow$}
\newunicodechar{‚àÄ}{$\forall$}
\newunicodechar{œï}{$\phi$}
\newunicodechar{‚ãØ}{$\AgdaInductiveConstructor{\ldots}$}

\usepackage[conor]{agda}
\AgdaNoSpaceAroundCode
% \renewcommand{\AgdaCodeStyle}{\footnotesize}
\definecolor{AgdaUnsolvedMeta}{HTML}{FFFFFF}
\newcommand{\AIC}[1]{\AgdaInductiveConstructor{#1}}

\input{\detokenize{ExamplesS.tex}}

\usepackage{macros}
\usepackage{hott}
\usepackage{syntax2}
\usepackage{microtype}

\usepackage{tikz}
\usetikzlibrary{decorations.markings}
\usetikzlibrary{quotes,fit,positioning}
\usetikzlibrary{arrows.meta, tikzmark}
\usetikzlibrary{knots}
\tikzstyle{func}=[rectangle,draw,fill=black!20,minimum size=1.9em,text width=2.4em, text centered]
\usetikzlibrary{braids}
\tikzset{>=latex}
\usepackage{tikzit}
\input{tikzit.tikzstyles}
\usepackage{quiver}
\usepackage[nocenter]{qtree}

\usepackage[most]{tcolorbox}

\newtcolorbox{dblock}[1][Definition]{
  colback=white,
  colframe=solarized-violet,
  colbacktitle=white!90!structure.fg,
  coltitle=black,
  fonttitle=\itshape,
  title={#1},
  enhanced,
  attach boxed title to top left={yshift=-2mm, xshift=0.5cm}
}

\newtcolorbox{tblock}[1][Lemma]{
  colback=white,
  colframe=solarized-blue,
  colbacktitle=white!90!structure.fg,
  coltitle=black,
  fonttitle=\itshape,
  title={#1},
  enhanced,
  attach boxed title to top left={yshift=-2mm, xshift=0.5cm}
}

\title{Symmetries in Reversible Programming}
\subtitle{From Symmetric Rig Groupoids to Reversible Programming Languages}
\author{\underline{Vikraman Choudhury}, Jacek Karwowski, Amr Sabry}
\date{POPL 2022}

\begin{document}

\begin{frame}
  \titlepage

  \note{ Hi, \ldots }
\end{frame}

\begin{frame}[fragile]{Permutations as tree transformations}
  Consider two programs which permute the elements of a 3-element set.
  \bigskip

  \begin{figure}
    \begin{subfigure}[b]{0.95\textwidth}
      \centering
      \[
        \Tree [ {\tiny A} [ {\tiny B} {\tiny C} ] ] ~\xrightarrow{\assoclp}~
        \Tree [ [ {\tiny A} {\tiny B} ] {\tiny C} ] ~\xrightarrow{\swapp}~
        \Tree [ {\tiny C} [ {\tiny A} {\tiny B} ] ] ~\xrightarrow[\phantom{xx}\swapp]{\idc\phantom{xx}}~
        \Tree [ {\tiny C} [ {\tiny B} {\tiny A} ] ] ~
      \]
      \caption{$p_1$}
    \end{subfigure}
    \vfill
    \begin{subfigure}[b]{0.95\textwidth}
      \centering
      \[
        \Tree [ {\tiny A} [ {\tiny B} {\tiny C} ] ] ~\xrightarrow[\phantom{xx}\swapp]{\idc\phantom{xx}}~
        \Tree [ {\tiny A} [ {\tiny C} {\tiny B} ] ] ~\xrightarrow{\assoclp}~
        \Tree [ [ {\tiny A} {\tiny C} ] {\tiny B} ] ~\xrightarrow[\swapp\phantom{x}]{\phantom{x}\idc}~
        \Tree [ [ {\tiny C} {\tiny A} ] {\tiny B} ] ~\xrightarrow{\assocrp}~
        \Tree [ {\tiny C} [ {\tiny A} {\tiny B} ] ] ~\xrightarrow[\phantom{xx}\swapp]{\idc\phantom{xx}}~
        \Tree [ {\tiny C} [ {\tiny B} {\tiny A} ] ] ~
      \]
      \caption{$p_2$}
    \end{subfigure}
  \end{figure}
  \note{
    They are drawn as tree transformations of binary trees.

    The first program rotates the tree to the left, then swaps the left and right children, and then swaps the leaves.

    The second program works differently. First, it swaps the leaves, then does a left rotation, swaps the leaves again,
    does a right rotation, and finally swaps the leaves.

    They are both bijections, or permutations, but they are equal because they produce the same outputs on same inputs.
  }
  \note{Can we design a sound and complete set of equations to decide equivalence of such programs?}
\end{frame}

\begin{frame}{A reversible programming language with finite types: $\PiLang$}
  \note{%
    These combinators are the building blocks for a reversible programming language. Formally, the language is
    presented as follows. The types are built from 0, 1, $+$ and $\times$. The programs, or 1-combinators, are built
    from type isomorphisms, such as $\idc$ and $\swapp$, and constructors for composition.
  }
  \bigskip

  {\scalebox{\scalef}{$%
        \begin{array}{lrcl}
          \textit{Value types}   & A,B & ::= & \zerot \alts \onet \alts A+B \alts A\times B        \\
          \textit{Values}        & v,w & ::= & \Acon{tt} \alts \inlv{v} \alts \inrv{v} \alts (v,w) \\
          \textit{Program types} &     &     & A \isoone B                                         \\
          \textit{Programs}      & c   & ::= &
        \end{array}$}}

  \begin{figure}
    {\scalebox{\scalef}{$%
          %%\noindent\begin{minipage}{.7\linewidth}
          \begin{array}{rrcll}
            \idc :     & A                     & \isoone & A                            & : \idc      \\ [1.5ex]
            \identlp : & \zerot + A            & \isoone & A                            & : \identrp  \\
            \swapp :   & A + B                 & \isoone & B + A                        & : \swapp    \\
            \assoclp : & A + (B + C)           & \isoone & (A + B) + C                  & : \assocrp  \\ [1.5ex]
            \identlt : & \onet \times A        & \isoone & A                            & : \identrt  \\
            \swapt :   & A \times B            & \isoone & B \times A                   & : \swapt    \\
            \assoclt : & A \times (B \times C) & \isoone & (A \times B) \times C        & : \assocrt  \\ [1.5ex]
            \absorbr : & ~ \zerot \times A     & \isoone & \zerot ~                     & : \factorzl \\
            \dist :    & ~ (A + B) \times C    & \isoone & (A \times C) + (B \times C)~ & : \factor
          \end{array}$}}

    \bigskip

    {\scalebox{\scalef}{%
        \Rule{}
        {\jdg{}{}{c_1 : A \isoone B} \quad \vdash c_2 : B \isoone C}
        {\jdg{}{}{c_1 \circledcirc c_2 : A \isoone C}}
        {}

        \Rule{}
        {\jdg{}{}{c_1 : A \isoone B} \quad \vdash c_2 : C \isoone D}
        {\jdg{}{}{c_1 \oplus c_2 : A + C \isoone B + D}}
        {}

        \Rule{}
        {\jdg{}{}{c_1 : A \isoone B} \quad \vdash c_2 : C \isoone D}
        {\jdg{}{}{c_1 \otimes c_2 : A \times C \isoone B \times D}}
        {}
      }}
  \end{figure}
\end{frame}

\begin{frame}[fragile]{Reversible Boolean Circuits: 3-bit Toffoli gate}
  \note{%
    This language can express interesting reversible boolean circuts which are used in quantum computing. For example,
    we can define a not gate, a controlled not gate, and a 3-bit toffoli gate. }

  \bigskip

  \controlled{}
  \cnot{}
  \toffolithree{}
\end{frame}

\begin{frame}[fragile]{Equational theory: Examples of 2-combinators}
  \note{
    The goal of this work is to design a sound and complete equational theory for reversible programs in this language.

    Carette and Sabry conjectured that these type isomorphisms satisfy the coherence conditions of symmetric rig
    groupoids. These can be encoded by adding a second level of combinators to the language, equating Pi programs. For
    example, we have combinators for coherence of composition, groupoid laws, and symmetric monoidal coherences.
  }

  \bigskip

  \begin{figure}
    {\scalebox{\scalef}{
        \Rule{}
        {\jdg{}{}{c_1 : A \isoone B} \quad {\vdash c_2 : A \isoone B}}
        {\jdg{}{}{c_1 \isotwo c_2}}
        {}
      }}
  \end{figure}
  \pause
  \medskip

  \begin{figure}
    {\scalebox{\scalef}{$%
          %%\noindent\begin{minipage}{.7\linewidth}
          \begin{array}{rrcll}
            \AIC{id‚ü∑‚ÇÇ} :     & c                                       & \isotwo & c                                       & : \AIC{id‚ü∑‚ÇÇ}     \\ [1.5ex]
            \AIC{assoc‚óél} :  & c_1 \circledcirc (c_2 \circledcirc c_3) & \isotwo & (c_1 \circledcirc c_2) \circledcirc c_3 & : \AIC{assoc‚óér}  \\ [1.5ex]
            \AIC{idl‚óél} :    & \idc \circledcirc c                     & \isotwo & c                                       & : \AIC{idl‚óér}    \\
            \AIC{idr‚óél} :    & c \circledcirc \idc                     & \isotwo & c                                       & : \AIC{idr‚óér}    \\
            \AIC{linv‚óél} :   & c \circledcirc \AIC{!‚ü∑‚ÇÅ} c              & \isotwo & \idc                                    & : \AIC{linv‚óér}   \\
            \AIC{swapl‚Çä‚ü∑‚ÇÇ} : & \swapp \circledcirc (c_1 \oplus c_2)    & \isotwo & (c_2 \oplus c_1) \circledcirc \swapp    & : \AIC{swapr‚Çä‚ü∑‚ÇÇ}
          \end{array}$}}

    \bigskip

    {\scalebox{\scaleff}{$%
          %%\noindent\begin{minipage}{.7\linewidth}
          \begin{array}{rrcll}
            \AIC{pentagon‚Çäl} : & \assocrp \circledcirc \assocrp                       & \isotwo & ((\assocrp \oplus \idc) \circledcirc \assocrp) \circledcirc (\idc \oplus \assocrp) & : \AIC{pentagon‚Çär} \\
            \AIC{hexagonl‚Çäl} : & (\assoclp \circledcirc \swapp) \circledcirc \assoclp & \isotwo & ((\idc \oplus \swapp) \circledcirc \assoclp) \circledcirc (\swapp \oplus \idc)     & : \AIC{hexagonl‚Çär}
          \end{array}$}}

    \bigskip

    {\scalebox{\scalef}{%
        \Rule{}
        {\jdg{}{}{\alpha_1 : c_1 \isotwo c_2} \quad \vdash \alpha_2 : c_2 \isotwo c_3}
        {\jdg{}{}{\alpha_1\;\blacksquare\;\alpha_2 : c_1 \isotwo c_3}}
        {}

        \Rule{}
        {\jdg{}{}{\alpha_1 : c_1 \isotwo c_3} \quad \vdash \alpha_2 : c_2 \isotwo c_4}
        {\jdg{}{}{\alpha_1\;\boxdot\;\alpha_2 : (c_1 \circledcirc c_2) \isotwo (c_3 \circledcirc c_4)}}
        {}
      }}
  \end{figure}

  \note{ There is a large number of such equations, which makes it a much more complicated equational theory compared
    to, say, the beta-eta equations in the typed lambda calculus. }
\end{frame}

\begin{frame}[fragile]{Solving the example}
  \note{
    Going back to our example, here is a 2-combinator that shows that they're equal. This can also be visualised as a
    commutative diagram as shown below.

    In this work, we will show that any two equal permutations can be equated using such combinators. How do we do
    this?}

  % \note{
  %   Essentially, we formally construct a denotational semantics for the language.
  %   Types are interpreted as finite sets, and reversible programs are interpreted as bijections between finite sets. Two
  %   bijections are equal if there is a homotopy between them. We show that this weak groupoid can be presented as the
  %   free symmetric rig groupoid on zero generators. This gives a sound and complete semantics for Pi, at both levels.}

  % \note{Using this semantics, we can normalise Pi programs -- two extensionally equal programs have the same normal
  %   form. We can construct a 2-combinator relating Pi programs to their normal forms.}
  % 2-combinator equating the examples:
  % \medskip
  \leveltwoexample{}

  % https://q.uiver.app/?q=WzAsOCxbMCwwLCJBICsgKEIgKyBDKSJdLFsyLDAsIihBICsgQikgKyBDIl0sWzQsMCwiQyArIChBICsgQikiXSxbNiwwLCJDICsgKEIgKyBBKSJdLFswLDIsIkEgKyAoQyArIEIpIl0sWzIsMiwiKEEgKyBDKSArIEIiXSxbNCwyLCIoQyArIEEpICsgQiJdLFs2LDIsIkMgKyAoQSArIEIpIl0sWzAsMSwiXFxhc3NvY2xwIl0sWzEsMiwiXFxzd2FwcCJdLFsyLDMsIlxcaWRjflxcb3BsdXN+XFxzd2FwcCJdLFswLDQsIlxcaWRjflxcb3BsdXN+XFxzd2FwcCIsMl0sWzQsNSwiXFxhc3NvY2xwIiwyXSxbNSw2LCJcXHN3YXBwflxcb3BsdXN+XFxpZGMiLDJdLFs2LDcsIlxcYXNzb2NycCIsMl0sWzMsNywiXFxpZGN+XFxvcGx1c35cXHN3YXBwIl0sWzIsNiwiXFxhc3NvY2xwIiwyXV0=
  \[\begin{tikzcd}[ampersand replacement=\&]
      {A + (B + C)} \&\& {(A + B) + C} \&\& {C + (A + B)} \&\& {C + (B + A)} \\
      \\
      {A + (C + B)} \&\& {(A + C) + B} \&\& {(C + A) + B} \&\& {C + (A + B)}
      \arrow["\assoclp", from=1-1, to=1-3]
      \arrow["\swapp", from=1-3, to=1-5]
      \arrow["{\idc~\oplus~\swapp}", from=1-5, to=1-7]
      \arrow["{\idc~\oplus~\swapp}"', from=1-1, to=3-1]
      \arrow["\assoclp"', from=3-1, to=3-3]
      \arrow["{\swapp~\oplus~\idc}"', from=3-3, to=3-5]
      \arrow["\assocrp"', from=3-5, to=3-7]
      \arrow["{\idc~\oplus~\swapp}", from=1-7, to=3-7]
      \arrow["\assoclp"', from=1-5, to=3-5]
    \end{tikzcd}\]
\end{frame}

\begin{frame}[fragile]{Permutations as braid diagrams}
  \note{Notice that, the only non-trivial computational content is in the swaps. We represent these permutations using
    braid diagrams, and they look like strings. We can add relations between them which allow one to freely slide wires,
    or cancel adjacent transpositions.}

  \note{The programs $p_1$ and $p_2$ can be normalised using these braid relations, to get the third diagram.}

  % We can represent these permutations as braid diagrams.

  \begin{figure}
    \begin{subfigure}[b]{0.45\textwidth}
      \centering
      \begin{tikzpicture}
        \def\nstrandsdf{3}
        \pic[local bounding box=my braid,braid/.cd,
          number of strands = \nstrandsdf,
          width = 0.8cm,
          height = 0.3cm,
          border height = 0.1cm,
          thick,
          name prefix=braid]
        {braid={s_2, s_2, s_2, s_1, s_2}};
        %   \draw[thick] % draws the top/bottom bars
        % ([xshift=-1ex]my braid.north west) --  ([xshift=1ex]my braid.north east)
        % ([xshift=-1ex]my braid.south west) --  ([xshift=1ex]my braid.south east);
        \node at (braid-1-s)[yshift = 2.0cm] {\tiny A};
        \node at (braid-2-s)[yshift = 2.0cm] {\tiny B};
        \node at (braid-3-s)[yshift = 2.0cm] {\tiny C};

        % labels the bottom bar
        \node at (braid-1-e)[yshift = -2.0cm] {\tiny A};
        \node at (braid-2-e)[yshift = -2.0cm] {\tiny B};
        \node at (braid-3-e)[yshift = -2.0cm] {\tiny C};
      \end{tikzpicture}
      \caption{$p_1 \mapsto [1,0,1,1,1]$}
    \end{subfigure}
    \begin{subfigure}[b]{0.45\textwidth}
      \centering
      \begin{tikzpicture}
        \def\nstrandsdf{3}
        \pic[local bounding box=my braid,braid/.cd,
          number of strands = \nstrandsdf,
          width = 0.8cm,
          height = 0.3cm,
          border height = 0.1cm,
          thick,
          name prefix=braid]
        {braid={1, s_2,, s_1, s_2, 1}};
        %   \draw[thick] % draws the top/bottom bars
        % ([xshift=-1ex]my braid.north west) --  ([xshift=1ex]my braid.north east)
        % ([xshift=-1ex]my braid.south west) --  ([xshift=1ex]my braid.south east);
        \node at (braid-1-s)[yshift = 2.0cm] {\tiny A};
        \node at (braid-2-s)[yshift = 2.0cm] {\tiny B};
        \node at (braid-3-s)[yshift = 2.0cm] {\tiny C};

        % labels the bottom bar
        \node at (braid-1-e)[yshift = -2.0cm] {\tiny A};
        \node at (braid-2-e)[yshift = -2.0cm] {\tiny B};
        \node at (braid-3-e)[yshift = -2.0cm] {\tiny C};
      \end{tikzpicture}
      \caption{$p_2 \mapsto [1,0,1]$}
    \end{subfigure}
    \pause
    \begin{subfigure}[b]{0.3\textwidth}
      \centering
      \begin{tikzpicture}
        \def\nstrandsdf{3}
        \pic[local bounding box=my braid,braid/.cd,
          number of strands = \nstrandsdf,
          width = 0.8cm,
          height = 0.3cm,
          border height = 0.1cm,
          thick,
          name prefix=braid]
        {braid={1, s_1,, s_2, s_1, 1}};
        %   \draw[thick] % draws the top/bottom bars
        % ([xshift=-1ex]my braid.north west) --  ([xshift=1ex]my braid.north east)
        % ([xshift=-1ex]my braid.south west) --  ([xshift=1ex]my braid.south east);
        \node at (braid-1-s)[yshift = 2.0cm] {\tiny A};
        \node at (braid-2-s)[yshift = 2.0cm] {\tiny B};
        \node at (braid-3-s)[yshift = 2.0cm] {\tiny C};

        % labels the bottom bar
        \node at (braid-1-e)[yshift = -2.0cm] {\tiny A};
        \node at (braid-2-e)[yshift = -2.0cm] {\tiny B};
        \node at (braid-3-e)[yshift = -2.0cm] {\tiny C};
      \end{tikzpicture}
      \caption{Normal form: $[0,1,0]$}
    \end{subfigure}
  \end{figure}

\end{frame}


\begin{frame}[fragile]{Denotational Semantics}
  \note{Using this trick, we can give a denotational semantics for the language using the groupoid of finite sets and
    bijections, but we will factor the semantics into 3 steps, where each step is an equivalence.}

  \note{Starting from the full language, we move to the additive fragment (where multiplication is implemented as
    repeated addition), then to a simplified version of the language (which has natural numbers and adjacent
    transpositions), and then finally to the groupoid $\UFin$.}

  \begin{figure}
    \centering
    \scalebox{1.5}{
      % https://q.uiver.app/?q=WzAsNCxbMCwwLCJcXFBpTGFuZyJdLFsyLDAsIlxcUGlQbHVzTGFuZyJdLFs0LDAsIlxcUGlIYXRMYW5nIl0sWzYsMCwiXFxVRmluIl0sWzAsMSwiXFxldmFsdCIsMCx7ImN1cnZlIjotNH1dLFsxLDIsIlxcZXZhbHAiLDAseyJjdXJ2ZSI6LTR9XSxbMiwzLCJcXGV2YWxoIiwwLHsiY3VydmUiOi00fV0sWzIsMSwiXFxxdW90ZXAiLDAseyJjdXJ2ZSI6LTR9XSxbMywyLCJcXHF1b3RlaCIsMCx7ImN1cnZlIjotNH1dLFsxLDAsIlxccXVvdGV0IiwwLHsiY3VydmUiOi00fV1d
      $\begin{tikzcd}[ampersand replacement=\&]
          \PiLang \&\& \PiPlusLang \&\& \PiHatLang \&\& \UFin
          \arrow["\evalt", curve={height=-24pt}, from=1-1, to=1-3]
          \arrow["\evalp", curve={height=-24pt}, from=1-3, to=1-5]
          \arrow["\evalh", curve={height=-24pt}, from=1-5, to=1-7]
          \arrow["\quotep", curve={height=-24pt}, from=1-5, to=1-3]
          \arrow["\quoteh", curve={height=-24pt}, from=1-7, to=1-5]
          \arrow["\quotet", curve={height=-24pt}, from=1-3, to=1-1]
        \end{tikzcd}$
    }
  \end{figure}

  \bigskip

  \begin{figure}
    \centering
    \scalebox{1.5}{$
        \parbox[c]{2cm}{\centering$\boolt \prodt (\boolt \prodt \boolt)$} \xrightarrow{\evalt}
        \parbox[c]{2.5cm}{\centering$(\boolt \sumt \boolt) \sumt (\boolt \sumt \boolt)$} \xrightarrow{\evalp}
        \parbox[c]{0.5cm}{\centering$8$} \xrightarrow{\evalh}
        \parbox[c]{1cm}{\centering$\Fin[8]$}
      $}
  \end{figure}

\end{frame}

\begin{frame}{Contributions}
  \note{
    In the paper, we use this semantics to establish a Lambek correspondence between reversible programming
    languages and symmetric rig groupoids, just like the simply-typed lambda calculus and cartesian closed categories.
    We also establish full-abstraction and adequacy for the language with respect to its operational semantics.
  }
  \note{
    Using the semantics, we can perform normalisation-by-evaluation for reversible boolean circuits written in the Pi
    language and decide their equivalence by inspecting the normal forms. We can also synthesise reversible circuits
    from their truth tables written as permutations.
  }
  \note{
    Finally, using different representations of permutations, we can transfer proofs of theorems between them, and use
    this to prove interesting theorems about reversible boolean circuits.
  }
  \note{
    Our semantics is also formalised in Agda and available as an artifact.
  }
  \note{
    Thank you!
  }
  \begin{plist}
    \item Curry-Howard-Lambek correspondence:
    \begin{center}
      Reversible Programming Languages $\leftrightsquigarrow$ Symmetric Rig Groupoids
    \end{center}
    \medskip
    \begin{table}
      \begin{center}
        \begin{tabular}{cccc}
          \hline
          $\PiLang$     & $\bigsqcup_n \mathcal{B}\Sn $ & $\BFin$     & $\UFin$ \tabularnewline
          \hline\hline
          Types         & Natural numbers               & Finite sets & 0-cells \tabularnewline
          1-combinators & Generators of $\Sn$           & Bijections  & 1-paths \tabularnewline
          2-combinators & Relations of $\Sn$            & Homotopies  & 2-paths \tabularnewline
          \hline
        \end{tabular}
      \end{center}
      \label{fig:table-summary}
    \end{table}
    \pause
    \medskip
    \item Full-abstraction and adequacy with respect to operational semantics
    \pause
    \item Normalisation, equivalence, and synthesis for reversible circuits
    \pause
    \item Transfer of theorems about permutations between different representations
    \pause
    \item Agda formalisation using HoTT-Agda
  \end{plist}
  \pause
  \vfill
  \begin{center}
    \Large
    \url{https://arxiv.org/abs/2110.05404}
  \end{center}
\end{frame}


\end{document}

% 1: 10
% 2: 50
% 3: 30
% 4: 15
% 5: 30
% 6: 30
% 7: 30
% 8: 30
% 9: 60
% total: 4:45

%%% Local Variables:
%%% mode: latex
%%% TeX-master: t
%%% fill-column: 120
%%% End:

