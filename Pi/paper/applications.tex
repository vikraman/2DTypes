\section{Applications to Reversible Circuits}
\label{sec:applications}

Using our semantics, we can normalise, synthesise, prove equivalence, and reason about~$\PiLang$ programs. We describe a
few applications in this section, and a more comprehensive list of applications and examples along with their
foramlisation is available in our artifact~\cite{choudhuryArtifactSymmetriesReversible2021}.

% \[
%   \begin{tikzpicture}[->,>=stealth',auto,thick,node distance=1em]
%     % nodes
%     \node (A) at (0, 2) {\Afun{reversibleOr1}};
%     \node (B) at (0, 0) {\Afun{reversibleOr2}};
%     \node (C) at (4, 1) {\Afun{reversibleOrNorm}};
%     \node (D) at (9, 1) {\AgdaSymbol{(}\AgdaNumber{0 5 6 7 4 1 2 3}\AgdaSymbol{)}};
%     % arrows
%     \path
%     (A) edge[bend left] node [above left] { $\strut\normt_{1}$ } (C)
%     (B) edge[bend right] node [below left] { $\strut\normt_{1}$ } (C)
%     (D) edge node[above] { $\strut\term{quote}$ } (C);
%   \end{tikzpicture}
% \]

% \[
%   \begin{tabular}{>{$}c<{$} @{\hspace{5em}} >{$}c<{$}}
%     \tikzmarknode{A}{\Afun{reversibleOr1}} & \\
%                                            & \tikzmarknode{C}{\Afun{reversibleOrNorm}} \\
%     \tikzmarknode{B}{\Afun{reversibleOr2}} &
%   \end{tabular}
%   % \tikzmarknode{D}{4}
%   \begin{tikzpicture}[overlay, remember picture, shorten <=1mm,
%     nodes={inner sep=1pt, align=center, font=\footnotesize}]
%     \draw (A.south) -- ++ (-1,-1) node[below] {2 bits};
%     \draw (B.south) -- ++ (-.5,-1) node[below] {2 bits};
%     % \draw (D.south) -- ++ (.5,-1) node[below] {3 bits};
%   \end{tikzpicture}
% \]

\subsection{Normalisation}

Normalisation happens by evaluating a combinator to a permutation and then reifying it back. The evaluation step goes
from $\PiLang$ to $\PiPlusLang$ reducing $\times$ to $+$ and translating the corresponding combinators, then from
$\PiPlusLang$ to $\PiHatLang$ reducing them to natural numbers and adjacent transpositions, then finally to $\UFin$
through words in $\Sn$ and Lehmer codes. Finally, the quotation step goes all the way back until $\PiPlusLang$. We
define this composite $\normt$ function below using our previous evaluation function $\gdenot{\blank}$.

\begin{definition}[Normalisation of $\PiLang$ programs]
  \begin{gather*}
    \begin{aligned}
      \normt_{0} & : U \to \UPlus                                            \\
      \normt_{0} & = \quotep_{0} \comp \quoteh_{0} \comp \gdenot{\blank}_{0}
    \end{aligned}
    \qquad
    \begin{aligned}
      \normt_{1} & : (c : X \iso Y) \to \normt_{0}(X) \iso \normt_{0}(Y)     \\
      \normt_{1} & = \quotep_{1} \comp \quoteh_{1} \comp \gdenot{\blank}_{1}
    \end{aligned}
  \end{gather*}
\end{definition}

\noindent
As an example, consider the \Afun{reversibleOr1} circuit introduced in~\cref{sec:pi}. After applying $\normt_{1}$, the
type $\mathbb{B}\ 3$ normalises to $\mathbb{8}+ \equiv \mathbb{1} + (\mathbb{1} + (\mathbb{1} + (\mathbb{1} +
  (\mathbb{1} + (\mathbb{1} + (\mathbb{1} + (\mathbb{1} + \mathbb{0})))))))$, and the circuit reduces to the following
normal form:

\medskip
\resetnormtwo{}

\subsection{Equivalence}

By normalisation, we also get a decision procedure for program equivalence -- two circuits are equivalent iff they
represent the same permutation, or equivalently, they have the same normal form. Recall that in~\cref{sec:examples} we
introduced two different ways of computing reversible disjunction using two Qiskit circuit implementations, and then
in~\cref{sec:pi} showed the corresponding $\PiLang$ definitions: \Afun{reversibleOr1} and \Afun{reversibleOr2}.

After applying $\normt_{1}$ to each circuit, we verify that they both reduce to the same normal form
\Afun{reversibleOrNorm}, along with a 2-combinator witnessing their equivalence with the normal form -- by composing
these, we get the 2-combinator witnessing their equivalence. More general, user-guided, reasoning can be done using the
sound and complete level-2 combinators to rewrite $\PiLang$ programs.


\subsection{Synthesis and verification}

Instead of manually producing $\PiLang$-programs to implement the reversible disjunction specification, it is possible
to simply write down the permutation directly and then quote it, synthesising a $\PiLang$ program. We use a function
$\term{lookup}$ to write tabulated permutations for readability.

\medskip
\resetperm{}

\noindent
The permutation uses the canonical encoding of sequences of bits as natural numbers, e.g., {(\textsf{false},
    \textsf{true},\textsf{true})} is encoded as 011 or 3. The second entry in the $\term{lookup}$ table maps index 1 (= 001)
to the value 5 (= 101), following the reversible disjunction specification (recall that
$\mathsf{reversibleOr}(h,b_1,b_2) = (h \,\underline{\vee}\, (b_1 \vee b_2), ~b_1, ~b_2)$ where~$\vee$ is disjunction
and~$\underline{\vee}$ is exclusive-disjunction). Quoting this permutation generates the same normalised program
\Afun{reversibleOrNorm}, matching the desired structured type of a 1-combinator on $\mathbb{8}+$.

In a similar way we can also verify whether a circuit is correctly implemented: by running the equivalence described
above in the other direction, we can evaluate the circuit to a bijection and compare it extensionally with the intended
one.

\subsection{Reasoning}

In our development, we described a number of different representations of permutations: $\PiLang$, $\PiPlusLang$ and
$\PiHatLang$ programs, lists of transpositions, Lehmer codes, and automorphisms of finite sets. The equivalences between
these representations allows us to transfer theorems about permutations, proving them on the representations most suited
for the particular task and getting others for free.

As an example, consider the following problem. Toffoli gate on 3 bits can be extended to 4 bits, inserting a wire in
four possible positions. The function of such gate is then identity on the newly inserted bit, and controlled-controlled
not on the three remaining ones.
\medskip
\extendedToffoli{}

\noindent
On the other hand, it is possible to construct a proper 4-bit toffoli gate:
\medskip
\toffoli{}

\noindent
Now, the question we want to answer is: is it possible to implement \Afun{toffoli₄} gate only using \Afun{toffoli₃} gates?

Solving this problem using the circuit representation is difficult. However, we can observe that all \Afun{toffoli₃}
gates implements even permutations, that is, permutations consisting of an even number of transpositions. On the other
hand, \Afun{toffoli₄} implements an odd permutation. It is an easily proven lemma that any composition of even
permutations always produces an even permutation, which answers the question to the negative. Thus, we want to formulate
the theorem using the representation on lists of transpositions, and transfer it to circuits using the equivalences
proven in the previous sections.

Thus, define a function $\parity : (c : X \iso Y) \to \Bool$ to compute a parity of a permutation defined by a
combinator $c$, by first tranforming a $\PiLang$ program into a list of transpositions (using $\evalh_{1}$ defined
in~\cref{sec:equivalence}), and then computing the parity on this representation, which amounts to a simple check of the
partiy of the length of the list.

\begin{propositionrep}
  \label{prop:parity-preserved}
  For two $\PiLang$ circuits $c_1, c_2$, if $c_1 \Iso c_2$, then $\parity(c_1) = \term{parity}(c_2)$.
\end{propositionrep}
\begin{proof}
  First, it is an easy check that Coxeter relations preserve parity of the list. Second, if $c_1$ and $c_2$ are related
  by a 2-combinator, then their Lehmer codes are the same, so their list-of-transpositions representations have to be
  related by the Coxeter relation. Composing these two facts completes the proof.
\end{proof}

Using ~\cref{prop:parity-preserved} and already mentioned lemma that any compostion of even circuits is even, we can
finish the proof by running $\parity$ on \Afun{toffoli₄} and on all of the \Afun{toffoli₃}.

% \paragraph*{Program synthesis.} The NbE process embodies a quoting mechanism that synthesizes programs from
% permutations. Indeed, instead of writing a program for \Afun{reset 2}, one could simply specify the desired permutation
% as:

%%\begin{minipage}{.65\textwidth}
%%  \PiRESET{}
%%\end{minipage}
%%\begin{minipage}{.30\textwidth}
%%  \begin{center}
%%  \resizebox{0.5\textwidth}{!}{\input{diagrams/reset.tikz}}
%%  \end{center}
%%\end{minipage}

%% \resettwo{}

% \noindent The syntax will be explained in detail in the next section and the full definitions of the helpers are
% provided in the supplementary material. For now, it is sufficient to know that there is some program that implements the
% reversible function of interest and that applying \Afun{reset} to 2 produces \verb|reversibleOr2| from the introduction.

% In principle, the normalised program can be produced following two strategies: (i) by repeatedly applying the rewrite
% rules of our calculus of reversible functions (explained in Sec.~\ref{sec:reversibletwo}), or (ii) in the case above by
% using a NbE process that evaluates the program to a permutation on a finite set of 8
% elements and reifies that permutation back to a program. The key idea of the NbE process is a systematic way to express
% permutations as sequences of adjacent swaps as illustrated in the following small example where the permutation on the
% left is compiled to the sequence of four adjacent transpositions on the right:

% \note{Motivation: There are two reversible circuits which describe the following permutation. They can be shown to be
%   equal using the 2-combinators.}

% \[
%   \begin{tikzpicture}
%     \begin{knot}[clip width=5]
%       \filldraw (0,5) circle (2pt) node[above] {0};
%       \filldraw (1,5) circle (2pt) node[above] {1};
%       \filldraw (2,5) circle (2pt) node[above] {2};
%       \filldraw (3,5) circle (2pt) node[above] {3};
%       \filldraw (4,5) circle (2pt) node[above] {4};
%       \filldraw (0,0) circle (2pt) node[below] {1};
%       \filldraw (1,0) circle (2pt) node[below] {4};
%       \filldraw (2,0) circle (2pt) node[below] {0};
%       \filldraw (3,0) circle (2pt) node[below] {3};
%       \filldraw (4,0) circle (2pt) node[below] {2};
%       \strand (0,5) .. controls (0.5,0.5) and (1.5,3.5) .. (2,0);
%       \strand (1,5) .. controls (0.75,0.5) and (0.25,3.5) .. (0,0);
%       \strand (2,5) .. controls (2.5,2.5) and (3.5,1.5) .. (4,0);
%       \strand (3,5) .. controls (4.5,2.5) and (4,1.5) .. (3,0);
%       \strand (4,5) .. controls (3.5,2.5) and (1.5,2.5) .. (1,0);
%       \flipcrossings{4,5};
%     \end{knot}
%   \end{tikzpicture}
% \]

% \paragraph*{Program equivalence.} The permutation above reveals another way to think about the desired program: it is a
% special addition circuit that keeps 0 and 4 fixed but otherwise adds 4 modulo 8 to its input. From this specification,
% one can use a standard synthesis algorithm for reversible circuits~\cite{10.1145/775832.775915} to generate the
% following program:

% \adder{}

% \noindent The \Afun{adder3} program looks nothing like the original \Afun{reset 2} program and yet they both have the
% same normal form thus establishing their equivalence. The reader can check that this circuit is the same as
% \verb|reversibleOr1| from the introduction.

% Now imagine we want to write the following reversible function:

% 0 -> 0
% 8 -> 8
% n -> n + 8 `mod` 16

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "main"
%%% fill-column: 120
%%% End:
