\section{Discussion \& Related Work}
\label{sec:discussion}

% In this paper, we \ldots

The main theme of our work is the semantic foundation of reversible languages. We prove that a programming language
presentation of reversible computing based on algebraic types matches---exactly---the categorified group-theoretic
semantics, thereby closing the circle on a complete Curry-Howard-Lambek correspondence for reversible languages.
Historically, the first such correspondence was between the $\lambda$-calculus, intuitionistic logic, and
cartesian-closed categories~\cite{curryCurryEssaysCombinatory1980}. For reversible languages, the Curry-Howard
correspondence was established by~\citet{sparksSuperstructuralReversibleLogic2014}, and the Lambek correspondence was
suggested by~\citet{caretteComputingSemiringsWeak2016} and~\citet{caretteEmbracingLawsPhysics2021}. In this work, we
have established this correspondence, as summarised in~\cref{fig:table-summary}. In the remainder of this section, we
discuss some broader related work.

\begin{figure}
    \begin{center}
        \begin{tabular}{|c|c|c|c|}
            \hline
            \rowcolor{lightgray} $\PiLang$ & $\bigsqcup_n \mathcal{B}\Sn $ & $\BFin$     & $\UFin$ \tabularnewline
            \hline
            Types                          & Natural numbers               & Finite sets & 0-cells \tabularnewline
            \hline
            1-combinators                  & Generators of $\Sn$           & Bijections  & 1-paths \tabularnewline
            \hline
            2-combinators                  & Relations of $\Sn$            & Homotopies  & 2-paths \tabularnewline
            \hline
        \end{tabular}
    \end{center}
    \caption{Summary of the established correspondences TODO: Move above}
    \label{fig:table-summary}
\end{figure}

% \begin{center}
%     \begin{tabular}{c c c}
%         \hline
%         Logic                              & Program                       & Algebra                     \\
%         \hline
%         Propositions                       & Types                         & Objects                     \\
%         \hline
%         Proofs                             & Terms                         & Morphisms                   \\
%         \hline
%         $\blank$                           & Equations                     & Homotopies                  \\
%         \hline
%         Intuitionistic propositional logic & Simply typed Lambda Calculus  & Cartesian Closed Categories \\
%         \hline
%         Superstructural Reversible logic   & Reversible Language $\PiLang$ & Symmetric Rig Groupoids     \\
%         \hline
%         Connectives                        & Type constructors             & Bifunctors                  \\
%         \hline
%         ?                                  & Type normalisation            & ?                           \\
%         \hline
%         ?                                  & Program normalisation         & ?                           \\
%         \hline
%         ?                                  & Soundness of 2-combinators    & ?                           \\
%     \end{tabular}
% \end{center}

% \begin{center}
%     \begin{tabular}{c c c}
%         \hline
%         Reversible Logic             & Reversible Programming                  & Algebra                  \\
%         \hline
%         Free commutative rig         & Free symmetric rig groupoid             & $\UFin$                  \\
%         \hline
%         Propositions                 & Types                                   & Objects                  \\
%         \hline
%         Entailment?                  & Reversible programs                     & Isomorphisms             \\
%         \hline
%         $\blank$                     & 2-combinators                           & Homotopies               \\
%         \hline
%         Conjunction?                 & $\times$                                & $\otimes$                \\
%         \hline
%         Disjunction?                 & $+$                                     & $\oplus$                 \\
%         \hline
%         $A \land B \vdash B \land A$ & $\swapt$                                & $\mathcal{B}_{A,B}$      \\
%         \hline
%         True proposition             & $\onet$                                 & $F_1$                    \\
%         \hline
%         Decidability                 & Program Synthesis                       & Reachability in a graph? \\
%         \hline
%         Soundness/Completeness       & Soundness/Completeness of 1-combinators & ?                        \\
%     \end{tabular}
% \end{center}

%%%%%%%%%%%%%%
\paragraph{Coherence and Rewriting}

Higher-order term-rewriting systems and word problems have a long history of being formalised in proof assistants like
{homotopy.io}, Agda, Coq and Lean~\cite{krausCoherenceWellFoundednessTaming2020}. As part of the proof of our main
result, we developed a rewriting system for the Coxeter relations for $\Sn$ to solve its word problem.
\citet{hiverCoqCombiCoxeterPresentation2021} describes an explicit algorithm for producing normal forms. It could
provide an alternative to our rewriting system. Other encodings of permutations as listed vectors, matrices, inductively
generated trees (Motzkin trees), Young diagrams, or string diagrams, proved either difficult to formalise in type theory
or difficult to relate directly to the primitive type isomorphisms of $\PiLang$. The automatic
\citet{knuthSimpleWordProblems1970} completion produced too many equations making proving correctness and termination
intractable.

Coherence theorems are famous problems in category theory, and Mac Lane's coherence
theorem~\cite{maclaneNaturalAssociativityCommutativity1963,joyalBraidedTensorCategories1993,gurskiInfiniteLoopSpaces2013}
for monoidal categories is a particular one. The use of rewriting and proof assistants to prove coherence theorems for
higher categorical structures has a long history,
see~\cite{forestCoherenceGrayCategories2018,beylinExtractingProofCoherence1996}.

%%%%%%%%%%%%%%
\paragraph{Computing with Univalence} In HoTT, univalence characterises the path type in the universe as equivalences of
types. The map $\term{idtoeqv} : A \id_{\UU} B \to A \eqv B$ can be easily constructed using path induction. The term
$\term{ua} : A \eqv B \to A \id_{\UU} B$, its computation rule
$\term{ua_\beta} : (e : A \eqv B) \to \term{idtoeqv}(\term{ua}(e)) \id e$, and its extensionality rule
$\term{ua_\eta} : (p : A \id_{\UU} B) \to p \id \term{ua}(\term{idtoeqv(p)})$ are generally added as postulates when
formalising in Agda. Together, $\term{ua}$ and $\term{ua}_\beta$ give the full univalence axiom
$(A \eqv B) \eqv (A \id_{\UU} B)$~\cite[Theorem 3.5]{ortonDecomposingUnivalenceAxiom2018}.
% Let's think of the $\PiLang$ combinators as describing the inhabitants of the identity type of finite types.
By giving a computable presentation for a univalent subuniverse, we are able to describe its path space syntactically
via a complete equational axiomatisation of the equivalences between types in the subuniverse. Univalent
typoids~\cite{petrakisUnivalentTypoids2019} are another way of axiomatising univalent subuniverses.

% By the property of being univalent, this subuniverse gives a model of the univalence axiom.
In the subuniverse of finite types, $\term{idtoeqv}$ corresponds to giving a denotation for a program (1-combinator),
which is easily done by induction. The $\term{ua}$ map corresponds to synthesising a program from an equivalence (which,
in general, is of course undecidable~\cite{krogmeierDecidableSynthesisPrograms2020}). In case of reversible boolean
circuits, it is decidable, as we have shown, but still far from trivial, which matches the need to assert the existence
of $\term{ua}$ without giving a constructive argument. Then, the computation rule $\term{ua_\beta}$ expresses the fact
that program synthesis is sound, while $\term{ua_\eta}$ corresponds to the soundness of the equational theory ($\PiLang$
2-combinators). Thus, our results suggest a new computational interpretation of the univalence principle, which provides
an intuition on why certain constructions are hard (or impossible in the general case). There are other, different
approaches to computing with univalence,
in~\cite{angiuliInternalizingRepresentationIndependence2021,tabareauMarriageUnivalenceParametricity2021}, and in Cubical
Type Theory\cite{angiuliComputationalSemanticsCartesianCubical2019,vezzosiCubicalAgdaDependently2019}.

% We could present a dependent type theory for the topos $\SetFin$, with an identity type for terms (generated by
% $\refl$), and one for types (generated by $\PiLang$ combinators). We can't talk about universes in $\SetFin$ since it
% doesn't have one, but we could show externally that it satisfies univalence.

% Univalent Fibrations were introduced by~\citet*{kapulkinUnivalenceSimplicialSets2018},
% to build a model of Voevodsky's \emph{univalence} principle in simplicial sets.
% \citet{christensenCharacterizationUnivalentFibrations2015} studied characterisations of univalent fibrations using the
% $\BAut$ construction. Univalent typoids~\cite{petrakisUnivalentTypoids2019a} are a different presentation of univalent
% subuniverses.

%%%%%%%%%%%%%%
% \paragraph{Univalent Fibrations}

% Coherence problems in type theory, coherence via Well-Foundedness.

% Formalised proofs of Mac Lane's coherence theorem.

% Applications of FSMG and history of the coherence theorems.

% Other proofs of coherence theorems, Joyal-Street.

% Pi has other extensions (fractional/negative/recursive types).
% What are the free X monoidal structures they're describing?

% Using our presentation of $S_{n}$, we can construct the Eilenberg-Maclane space (using a HIT) $K(S_{n},1)$. Then, it
% should be true that $\UFin \eqv \sqcup_{n:\Nat} K(S_{n},1)$. This is future work.

% Other applications of symmetric groups.

% Actions of symmetric groups, permutation groupoids.

%%%%%%%%%%%%%%
\paragraph{Algebraic Theories} In universal algebra, algebraic theories are used to describe structures such as groups
or rings. A specific group or ring is a model of the appropriate algebraic theory. Algebraic theories are usually
\emph{presented} in terms of logical syntax, that is, as first-order theories whose signatures allow only functional
symbols, and whose axioms are universally quantified equations. In his seminal thesis,
\citet{lawvereFUNCTORIALSEMANTICSALGEBRAIC1963} defined a presentation-free categorical notion of universal algebraic
structure, called a Lawvere theory. Programming Languages, such as the $\lambda$-calculus, can be viewed as algebraic
structures with variable-binding operators, which can be formalised using second-order algebraic
theories~\cite{fioreSecondOrderAlgebraicTheories2010}, or algebraic theories with closed
structure~\cite{hylandClassicalLambdaCalculus2017}, called $\lambda$-theories, making the $\lambda$-calculus the
presentation of the initial $\lambda$-theory $\Lambda$. Our family of reversible languages $\PiLang$ have been presented
as first-order algebraic
2-theories~\cite{cohenCoherenceRewriting2theories2009,bekeCategorificationTermRewriting2011,yanofskySyntaxCoherence2000},
which are a categorification of algebraic theories. The types $\zerot$ and $\onet$ are nullary function symbols, the
type formers $+$ and $\times$ are binary function symbols, the 1-combinators are invertible reduction rules, and the
2-combinators are equations or coherence diagrams of compositions of reduction rules. Just like models of Lawvere
theories are given by algebras of (finitary) monads on $\SetCat$, models of 2-theories are given by algebras of 2-monads
on $\CatCat$. Our development is related to the free symmetric monoidal completion 2-monad.

%%%%%%%%%%%%%%
\paragraph{Free Symmetric Monoidal Category} The free symmetric monoidal category has been used to study
concurrency~\cite{hylandSymmetricMonoidalSketches2004}, Petri nets~\cite{baezCategoriesNets2021}, combinatorial
structures~\cite{fioreCartesianClosedBicategory2008}, quantum mechanics~\cite{abramskyAbstractScalarsLoops2005}, and
bicategorical models of (differential) linear logic~\cite{melliesTemplateGamesDifferential2019}. The forgetful functor
from $\SymMonCat$, the 2-category of (small) symmetric monoidal categories, strong symmetric monoidal functors, and
monoidal natural transformations, to the 2-category $\CatCat$, has a left adjoint giving the free symmetric monoidal
category $\FSM[\CCat{C}]$ on a category $\CCat{C}$. This is a 2-monad on
$\CatCat$~\cite{blackwellTwodimensionalMonadTheory1989}, whose algebras are (strict) symmetric monoidal categories. Its
construction is known in the literature~\cite{abramskyAbstractScalarsLoops2005}.  Concretely, the objects of
$\FSM[\CCat{C}]$ are given by lists of objects of $\CCat{C}$, that is, a pair $(n:\Nat, A:[n] \to \CCat{C}_{0})$;
morphisms between $(n,A)$ and $(n,B)$ are pairs $(\pi,\lambda)$ where $\pi$ is a permutation of $[n]$, and
$\lambda_{i} : A_{i} \to B_{\pi(i)}$ for $1 \leq i \leq n$. Abstractly, this is given by the Grothendieck construction
$\int F$ of the functor $F : \BFin \to \CatCat$ from the groupoid of finite sets and bijections to $\CatCat$, assigning
each natural number $n$ to the $n$-power $C^{n}$ of $C$, and each permutation on $[n]$ inducing an endofunctor on
$C^{n}$ by action. The groupoid $\BFin$ is the free symmetric monoidal category (groupoid) on one generator, $\FSM[\unit]$.

Coherence and normalisation problems for monoids in constructive type theory using coherence for monoidal categories
were studied by \citet{beylinExtractingProofCoherence1996}. In HoTT, coherence for the free monoidal groupoid over a
groupoid and the proof of its universal property has been considered
by~\citet{piceghelloCoherenceMonoidalGroupoids2020}. Free commutative monoids in type theory have been studied by
\citet{gylterudMultisetsTypeTheory2020}, and in HoTT by
\citet*{choudhuryFinitemultisetConstructionHoTT2019,choudhuryFreeCommutativeMonoids2021}. The free symmetric monoidal
groupoid $\FSM[A]$ over a groupoid $A$ can be given by $\dsum*{X:\UFin}{A^{X}}$, or it can be presented as an algebraic
2-theory using 1-HITs. These HITs and the proof of their universal property have been considered by
\citet*{piceghelloCoherenceSymmetricMonoidal2019,choudhuryFinitemultisetConstructionHoTT2019}. The proof of the
universal property of $\FSM$ is asserted by appealing to Mac Lane's coherence theorem for symmetric monoidal categories,
and using the fact that the finite symmetric group $\Sn$ encodes the group of permutations on a finite set. The existence of
the proof is folklore. We have produced a proof and formalised it in constructive type theory. A stronger universal
property that $\BFin$ is biinitial in $\term{RigCat}$, is in~\cite{elguetaGroupoidFiniteSets2021}.

%%%%%%%%%%%%%%
\paragraph{Reversible Programming Languages} The practice of programming languages is replete with \emph{ad hoc}
instances of reversible computations: database transactions, mechanisms for data provenance, checkpoints, stack and
exception traces, logs, backups, rollback recoveries, version control systems, reverse engineering, software
transactional memories, continuations, backtracking search, and multiple-level undo features in commercial applications.
In the early nineties, \citet{bakerNREVERSALFortuneThermodynamics1992,bakerLivelyLinearLisp1992} argued for a
systematic, first-class, treatment of reversibility. But intensive research in full-fledged reversible models of
computations and reversible programming languages was only sparked by the discovery of deep connections between physics
and computation~\cite{landauerIrreversibilityHeatGeneration1961, peresReversibleLogicQuantum1985,
    toffoliReversibleComputing1980, bennettFundamentalPhysicalLimits1985, frankReversibilityEfficientComputing1999,
    heyFeynmanComputationExploring1999, fredkinConservativeLogic1982}, and by the potential for efficient quantum
computation~\cite{feynmanSimulatingPhysicsComputers1982}. The early developments of reversible programming languages
started with a conventional programming language, e.g., an extended $\lambda$-calculus, and either (i) extended the
language with a history mechanism~\cite{vantonderLambdaCalculusQuantum2004,klugeReversibleSECD2000,
    huelsbergenLogicallyReversibleEvaluator1996,danosReversibleCommunicatingSystems2004}, or (ii) imposed constraints on the
control flow constructs to make them reversible~\cite{yokoyamaReversibleProgrammingLanguage2007}. More modern approaches
recognize that reversible programming languages require a fresh approach and should be designed from first principles
without the detour via conventional irreversible languages~\cite{yokoyamaPrinciplesReversibleProgramming2008,
    muInjectiveLanguageReversible2004, abramskyStructuralApproachReversible2005, dipierroReversibleCombinatoryLogic2006}.
The version of $\PiLang$ studied in this paper is restricted to finite types and terminating total computations. It
would be interesting to understand which versions of free monoidal structures correspond to extensions of $\Pi$ with
recursive types~\cite{jamesInformationEffects2012,bowmanDaggerTracedSymmetric2011}, or negative and fractional
types~\cite*{chenFractionalTypes2020,chenComputationalInterpretationCompact2021}.

%%%%%%%%%%%%%%
\paragraph{Permutations} Finding formal systems for expressing various flavors of computable functions has been a major
focus of logic and computer science since its inception. Permutations, being at the core of reversible computing, are an
interesting class of functions, for which there are few formal systems. The system we have developed brings in all the
associated benefits of syntactic calculi, notably, their calculational flavor. Instead of comparing two reversible
programs by extensional equality of the underlying bijective functions, a calculus offers more nuanced techniques that
can enforce additional intensional constraints on the desired equality relation.


% additional constraints on the
% process of transforming one program into another, and no way of inspecting what
% transformation occurred. We can imagine a practical situation in which reversible
% circuits admit one kind of optimization FPGA?, but do not admit another,
% even though they are equivalent in the extensional sense - or maybe one of these
% transformations is cheaper than another, or maybe it is important to know which
% transformation did occur for the producer(?) to focus their resources of
% improving this kind of transformations. By comparing the circuits extensionally,
% the proof object = the path from one into the other - does not have any
% structure,  it is just a check that the values match.

% On the other hand, even though in general, the equality of circuits requires
% exponential time jk{triple check}, the proof object can be still very small.
% This creates structure that can possibly be exploited in a heuristic way.
% Additionally, if the goal is to convince third-party that two circuits are
% the same, we can just present the proof instead of showing the equality directly
% - for example, by choosing a particularly short one.

% Taking all this into account, it is clear that we must seek a syntactic way of
% computing the meaning of the circuit, instead of just directly evaluating it to
% $\Aut[\Fin[n]]$ - since when we go back and quote the permutation as a circuit
% (in a normal form), there was no "trace" left to see what transformation (what
% sequence of 2-paths) maps the old one into the new one.

% We are additionally experimenting with user annotations that can guide
% the search. Each level-2 combinator can be annotated with various
% ``cost'' annotations indicating whether it reduces the number of
% gates, reduces the number of choice points, or other cost
% functions. Then one can ask for a proof that takes no more than a
% certain number of steps or a proof that does not create more than a
% certain number of additional wires etc. We illustrate these ideas by
% defining a simple cost function and using it to annotate level-2
% combinators.

% We define the \emph{length} $L(c)$ of a composite circuit $c$ as
% follows: the length of a sequential composition of circuits is the sum
% of the lengths of the subcircuits $L(f \odot g) = L(f) + L(g)$; and
% the length of choice or parallel composition is the maximum of either
% branch $L(f \oplus g) = L(f \otimes g) = \max(L(f),L(g))$. For
% primitive gates, the length needs to be postulated to reflect the
% ``length'' of the computation involved in applying that primitive. As
% examples, consider the following two level-2 combinators:

% % \begin{code}
% % linv◎l'  :  {t₁ t₂ : U} {c : t₁ ⟷ t₂} → (c ◎ ! c) ⇔ id⟷
% % idl◎l'   :  {t₁ t₂ : U} {c : t₁ ⟷ t₂} → (id⟷ ◎ c) ⇔ c
% % \end{code}
% % \AgdaHide{
% % \begin{code}
% % linv◎l'  = ?
% % idl◎l'   = ?
% % \end{code}
% % }

% \noindent Assuming that $\idc$ takes a unit length of computation, the
% first can be annotated with $L(c)*2 \isotwo 1$ and the second with $L(c)+1 \isotwo
%     L(c)$ indicating that the first combinator reduces the length of the
% circuit from twice the length of $c$ to 1 and the second combinator
% reduces the length of the circuit by 1. Such annotations can then be
% used to constrain or guide the search for transformations between
% circuits.

% \todo{Why is this better than evaluating the permutation and checking each bit?}
% \todo{Why care about an equational theory? Compilers, optimisation.}

% %%%%%%%%%%%%%%
% \paragraph{Computational group theory} Coxeter relations are used in computational group theory to study XXX problems.

% \todo{but computation is usually done by using Coxeter matrices~\cite{davisGeometryTopologyCoxeter2008}.}

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "main"
%%% fill-column: 120
%%% End:
