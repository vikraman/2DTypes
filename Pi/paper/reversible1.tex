\section{A Reversible Programming Language}
%% ~3 pages
\label{sec:pi}
\label{sec:reversibleone}
\label{sec:reversibletwo}
\label{langeqeq}
\label{sec:informal}

The circuit model of reversible computation discussed in the previous section is a useful abstraction close to the
hardware platform. However, since its main data abstraction is a \emph{sequence of wires}, it only provides an
``assembly-level'' programming abstraction (e.g., \verb|qasm|). As motivated by \citet{LAFONT2003257}, a mathematical
model based on permutations of finite sets provides a richer algebraic structure, using which we describe a reversible
programming language in this section.

%%%%%%%%%%%%%%%%%
\subsection{The $\Pi$ Family of Languages}
\label{sec:langRev-examples}
\label{examples}

In reversible boolean circuits, the number of input bits matches the number of output bits. Thus, a key insight for a
programming language of reversible circuits is to ensure that each primitive operation preserves the number of bits,
which is just a natural number. The algebraic structure of natural numbers as the free commutative semiring (or,
commutative rig), with $(0,+)$ for addition, and $(1,\times)$ for multiplication then provides sequential, vertical, and
horizontal circuit composition.

These commutative rig identities can be used to design a logic for reversible
programming~\cite*{jamesInformationEffects2012,sparksSuperstructuralReversibleLogic2014}. To interpret natural number
identities as reversible programs, the logic needs to be equipped with values and types, and a notion of operational
semantics and contextual equivalence, giving a computational interpretation of the commutative rig
structure~\cite{jamesInformationEffects2012}. On the semantic side, the natural space to consider is the
groupoidification of a commutative rig, that is, a symmetric rig groupoid.

Putting these ideas together, the programming language $\PiLang$, whose syntax is given below, embodies the
computational content of isomorphisms of finite types, or permutations.

% In programming parlance, as shown in~\cref{fig:pi-terms}, each primitive algebraic identity of commutative rigs becomes
% a reversible combinator in the programming language and the algebraic closure operators become composition operators in
% the programming language. Once equipped with a notion of values and types, we get the following syntactic presentation
% of a programming language for permutations~\cite{James:2012:IE:2103656.2103667,Carette2016}:

% A specialised language for programming with permutations on finite sets can be built using ideas going back to Kelly,
% Laplaza, and Mac Lane~\cite{laplaza72,kelly74,KELLY197197} that the commutative semiring (also known as the commutative
% rig) of natural numbers exactly characterizes permutations on finite sets. In programming parlance, as shown in
% Fig.~\ref{fig:pi-terms}, each primitive algebraic identity of commutative rigs becomes a constant in the programming
% language and the algebraic closure operators become composition operators in the programming language. Once equipped
% with a notion of values and types, we get the following syntactic presentation of a programming language for
% permutations~\cite{James:2012:IE:2103656.2103667,Carette2016}:

% The practice of programming languages is replete with \emph{ad hoc} instances of reversible computations: database
% transactions, mechanisms for data provenance, checkpoints, stack and exception traces, logs, backups, rollback
% recoveries, version control systems, reverse engineering, software transactional memories, continuations, backtracking
% search, and multiple-level undo features in commercial applications. In the early nineties,
% \citet{Baker:1992:LLL,Baker:1992:NFT} argued for a systematic, first-class, treatment of reversibility. But intensive
% research in full-fledged reversible models of computations and reversible programming languages was only sparked by the
% discovery of deep connections between physics and
% computation~\cite{Landauer:1961,PhysRevA.32.3266,Toffoli:1980,bennett1985fundamental,Frank:1999:REC:930275, Hey:1999:FCE:304763,fredkin1982conservative}, and by the
% potential for efficient quantum computation~\cite{springerlink:10.1007/BF02650179}.

% The early developments of reversible programming languages started
% with a conventional programming language, e.g., an extended
% $\lambda$-calculus, and either:
% \begin{enumerate}
%   \item extended the language with a history
%         mechanism~\cite{vanTonder:2004,Kluge:1999:SEMCD,lorenz,danos2004reversible}, or
%   \item imposed constraints on the control flow constructs to make them
%         reversible~\cite{Yokoyama:2007:RPL:1244381.1244404}.
% \end{enumerate}
% More foundational approaches recognize that reversible programming languages require a fresh approach and should be
% designed from first principles without the detour via conventional irreversible
% languages~\cite{Yokoyama:2008:PRP,Mu:2004:ILRC,abramsky2005structural,DiPierro:2006:RCL:1166042.1166047,
%   rc2011, James:2012:IE:2103656.2103667, Carette2016}.

\medskip

{\scalebox{\scalef}{$%
      \begin{array}{lrcl}
        \textit{Value types}   & A,B,C,D & ::= & \zerot \alt \onet \alt A+B \alt A\times B        \\
        \textit{Values}        & v,w,x,y & ::= & \Acon{tt} \alt \inlv{v} \alt \inrv{v} \alt (v,w) \\
        \textit{Program types} &         &     & A \isoone B                                      \\
        \textit{Programs}      & c       & ::= & (\textrm{See~\cref{fig:pi-terms}})
      \end{array}$}}

\begin{figure}
  {\scalebox{\scalef}{$%
        %%\noindent\begin{minipage}{.7\linewidth}
        \begin{array}{rrcll}
          \idc :     & A                     & \isoone & A                            & : \idc      \\ [1.5ex]
          \identlp : & \zerot + A            & \isoone & A                            & : \identrp  \\
          \swapp :   & A + B                 & \isoone & B + A                        & : \swapp    \\
          \assoclp : & A + (B + C)           & \isoone & (A + B) + C                  & : \assocrp  \\ [1.5ex]
          \identlt : & \onet \times A        & \isoone & A                            & : \identrt  \\
          \swapt :   & A \times B            & \isoone & B \times A                   & : \swapt    \\
          \assoclt : & A \times (B \times C) & \isoone & (A \times B) \times C        & : \assocrt  \\ [1.5ex]
          \absorbr : & ~ \zerot \times A     & \isoone & \zerot ~                     & : \factorzl \\
          \dist :    & ~ (A + B) \times C    & \isoone & (A \times C) + (B \times C)~ & : \factor
        \end{array}$}}

  \medskip

  {\scalebox{\scalef}{%
      \Rule{}
      {\jdg{}{}{c_1 : A \isoone B} \quad \vdash c_2 : B \isoone C}
      {\jdg{}{}{c_1 \circledcirc c_2 : A \isoone C}}
      {}

      \Rule{}
      {\jdg{}{}{c_1 : A \isoone B} \quad \vdash c_2 : C \isoone D}
      {\jdg{}{}{c_1 \oplus c_2 : A + C \isoone B + D}}
      {}

      \Rule{}
      {\jdg{}{}{c_1 : A \isoone B} \quad \vdash c_2 : C \isoone D}
      {\jdg{}{}{c_1 \otimes c_2 : A \times C \isoone B \times D}}
      {}
    }}
  \caption{$\Pi$-terms, combinators, and their types.}
  \label{fig:pi-terms}
\end{figure}

\medskip\noindent The language of types is built from the empty type ($\zerot$), the unit type
($\onet$) containing just one value~$\Acon{tt}$, the sum type ($+$) containing values of the form $\inlv{v}$ and
$\inrv{v}$, and the product type ($\times$) containing pairs of values $(v_1,v_2)$.
%
% A natural candidate for a semantic foundation for reversible programming languages is the notion of type
% isomorphism. Indeed, the type isomorphisms among finite types are sound and complete for all permutations on finite
% types~\cite{Fiore:2004,fiore-remarks} and hence they are \emph{complete} for expressing reversible combinational
% circuits~\cite{fredkin1982conservative, James:2012:IE:2103656.2103667,Toffoli:1980} and the extension with recursive
% types and trace operators~\cite{Hasegawa:1997:RCS:645893.671607} is a Turing-complete reversible
% language~\cite{James:2012:IE:2103656.2103667,rc2011}.

To see how this language expresses reversible circuits, we present a few examples using the Agda embedding of the
language~\cite{choudhuryArtifactSymmetriesReversible2021}. First it is possible to directly mimic the
\verb|qasm|-perspective by defining types that describe sequences of booleans ($\mathbb{2}^{n}$). We use the type
$\mathbb{2} = \onet + \onet$ to represent booleans with $\inlv{\Acon{tt}}$ representing \textsf{true}, and
$\inrv{\Acon{tt}}$ representing $\textsf{false}$. Boolean negation (the \verb|x|-gate) is straightforward to define
using the primitive combinator $\swapp$. We can represent $n$-bit words using an n-ary product of boolean values, thus
the type $\mathbb{2} \times (\mathbb{2} \times \mathbb{2})$ (abbreviated $\mathbb{B}~3$) corresponds to a collection of
wires that can transmit three bits.
%
% For example, we can express a 3-bit word reversal operation as follows:
% $\Afun{reverse} : \mathbb{B}~3 \iso \mathbb{B}~3$
% $\Afun{reverse} = \swapt \circledcirc (\swapt  \otimes  \idc)~ \circledcirc \assocrt$
% \noindent The manual trace of $\Afun{reverse}$ below confirms that it indeed reverses the three bits:
% \[\begin{array}{rlr}
%                          & (v_1, (v_2, v_3)) \\
%     \swapt               & ((v_2, v_3), v_1) \\
%     \swapt \otimes  \idc & ((v_3, v_2), v_1) \\
%     \assocrt             & (v_3, (v_2, v_1)) \\
%   \end{array}\]
%subcode source isomorphisms.tex:979
%
To express the \verb|cx| and \verb|ccx| gates, we need to encode a notion of conditional expression. Such conditionals
turn out to be expressible using the distributivity and factoring identities of rigs as shown below:
\medskip
\cif{}

\noindent The input value of type $\mathbb{2} \times A$ is processed by the distribute operator \ensuremath{\dist},
which converts it into a value of type $(\onet \times A) + (\onet \times A)$. In the left branch, which corresponds to
the case when the boolean is \textsf{true}, the combinator~\ensuremath{c_1} is applied to the value of
type~\ensuremath{A}. The right branch, which corresponds to the boolean being \textsf{false}, passes the value of type $A$
through the combinator \ensuremath{c_2}.  The inverse of \ensuremath{\dist}, namely \ensuremath{\factor} is applied to
get the final result. Using this conditional operator, \verb|cx| is defined as $\Afun{cif}~\verb|x|~\idc$ and
\verb|ccx| is defined as $\Afun{cif}~\verb|cx|~\idc$. With these conventions, the first circuit in the previous section
is transcribed as follows:
\medskip
\adder{}

\addertwo{}

\noindent where we clearly see the sequences of the three operations \verb|ccx|, \verb|cx|, and \verb|cx| but, instead
of using the indices in the sequence of wires to identify the relevant parameters, here we use structural isomorphisms
to re-shuffle the types. We only show one of these re-shuffling isomorphisms and elide the others. For the second
circuit, instead of transcribing it directly, we express it using $\Afun{cif}$.
\medskip
\resettwo{}

\noindent
Like the original circuit, we examine the bit at index 1 (corresponding to the component $B$ in a tuple $(A,(B,C))$): if
the bit is true, we perform an \verb|x| operation on component $A$, and otherwise we perform a \verb|cx| operation on
$(C,A)$. The two uses of \verb|x| gates in the circuit are now unnecessary as they were only needed to encode a two-way
conditional expression using a sequence of one-way conditional expressions (the only ones available in the linear
circuit model).

All of this is only half the story, however. A sound semantics for $\PiLang$ using weak rig
groupoids was established by~\citet{caretteComputingSemiringsWeak2016}, and conjectured to be complete. For this
semantics, \emph{coherence conditions} for symmetric rig groupoids that identify different syntactic representations of the same
permutation~\cite{laplaza72,caretteComputingSemiringsWeak2016}, were collected  in a
second level of $\PiLang$ syntax as level-2 combinators.  Each level-2 combinator is of the form $c_1 \isotwo c_2$ for appropriate
$c_1$ and $c_2$ of the same level-1 type $A \isoone B$ and asserts that $c_1$ and $c_2$ denote the same bijection. For
example, we have the following level-2 combinators dealing with associativity:
\medskip
\leveltwoblockone{}

\noindent The full set of level-2 combinators is large; the remaining combinators are listed in~\cref{app:leveltwo}.

\begin{toappendix}
  \subsection{2-combinators}

  The additional level-2 combinators:

  \label{app:leveltwo}

  \medskip
  \leveltwoblocktwo{}
\end{toappendix}

% and that impose various coherence conditions on the level-1 combinators. In the remainder of this section, we show how
% to use a subset of these level-2 combinators to show the equivalence of \Afun{reversibleOr1} and \Afun{reversibleOr2}.

% \medskip

% \orequiv{}

% \note{This section should explain the main technical parts of the paper
%   informally, without using any technology. Use an example, such as, a
%   reversible language with $\leq 5$ bits, and examples of permutations and
%   transpositions, and when they're equal.}

%%%%%%%%%
\subsection{Semantics}
\label{subsec:denotational}

\noindent Below we present a simple denotational semantics for our language, using finite types and type isomorphisms.
Each $\PiLang$ type $A$ is mapped to a (finite) set $\denot{A}$ and each combinator $c : A \isoone B$ is mapped to a
(bijective) function $\denot{A} \to \denot{B}$. We describe this semantics by writing an interpreter in Agda. First, we
state the semantics for types, where $\bot$ is the empty set, $\top$ is the singleton set, $\sqcup$ is the disjoint
union of sets, and $\times$ is the cartesian product of sets.

% semantic map that dually serves as an operational semantics and a denotational semantics. As an operational semantics,
% As a denotational semantics, each $\PiLang$ type $A$ is mapped to a finite set $\denot{A}$ and each combinator $c : A
% \isoone B$ is mapped to bijection between $\denot{A} \to \denot{B}$.

\begin{center}
  {\scalebox{\scalef}{$%
        \begin{array}{rcl}
          \denot{\zerot}     & = & \bot                       \\
          \denot{\onet}      & = & \top                       \\
          \denot{A + B}      & = & \denot{A} \sqcup \denot{B} \\
          \denot{A \times B} & = & \denot{A} \times \denot{B}
        \end{array}$}}
\end{center}

For combinators, we show explicitly how values reduce along each combinator, similar to a big-step operational
semantics~\cite{chenComputationalInterpretationCompact2021,theseus}.

% The semantics of a combinator $c : A \isoone B$ is a (bijective) function mapping $\denot{A}$ to $\denot{B}$:

\begin{center}
\begin{tabular}[t]{c @{\hspace{5em}} c}
  {\scalebox{\scalef}{
      \begin{tabular}[t]{>{$}r<{$} @{\hspace{4pt}} >{$}l<{$} >{$}c<{$} >{$}l<{$}}
        \denotbox{\identlp} & (\inl{v})         & = & v               \\
        \denotbox{\identrp} & v                 & = & \inl{v}         \\
        \denotbox{\swapp}   & (\inl{v})         & = & \inr{v}         \\
        \denotbox{\swapp}   & (\inr{v})         & = & \inl{v}         \\
        \denotbox{\assoclp} & (\inl{v})         & = & \inl{(\inl{v})} \\
        \denotbox{\assoclp} & (\inr{(\inl{v})}) & = & \inl{(\inr{v})} \\
        \denotbox{\assoclp} & (\inr{(\inr{v})}) & = & \inr{v}         \\
        \denotbox{\assocrp} & (\inl{(\inl{v})}) & = & \inl{v}         \\
        \denotbox{\assocrp} & (\inl{(\inr{v})}) & = & \inr{(\inl{v})} \\
        \denotbox{\assocrp} & (\inr{v})         & = & \inr{(\inr{v})}
      \end{tabular}}}
  &
  {\scalebox{\scalef}{
      \begin{tabular}[t]{>{$}r<{$} @{\hspace{4pt}} >{$}l<{$} >{$}c<{$} >{$}l<{$}}
        \denotbox{\identlt} & (\ttt , v)          & = & v                   \\
        \denotbox{\identrt} & v                   & = & (\ttt , v)          \\
        \denotbox{\swapt}   & (v_1 , v_2)         & = & (v_2 , v_1)         \\
        \denotbox{\assoclt} & (v_1 , (v_2 , v_3)) & = & ((v_1 , v_2) , v_3) \\
        \denotbox{\assocrt} & ((v_1 , v_2) , v_3) & = & (v_1 , (v_2 , v_3)) \\
        \denotbox{\dist}    & (\inl{v_1} , v_3)   & = & \inl{(v_1 , v_3)}   \\
        \denotbox{\dist}    & (\inr{v_2 , v_3})   & = & \inr{(v_2 , v_3)}   \\
        \denotbox{\factor}  & (\inl{(v_1 , v_3)}) & = & (\inl{v_1} , v_3)   \\
        \denotbox{\factor}  & (\inr{(v_2 , v_3)}) & = & (\inr{v_2} , v_3)   \\
        \denotbox{\idc}     & v                   & = & v
      \end{tabular}}}
\end{tabular}
\end{center}

\begin{center}
  {\scalebox{\scalef}{
      \begin{tabular}[t]{>{$}r<{$} @{\hspace{4pt}} >{$}l<{$} >{$}c<{$} >{$}l<{$}}
        \denotbox{(c_1 \circledcirc c_2)} & v           & = & \denot{c_2} (\denot{c_1}~v)         \\
        \denotbox{(c_1 \oplus c_2)}       & (\inl{v})   & = & \inl{(\denot{c_1}~v)}               \\
        \denotbox{(c_1 \oplus c_2)}       & (\inr{v})   & = & \inr{(\denot{c_2}~v)}               \\
        \denotbox{(c_1 \otimes c_2)}      & (v_1 , v_2) & = & (\denot{c_1}~v_1 , \denot{c_2}~v_2)
      \end{tabular}}}
\end{center}

% \begingroup
% \allowdisplaybreaks
% \begin{align*}
% \end{align*}
% \endgroup

% \begin{center}
% \begin{tikzpicture}[scale=0.7,every node/.style={scale=0.8}]
%   \draw[>=latex,<->,double,red,thick] (2.25,-1.2) -- (2.25,-2.9) ;
%   \draw[fill] (-2,-1.5) circle [radius=0.025];
%   \node[below] at (-2.1,-1.5) {$A$};
%   \node[below] at (-2.1,-1.9) {$+$};
%   \draw[fill] (-2,-2.5) circle [radius=0.025];
%   \node[below] at (-2.1,-2.5) {$B$};

%   \draw[fill] (6.5,-1.5) circle [radius=0.025];
%   \node[below] at (6.7,-1.5) {$C$};
%   \node[below] at (6.7,-1.9) {$+$};
%   \draw[fill] (6.5,-2.5) circle [radius=0.025];
%   \node[below] at (6.7,-2.5) {$D$};

%   \draw[<-] (-2,-1.5) to[bend left] (1,0.5) ;
%   \draw[<-] (-2,-2.5) to[bend left] (1,-0.5) ;
%   \draw[->] (3.5,0.5) to[bend left] (6.5,-1.45) ;
%   \draw[->] (3.5,-0.5) to[bend left] (6.5,-2.45) ;

%   \draw[<-] (-2,-1.5) to[bend right] (1,-3.5) ;
%   \draw[<-] (-2,-2.5) to[bend right] (1,-4.5) ;
%   \draw[->] (3.5,-3.5) to[bend right] (6.5,-1.55) ;
%   \draw[->] (3.5,-4.5) to[bend right] (6.5,-2.55) ;


%   \draw     (2,0.5)  -- (2.5,0.5)  ;
%   \draw     (2,-0.5) -- (2.5,-0.5) ;

%   \draw     (2.5,0.5)  -- (3.5,-0.5)  ;
%   \draw     (2.5,-0.5) -- (3.5,0.5) ;

%   \draw     (1,-3.5)  -- (2,-4.5)    ;
%   \draw     (1,-4.5) -- (2,-3.5)   ;

%   \draw     (2,-3.5)  -- (2.5,-3.5)    ;
%   \draw     (2,-4.5) -- (2.5,-4.5)   ;

%   \path (1.5,0.5) node (tc1) [func] {$c_1$};
%   \path (1.5,-0.5) node (tc2) [func] {$c_2$};
%   \path (3,-4.5) node (bc1) [func] {$c_1$};
%   \path (3,-3.5) node (bc2) [func] {$c_2$};
% \end{tikzpicture}
% \end{center}
% The top path is the $\Pi$ program $(c_1~\oplus~c_2)~\odot~\swapp$ which acts on the type $A$ by $c_1$, acts on the type
% $B$ by $c_2$, and acts on the resulting value by a twist that exchanges the two injections into the sum type. The bottom
% path performs the twist first and then acts on the type $A$ by $c_1$ and on the type $B$ by $c_2$ as before. One could
% imagine the paths are physical \emph{elastic} wires in $3$ space, where the programs $c_1$ and $c_2$ as arbitrary
% deformations on these wires, and the twists do not touch but are in fact well-separated. Then, holding the points $A$,
% $B$, $C$, and $D$ fixed, it is possible to imagine sliding $c_1$ and $c_2$ from the top wire rightward past the twist,
% and then using the elasticity of the wires, pull the twist back to line up with that of the bottom --- thus making both
% parts of the diagram identical.  Each of these moves can be undone (reversed), and doing so would take the bottom part
% of the diagram into the top part.  In other words, there exists an equivalence of the program
% $(c_1~\oplus~c_2)~\odot~\swapp$ to the program $\swapp \odot (c_2~\oplus~c_1)$. We can also show that this means that,
% as permutations, $(c_1~\oplus~c_2)~\odot~\swapp$ and $\swapp \odot (c_2~\oplus~c_1)$ are equal. And, of course, not all
% programs between the same types can be deformed into one another. The simplest example of inequivalent deformations are
% the two automorphisms of $1+1$, namely $\idc$ and $\swapp$.

% The denotational semantics can be used to evaluate programs and to check equivalence of programs. For example, it is
% straightforward to verify that $\denot{(c_1~\oplus~c_2)~\circledcirc~\swapp} = \denot{\swapp \circledcirc (c_2~\oplus~c_1)}$. A
% slightly more involved example are the following two programs:

% \rotate{}

% \noindent The first program performs the following sequence of transformations:
% \[
%   \Tree [ {\small a} [ {\small b} {\small c} ] ] ~\to~
%   \Tree [ [ {\small a} {\small b} ] {\small c} ] ~\to~
%   \Tree [ {\small c} [ {\small a} {\small b} ] ] ~\to~
%   \Tree [ {\small c} [ {\small b} {\small a} ] ] ~.
% \]
% \noindent
% while the second evaluates as follows:
% \[
%   \Tree [ {\small a} [ {\small b} {\small c} ] ] ~\to~
%   \Tree [ {\small a} [ {\small c} {\small b} ] ] ~\to~
%   \Tree [ [ {\small a} {\small c} ] {\small b} ] ~\to~
%   \Tree [ [ {\small c} {\small a} ] {\small b} ] ~\to~
%   \Tree [ {\small c} [ {\small a} {\small b} ] ] ~\to~
%   \Tree [ {\small c} [ {\small b} {\small a} ] ] ~.
% \]

% The semantics above can be packaged in the category of finite sets and functions, $\SetFin$, which is the category
% freely generated by finite coproduct completion of the terminal category. Objects of $\SetFin$ can be identified with
% sets of fixed cardinality, that is, $\Fin[n] \defeq \Set{0,1,\ldots,n-1}$. $\SetFin$ has finite coproducts and products,
% which lets us interpret the types of $\PiLang$. Combinators are interpreted as morphisms in $\SetFin$, but we have to
% restrict to invertible morphisms, that is, isomorphisms. This gives the \emph{groupoid} of finite sets and bijections,
% $\BFin \defeq \mathsf{core}(\SetFin)$. The isomorphisms satisfied by coproducts and products in $\SetFin$ lift to
% $\BFin$, but they're no longer categorical coproducts and products. They give two symmetric monoidal tensor products on
% $\BFin$, the additive and multiplicative ones, with the multiplicative tensor distributing over the additive tensor.

% \note{change thm:
%   1. Each function is a bijection. 2. If there is a 2-combinator, the denotations of the 1-combinators are equal
% }

\begin{theoremrep}\label{thm:semone}
  The semantics is sound in the following sense:
  \begin{itemize}
    \item For every level-1 combinator $c : A \isoone B$, we have a bijection $\denot{c}$ between $\denot{A}$ and $\denot{B}$.
    \item For every pair of combinators $c_1$ and $c_2$ of the same type $A \isoone B$, if there exists a level-2
          combinator $\alpha : c_1 \isotwo c_2$, then $\denot{c_1} = \denot{c_2}$, using extensional equivalence of
          functions.
  \end{itemize}
\end{theoremrep}
\begin{proof}
  For every primitive combinator $c$ listed on one side of~\cref{fig:pi-terms}, let $!c$ be the combinator listed on
  the other side. Thus $! \assoclp$ is $\assocrp$ and $! \swapp$ is $\swapp$ itself. Then we have that $\denot{c}$ and
  $\denot{!c}$ form an equivalence. For the level-2 combinator \Afun{idr◎l}, we check
  $\denot{\AgdaBound{c}~\AgdaOperator{\AgdaInductiveConstructor{◎}}~\AgdaInductiveConstructor{id⟷₁}}
    = \mathit{id} \circ \denot{c} = \denot{c}$. The other cases are only slightly more involved calculations.
\end{proof}

%   Let $\sim$ be the following equivalence relation on combinators $c_1 \sim c_2$ iff $\denot{c_1} = \denot{c_2}$
%   identifying combinators with the same denotation.  The notation $[c]_{\sim}$ refers to a representative combinator
%   from a $\sim$-equivalence class. Using this relation, we define the
%   category $\mathcal{C}$ as follows:
%   \begin{itemize}
%     \item $\mathit{Obj}(\mathcal{C})$ is the set of $\Pi$-types, and
%     \item $\mathit{Hom}(A,B) = [c : A \isot B]_{\sim}$
%   \end{itemize}
%   The category $\mathcal{C}$ is a groupoid.
% \end{theorem}
% \begin{proof}
%   The relation $\sim$ identifies $c$, $\idc \circ c$, and $c \circ \idc$, and is associative. Furthermore, the denotation
%   of each combinator is a reversible function thus making every morphism into an isomorphism.
% \end{proof}

% \note{Then say that $\mathcal{C}$ is ``the same'' as $\BFin$ We can say here that the relation $\sim$ also identifies
%   $(c_1~\oplus~c_2)~\circledcirc~\swapp$ and $\swapp \circledcirc (c_2~\oplus~c_1)$ and other properties. ?? }

% \[\begin{array}{l}
%     \Tree[ {\small a} [ {\small b} {\small c} ] ] \\
%     2 \quad 1 \quad 0 \\
%     0 \quad 2 \quad 1 \\
%     \Tree[ [ {\small b}  {\small c} ] {\small a} ]
% \end{array}\]

% Such functions are finitely supported, that is, their outputs can be tabulated using the canonical ordering on
% $\Fin[n]$. For bijections, this gives a listed permutation. By observing the action of the combinators on the values of
% the finite set, we can define a denotational semantics which constructs the bijection.
% \note{\(\Fin[n] \to A \eqv <\type{Vec_{n}}(A)\)}

% In the previous section, we examined equivalences between conventional data structures, i.e., structured trees of
% values. We now consider a richer but foundational notion of data: programs themselves. Indeed, universal computation
% models crucially rely on the fact that \emph{programs are (or can be encoded as) data}, e.g., a Turing machine can be
% encoded as a string that another Turing machine (or even the same machine) can manipulate. Similarly, first-class
% functions are the \emph{only} values in the $\lambda$-calculus.  In our setting, we ask whether the programs developed
% in the previous section can themselves be subject to (higher-level) equivalences?

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "main"
%%% fill-column: 120
%%% End:
