\section{Informal Examples}
\label{sec:informal}

% \todo{Not the right title.}

% \note{This section should explain the main technical parts of the paper
%   informally, without using any technology. Use an example, such as, a
%   reversible language with $\leq 5$ bits, and examples of permutations and
%   transpositions, and when they're equal.}

Instead of working with circuits operating on sequences of bits, we work with circuits operating on algebraic data
types.

\paragraph*{Normalisation by evaluation.} Consider the following reversible function:
$\Afun{RESET}(b,b_1,\ldots,b_n) = (b \; \underline{\vee} \; (\bigvee_{i=1}^n b_i),b_1,\ldots,b_n)$ where $\vee$ is
logical-or and $\underline{\vee}$ is exclusive-or. The function sets or resets the first bit depending on whether any of
the other bits is true or not. The natural definition for this function is recursive: modulo some re-shuffling of the
bits, the strategy is to examine the bits $b_i$ one-by-one: if we encounter a true value, we negate the first bit and
terminate; otherwise we continue making recursive calls until we reach the last bit at which point we return the
incoming value with no change:

%%\begin{minipage}{.65\textwidth}
%%  \PiRESET{}
%%\end{minipage}
%%\begin{minipage}{.30\textwidth}
%%  \begin{center}
%%  \resizebox{0.5\textwidth}{!}{\input{diagrams/reset.tikz}}
%%  \end{center}
%%\end{minipage}

\resettwo{}

\noindent The syntax will be explained in detail in the next section and the full definitions of the helpers are
provided in the supplementary material. For now, it is sufficient to know that there is some program that implements the
reversible function of interest and that applying \Afun{reset} to 2 produces \verb|reversibleOr2| from the
introduction. Our Agda infrastructure provides tools to normalise all programs to their normal form. For \Afun{reset 2}
we get:

\resetnormtwo{}

In principle, the normalised program can be produced following two strategies: (i) by repeatedly applying the rewrite
rules of our calculus of reversible functions (explained in Sec.~\ref{sec:reversibletwo}), or (ii) in the case above by
using a normalisation-by-evaluation (NbE) process that evaluates the program to a permutation on a finite set of 8
elements and reifies that permutation back to a program. The key idea of the NbE process is a systematic way to express
permutations as sequences of adjacent swaps as illustrated in the following small example where the permutation on the
left is compiled to the sequence of four adjacent transpositions on the right:

% \note{Motivation: There are two reversible circuits which describe the following permutation. They can be shown to be
%   equal using the 2-combinators.}

% \[
%   \begin{tikzpicture}
%     \begin{knot}[clip width=5]
%       \filldraw (0,5) circle (2pt) node[above] {0};
%       \filldraw (1,5) circle (2pt) node[above] {1};
%       \filldraw (2,5) circle (2pt) node[above] {2};
%       \filldraw (3,5) circle (2pt) node[above] {3};
%       \filldraw (4,5) circle (2pt) node[above] {4};
%       \filldraw (0,0) circle (2pt) node[below] {1};
%       \filldraw (1,0) circle (2pt) node[below] {4};
%       \filldraw (2,0) circle (2pt) node[below] {0};
%       \filldraw (3,0) circle (2pt) node[below] {3};
%       \filldraw (4,0) circle (2pt) node[below] {2};
%       \strand (0,5) .. controls (0.5,0.5) and (1.5,3.5) .. (2,0);
%       \strand (1,5) .. controls (0.75,0.5) and (0.25,3.5) .. (0,0);
%       \strand (2,5) .. controls (2.5,2.5) and (3.5,1.5) .. (4,0);
%       \strand (3,5) .. controls (4.5,2.5) and (4,1.5) .. (3,0);
%       \strand (4,5) .. controls (3.5,2.5) and (1.5,2.5) .. (1,0);
%       \flipcrossings{4,5};
%     \end{knot}
%   \end{tikzpicture}
% \]

\paragraph*{Program synthesis.} The NbE process embodies a quoting mechanism that synthesizes programs from
permutations. Indeed, instead of writing a program for \Afun{reset 2}, one might simply specify the desired permutation as:

\resetperm{}

\noindent The permutation uses the canonical encoding of sequences of bits as natural numbers (e.g., (\textsf{false},
\textsf{true},\textsf{true}) is encoded as 011 or 3).  The second entry maps index 1 (= 001) to the value 5 (= 101)
which states that since one of the right bits is set in 001 then the leftmost bit in the output is set. Simply
``quoting'' this permutation generates the same normalised program \Afun{reset2Norm} above.

\paragraph*{Program equivalence.} The permutation above reveals another way to think about the desired program: it is a
special addition circuit that keeps 0 and 4 fixed but otherwise adds 4 modulo 8 to its input. From this specification,
one can use a standard synthesis algorithm for reversible circuits~\cite{10.1145/775832.775915} to generate the
following program:

\adder{}

\noindent The \Afun{adder3} program looks nothing like the original \Afun{reset 2} program and yet they both have the
same normal form thus establishing their equivalence. The reader can check that this circuit is the same as
\verb|reversibleOr1| from the introduction.

% Now imagine we want to write the following reversible function:

% 0 -> 0
% 8 -> 8
% n -> n + 8 `mod` 16

% \note{This might be followed by a section which explains the syntax of Pi.}

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "main"
%%% fill-column: 120
%%% End:
