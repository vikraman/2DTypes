\documentclass[acmsmall]{acmart}
\settopmatter{printfolios=true,printccs=true,printacmref=true}

\usepackage{currfile}
\ifcurrfilename{popl22-rev-strip.tex}%
{\usepackage[appendix=strip]{apxproof}}%
{\usepackage[appendix=append]{apxproof}}

\usepackage[capitalise,noabbrev]{cleveref}
\usepackage[inline]{enumitem}
\usepackage{extarrows}
\usepackage{longtable}
\usepackage{adjustbox}
\usepackage{url}
\usepackage{multicol}
\usepackage{stmaryrd}
\usepackage{proof}
\usepackage{bbold}
\usepackage{subcaption}
\usepackage[utf8]{inputenc}
\usepackage{newunicodechar}
\usepackage{underoverlap}

\let\Bbbk\relax
\usepackage{amssymb}
\usepackage{newtxmath}

\usepackage{agda}
\AgdaNoSpaceAroundCode
\renewcommand{\AgdaCodeStyle}{\footnotesize}

\usepackage{tikz}
\usetikzlibrary{decorations.markings}
\usetikzlibrary{quotes,fit,positioning}
\usetikzlibrary{knots}
\tikzstyle{func}=[rectangle,draw,fill=black!20,minimum size=1.9em,text width=2.4em, text centered]
\usetikzlibrary{braids}
\tikzset{>=latex}
\usepackage{tikzit}
\input{tikzit.tikzstyles}
\usepackage{quiver}

\usepackage{macros}
\usepackage{hott}
\usepackage{syntax}

% \usepackage[
%   all=normal,
%   paragraphs,
%   floats,
%   wordspacing,
%   charwidths,
%   mathdisplays,
%   indent,
% ]{savetrees}

%% Some recommended packages.
%% \usepackage{booktabs}   %% For formal tables:
                        %% http://ctan.org/pkg/booktabs
%% \usepackage{subcaption} %% For complex figures with subfigures/subcaptions
                        %% http://ctan.org/pkg/subcaption
%% \usepackage{verbatim}
%% \usepackage{amsmath,amsbsy}
%% \usepackage{alltt}
%% \usepackage{fdsymbol}
%% \usepackage{amsthm,proof}
%% \usepackage{bbold,stmaryrd,bbm}
%% \usepackage{ucs}
%% \usepackage{wrapfig}
%% \usepackage[utf8x]{inputenc}
%% \usepackage{microtype}
%% \usepackage{agda}
%% \usepackage{mathtools}
%% \usepackage{amsthm,amsmath}
\usepackage[nocenter]{qtree}
%% \usepackage{listings}

\newtheorem{theorem}{Theorem}
\newtheorem{corollary}[theorem]{Corollary}
\newtheorem{lemma}[theorem]{Lemma}
\newtheorem{definition}[theorem]{Definition}
\newtheorem*{remark}{Remark}
\newtheoremrep{proprep}[theorem]{Proposition}

\newtheoremrep{theorem}{Theorem}[section]
\newtheoremrep{corollary}[theorem]{Corollary}
\newtheoremrep{proposition}[theorem]{Proposition}
\newtheoremrep{lemma}[theorem]{Lemma}
\newtheoremrep{definition}[theorem]{Definition}

\newunicodechar{‚ä∏}{$\multimap$}
\newunicodechar{ùïç}{$\mathbb{V}$}
\newunicodechar{ùïÉ}{$\mathbb{L}$}
\newunicodechar{ùïÑ}{$\mathbb{M}$}
\newunicodechar{‚Ñù}{$\mathbb{R}$}
\newunicodechar{ùïå}{$\mathbb{U}$}
\newunicodechar{ùîπ}{$\mathbb{B}$}
\newunicodechar{ùïê}{$\mathbb{Y}$}
\newunicodechar{ùîº}{$\mathbb{E}$}
\newunicodechar{ùîΩ}{$\mathbb{F}$}
\newunicodechar{ùïã}{$\mathbb{T}$}
\newunicodechar{ùïö}{$\mathbb{i}$}
\newunicodechar{ùüò}{$\mathbb{0}$}
\newunicodechar{ùüô}{$\mathbb{1}$}
\newunicodechar{ùüö}{$\mathbb{2}$}
\newunicodechar{ùüõ}{$\mathbb{3}$}
\newunicodechar{ùü†}{$\mathbb{8}$}
\newunicodechar{‚ü∑}{$\leftrightarrow$}
\newunicodechar{‚ÇÄ}{$_{0}$}
\newunicodechar{‚ÇÅ}{$_{1}$}
\newunicodechar{‚ÇÇ}{$_{2}$}
\newunicodechar{‚ÇÉ}{$_{3}$}
\newunicodechar{‚ÇÑ}{$_{4}$}
\newunicodechar{‚ñ†}{$\blacksquare$}
\newunicodechar{‚ä°}{$\boxdot$}
\newunicodechar{‚ãÜ}{$\star$}
\newunicodechar{‚óé}{$\circledcirc$}
\newunicodechar{‚äó}{$\otimes$}
\newunicodechar{‚äï}{$\oplus$}
\newunicodechar{‚Çä}{$_{+}$}
\newunicodechar{‚Üî}{$\leftrightarrow$}
\newunicodechar{‚áî}{$\Leftrightarrow$}
\newunicodechar{‚àÄ}{$\forall$}
\newunicodechar{œï}{$\phi$}
% agda --latex ../Examples/ExamplesL.lagda
\input{\detokenize{ExamplesL.tex}}

%%
%% \BibTeX command to typeset BibTeX logo in the docs
\AtBeginDocument{%
  \providecommand\BibTeX{{%
    \normalfont B\kern-0.5em{\scshape i\kern-0.25em b}\kern-0.8em\TeX}}}



%% Journal information
%% Supplied to authors by publisher for camera-ready submission;
%% use defaults for review submission.
\acmJournal{PACMPL}
\acmVolume{1}
\acmNumber{POPL} % CONF = POPL or ICFP or OOPSLA
\acmArticle{1}
\acmYear{2022}
\acmMonth{1}
\acmDOI{} % \acmDOI{10.1145/nnnnnnn.nnnnnnn}
\startPage{1}

%% Copyright information
%% Supplied to authors (based on authors' rights management selection;
%% see authors.acm.org) by publisher for camera-ready submission;
%% use 'none' for review submission.
%\setcopyright{none}
%\setcopyright{acmcopyright}
%\setcopyright{acmlicensed}
\setcopyright{rightsretained}
%\copyrightyear{2018}           %% If different from \acmYear

%% Bibliography style
\bibliographystyle{ACM-Reference-Format}
%% Citation style
%% Note: author/year citations are required for papers published as an
%% issue of PACMPL.
\citestyle{acmauthoryear}   %% For author/year citations

%%
%% end of the preamble, start of the body of the document source.
\begin{document}

%%
%% The "title" command has an optional parameter,
%% allowing the author to define a "short title" to be used in page headers.

\title{Symmetries in Reversible Programming}
\subtitle{From Symmetric Rig Groupoids to Reversible Programming Languages}

% Reversible Programming with Univalent Finite Types
% Curry-Lambek Correspondence between Reversible Circuits and Symmetric Rig Groupoids
% Reversible Curry-(Howard)-Lambek Correspondence

% Symmetries in Reversible Computing:
%   From Reversible Circuits to Symmetric Rig Groupoids and Back
%   Lambek Correspondence for Reversible Circuits and Symmetric Rig Groupoids
%   Symmetric Rig Groupoids for Reversible Circuits

% Symmetry in Reversible Computing (and its Lambek Correspondence)
% (The) Symmetry of Reversible Circuits
% (The) Symmetry of Reversible Programming
% The Symmetries of Reversible Computing
% Symmetry in Reversible Programming Languages
% Symmetry from a Reversible Perspective
% Symmetry in a Reversible Framework

% Computing with Univalent Subuniverses
% Programming with Computable Univalent Subuniverses
% Reversible Programming with Univalent Subuniverse
% The Computational Content of Univalent Subuniverses
% The Computational Content of Finite Type Isomorphisms
% Computational Content of Weak Rig Groupoids

% Univalent Curry-Howard-Lambek by Quantum Circuits NbE

%%
%% The "author" command and its associated commands are used to define
%% the authors and their affiliations.
%% Of note is the shared affiliation of the first two authors, and the
%% "authornote" and "authornotemark" commands
%% used to denote shared contribution to the research.
\author{Vikraman Choudhury}
\orcid{0000-0003-2030-8056}
\affiliation{
  \department{Department of Computer Science}
  \institution{Indiana University}
  \city{Bloomington}
  \postcode{47408}
  \country{USA}
}
\email{vikraman@indiana.edu}
\affiliation{
  \department{Department of Computer Science and Technology}
  \institution{University of Cambridge}
  \city{Cambridge}
  \postcode{CB3 0FD}
  \country{UK}
}
\email{vc378@cam.ac.uk}
\author{Jacek Karwowski}
\orcid{0000-0002-8361-2912}
\affiliation{
  \institution{University of Warsaw}
  \city{Warsaw}
  \postcode{00-927}
  \country{Poland}
}
\email{jac.karwowski@gmail.com}
\author{Amr Sabry}
\orcid{0000-0002-1025-7331}
\affiliation{
  \department{Department of Computer Science}
  \institution{Indiana University}
  \city{Bloomington}
  \postcode{47408}
  \country{USA}
}

%%
%% By default, the full list of authors will be used in the page
%% headers. Often, this list is too long, and will overlap
%% other information printed in the page headers. This command allows
%% the author to define a more concise list
%% of authors' names for this purpose.
% \renewcommand{\shortauthors}{Anonymous}

%%
%% The abstract is a short summary of the work to be presented in the
%% article.

% \begin{abstract}
%   The reversible model of computation is motivated by the physical nature of computational processes and proposes
%   information-preserving computation. The primitive building blocks in this paradigm are reversible boolean gates, which
%   can also be formalised as permutations of sets of bits, or combinators for type isomorphisms. We unify these
%   approaches by giving a sound and complete denotational semantics for a first-order reversible programming language
%   $\PiLang$ for reversible circuits and circuit equivalences.

%   We establish a correspondence between $\PiLang$ and the groupoid of finite sets and bijections. The result suggests a
%   Curry-Howard-Lambek correspondence between Reversible Logic, Reversible Programming Languages, and Symmetric Monoidal
%   Groupoids. Using the formalisation of our result, we show how to perform normalisation, verification, and synthesis of
%   reversible and quantum circuits.
% \end{abstract}

\begin{abstract}
  The $\PiLang$ family of reversible programming languages for boolean circuits is presented as a syntax of combinators
  witnessing type isomorphisms of algebraic datatypes. In this paper, we give a denotational semantics for this language,
  using the language of weak groupoids \`{a} la Homotopy Type Theory, and show how to derive an equational theory for it,
  presented by 2-combinators witnessing equivalences of reversible circuits.

  We establish a correspondence between the syntactic groupoid of the language and a formally presented univalent
  subuniverse of finite types. The correspondence relates 1-combinators to 1-paths, and 2-combinators to 2-paths in the
  universe, which is shown to be sound and complete for both levels, establishing full abstraction and adequacy. We extend
  the already established Curry-Howard correspondence for $\PiLang$ to a Curry-Howard-Lambek correspondence between
  Reversible Logic, Reversible Programming Languages, and Symmetric Rig Groupoids, by showing that the syntax of $\PiLang$
  is presented by the free symmetric rig groupoid, given by finite sets and permutations. Our proof uses techniques from
  the theory of group presentations and rewriting systems to solve the word problem for symmetric groups.

  Using the formalisation of our results, we show how to perform normalisation-by-evaluation, verification, and synthesis
  of reversible logic gates, motivated by examples from quantum computing.
\end{abstract}

% Using soundness and completeness, we show how to perform Normalisation by Evaluation (NbE) for boolean reversible
% circuits, motivated by a few examples of reversible logic gates used in Quantum Computing. We also show how to
% synthesise normal forms for reversible circuits starting from the extensional view of permutations of bits.

% proposed by~\cite{jamesInformationEffects2012}, settling a conjecture by~\citet{caretteComputingSemiringsWeak2016}.

% Reversible computing is an alternative model of computation motivated by the physical nature of computational
% processes, where computations are required to preserve information. Reversibility is encoded using reversible logic
% gates, or reversible boolean functions, which can be formalised as reversible programming languages of isomorphisms
% between finite types, or as permutations of finite sets.

% Several reversible programming languages have been
% proposed which permit hardware-independent, low-level and high-level descriptions of reversible circuits.

% Reversible boolean circuits are formalised both as isomorphisms between finite types and as permutations between
% finite sets. The first perspective is the basis of two-level reversible programming languages where programs in the
% level-1 denote type isomorphisms and programs in level-2 denote equivalences of level-1 programs. The second
% perspective rests on group theory and its categorification using symmetric rig categories. It is folklore that these
% two perspectives match but a full proof of this statement requires a non-trivial construction to establish that the
% algebraic presentation of \emph{free symmetric rig groupoid} (the syntax of the two level programming language) is
% equivalent to the \emph{weak symmetric rig of finite sets and bijections} (the categorification of the symmetric
% groups on finite sets).

% Our main result is this proof of equivalence thus establishing a sound and complete Curry-Lambek correspondence between the programming
% language and the categorical semantics. The proof, formalised in Agda, induces automatic processes for the
% synthesis of reversible circuits from permutations, for the verification of reversible circuits, and for normalising reversible circuits using
% normalisation-by-evaluation.


% we extract procedures for performing verification, synthesis and Normalisation
% by Evaluation (NbE) for boolean reversible circuits, motivated by a examples of reversible logic gates used in Quantum
% Computing. Working in a HoTT, we provide a syntactic presentation of a \emph{univalent subuniverse of finite types},
% and explain how the properties of the theory correspond to our programming-language results.

% Using the sound and complete denotational semantics, we show how to perform Normalisation by Evaluation (NbE) for
% reversible boolean circuits, motivated by examples of reversible logic gates used in Quantum Computing. We also show
% how to decide equivalences of two reversible boolean circuits, and synthesise normal forms for reversible circuits
% starting from the extensional view of permutations of bits.

% The reversible model of computation motivated by the physical nature of computational processes, proposes reversible
% boolean circuits and reversible logic gates to perform computation. Several reversible programming languages have been
% proposed which permit hardware-independent, low-level and high-level descriptions of reversible circuits.

% The $\PiLang$ family of reversible languages were proposed by~\citet{jamesInformationEffects2012} as a first-order
% programming language for describing reversible circuits, using type isomorphisms of finite types.

% Reversible boolean functions can also be realised as permutations of finite sets of bits, and can be studied using
% permutation groups, and their horizontal categorification, groupoids. It was conjectured
% in~\cite{caretteComputingSemiringsWeak2016} that these two perspectives are the same.

% In this paper, we resolve this question by establishing a correspondence between $\PiLang$ and the groupoid of finite
% sets and bijections, establishing that the syntactic category of $\PiLang$ is equivalent to the free symmetric rig
% groupoid on one generator. This result suggests a Curry-Howard-Lambek correspondence between $\PiLang$ and symmetric
% monoidal groupoids.

% Using the sound and complete denotational semantics, we show how to perform Normalisation by Evaluation (NbE) for
% reversible boolean circuits, motivated by examples of reversible logic gates used in Quantum Computing. We also show
% how to decide equivalences of two reversible boolean circuits, and synthesise normal forms for reversible circuits
% starting from the extensional view of permutations of bits.

% --------

% Reversible paradigm, motivated by the physical nature of computational processes, argues for the advantages of doing
% computation in an information-preserving way. The primitive building blocks of such can be thought of in several ways:
% as reversible boolean gates, as permutations on a finite set, and as type isomorphisms. We propose an approach that
% unifies and relates all of those perspectives. By constructing an algebraic semantics for a reversible language with
% type isomorphisms and (optimizations?), we relate Reversible Logic, Reversible Programming Languages and Symmetric
% Monoidal Categories, in a way reminiscent of the Curry-Howard-Lambek correspondence between Intuitionistic Logic,
% Simply Typed Lambda Calculus and Cartesian Closed Categories.

% The result is formalised in the Homotopy Type Theory setting, in the Agda proof assistant. Using soundness and
% completeness on both program and program-optimization levels, we extract procedures for performing verification, synthesis and
% Normalisation by Evaluation (NbE) for boolean reversible circuits, motivated by a examples of reversible logic gates
% used in Quantum Computing. Working in a HoTT, we provide a syntactic presentation of a \emph{univalent subuniverse of
% finite types}, and explain how the properties of the theory correspond to our programming-language results.

% ----------

% Reversible computing is an alternative model of computation motivated by the physical nature of computational
% processes, where computations are required to preserve information. Several reversible programming languages have been
% proposed which permit hardware-independent, low-level and high-level descriptions of reversible circuits.

% The $\PiLang$ family of reversible programming languages were proposed by~\citet{jamesInformationEffects2012} in which
% all computations are logically reversible. Formally, it is presented as a language of 1-combinators witnessing type
% isomorphisms, and an equational theory given by 2-combinators witnessing 1-combinator optimisations.

% In this paper, we present a denotational semantics for this language, using the language of groupoids \`{a} la
% Homotopy Type Theory (HoTT). We establish a correspondence between the syntactic groupoid of the language and a
% formally presented univalent subuniverse of finite types. The correspondence relates 1-combinators to 1-paths, and
% 2-combinators to 2-paths in the universe, which is shown to be sound and complete for both levels. The result suggests
% a Curry-Howard-Lambek/Lawvere correspondence between Reversible Logic, Reversible Programming Languages, and Symmetric
% Monoidal Groupoids, similar to the well-known correspondence of Intuitionistic Logic, Simply Typed Lambda Calculus,
% and Cartesian Closed Categories.

% Using soundness and completeness, we show how to perform Normalisation by Evaluation (NbE) for boolean reversible
% circuits, motivated by a few examples of reversible logic gates used in Quantum Computing. We also show how to
% synthesise normal forms for reversible circuits starting from the extensional view of permutations of bits.

%%
%% The code below is generated by the tool at http://dl.acm.org/ccs.cfm.
%% Please copy and paste the code instead of the example below.
%%
\begin{CCSXML}
  <ccs2012>
  <concept>
  <concept_id>10003752.10003790.10011740</concept_id>
  <concept_desc>Theory of computation~Type theory</concept_desc>
  <concept_significance>500</concept_significance>
  </concept>
  <concept>
  <concept_id>10003752.10010124.10010131.10010137</concept_id>
  <concept_desc>Theory of computation~Categorical semantics</concept_desc>
  <concept_significance>500</concept_significance>
  </concept>
  <concept>
  <concept_id>10003752.10010124.10010131.10010133</concept_id>
  <concept_desc>Theory of computation~Denotational semantics</concept_desc>
  <concept_significance>500</concept_significance>
  </concept>
  <concept>
  <concept_id>10011007.10011006.10011008.10011009.10011012</concept_id>
  <concept_desc>Software and its engineering~Functional languages</concept_desc>
  <concept_significance>500</concept_significance>
  </concept>
  <concept>
  <concept_id>10011007.10011006.10011039.10011040</concept_id>
  <concept_desc>Software and its engineering~Syntax</concept_desc>
  <concept_significance>500</concept_significance>
  </concept>
  <concept>
  <concept_id>10011007.10011006.10011039.10011311</concept_id>
  <concept_desc>Software and its engineering~Semantics</concept_desc>
  <concept_significance>500</concept_significance>
  </concept>
  </ccs2012>
\end{CCSXML}

\ccsdesc[500]{Theory of computation~Type theory}
\ccsdesc[500]{Theory of computation~Categorical semantics}
\ccsdesc[500]{Theory of computation~Denotational semantics}
\ccsdesc[500]{Software and its engineering~Functional languages}
\ccsdesc[500]{Software and its engineering~Syntax}
\ccsdesc[500]{Software and its engineering~Semantics}

%%
%% Keywords. The author(s) should pick words that accurately describe
%% the work being presented. Separate the keywords with commas.
\keywords{reversible computing, reversible programming languages, homotopy type theory, denotational semantics,
  categorical semantics,
  computational group theory}

%%
%% This command processes the author and affiliation and title
%% information and builds the first part of the formatted document.
\maketitle

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\renewcommand{\appendixsectionformat}[2]{
  {Supplementary material for Section~#1}
}

\input{introduction}                                                            % 2 pages
\input{examples} % sec 1.5                                          % 2 pages
\input{reversible1} % sec 2 front                                         % 2 pages
\input{ufin}            % sec 3 back                                         %  5 pages
\input{finite}          % sec 4 middle                                      %  8 pages
\input{equivalence}  % sec 5 main result                             % 4 pages
\input{discussion}   % sec 6 context and conclusions        % 2 pages
%% \input{extra}

%% Acks: Chao-Hong and Jacques


\begin{acks}
  The authors would like to thank Jacques Carette and Chao-Hong Chen for numerous discussions, ideas, and contributions.  The authors would also like to thank the anonymous referees for their valuable comments and helpful suggestions.
\end{acks}


\bibliography{2dtypesZot,survey} %% ,chen}

\end{document}

%%% Local Variables:
%%% mode: latex
%%% TeX-master: t
%%% fill-column: 120
%%% End:
