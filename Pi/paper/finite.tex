\section{The Group of Permutations}
\label{sec:finite}

% Recap of the previous section
In~\cref{sec:ufin}, we established that paths in $\UFin$ are equivalent to families of loops on $\Fin[n]$ for every
$n:\Nat$, that is, automorphisms of finite sets of size $n$, with the loopspace encoding the automorphism group.  This
is also known to be the finite symmetric group $\Sn[n]$, making $\UFin$ the \emph{horizontal categorification} of $\Sn$
for every $n$. In this section, we will describe this group syntactically.

% What now?
In order to study syntactic descriptions of permutations, we will hit the problem of deciding whether two descriptions
refer to the same permutation -- in group theory, this is the \emph{word problem} for $\Sn$. Putting it in this form
allows us to connect it to the broader scope of computational group theory and combinatorics -- we can borrow ideas such
as Coxeter relations and Lehmer codes. The concepts we use can be found in any standard textbook on group theory, or see
the Symmetry book~\cite{symmetryBook2021} for a univalent point of view.

% The summary of what we'll do
Thus, the goal of this section is to reconcile two different approaches to defining the symmetric group -- as an
automorphism group, and as a group syntactically presented using \emph{generators} and \emph{relations}. The generators
of the group are similar to the primitive combinators in a (reversible) programming language -- the group structure
gives the composition and inverse operations, and the relations describe how these primitive combinators interact with
each other.

% High-level explanation of technical devices
First, we will define the required notions of free groups and group presentations, and state some of their most
important properties. Then, we introduce our chosen \emph{Coxeter presentation} for $\Sn$. To solve the word problem for
$\Sn$, we will use a rewriting system, with a suitable, well behaved collection of reduction rules corresponding to the
Coxeter presentation equations. Finally, we describe the normal forms in this rewriting system, using Lehmer codes, and prove the
correspondence between them and the type $\Aut[\Fin[n]]$ of automorphisms on a finite set. The generators and relations
we use here will be used to quote back to 1 and 2-combinators in $\PiLang$ (see~\cref{sec:equivalence}).

\subsection{Presenting the permutation group}

One way of thinking about presentations of $\Sn$ is via sorting algorithms, which use different primitive operations. A
sorting algorithm has to calculate a permutation of a list or a finite set, which satisfies the invariant of being a
sorted sequence, which means, the primitive operations of a sorting algorithm are able to generate all the permutations
on a given list. So, a chosen set of reversible operations in a sorting algorithm can be a good candidate for the
generators of a permutation group. For example, we could generate the permutation group on $\Fin[n]$ by using generators
(primitive operations) that:

\begin{itemize}
  \item swap the $i$-th element with the $(i+1)$-th element, that is, adjacent swaps, or
  \item swap the $i$-th element with the $j$-th element, for arbitrary $i$-s and $j$-s, or
  \item swap the $i$-th element with an element at a fixed position, or
  \item reverses a prefix $\Fin[k]$ of $\Fin[n]$ for $k \leq n$, or
  \item cyclically shift any subset of $\Fin[n]$.
\end{itemize}

Bubble sort uses the primitive operation of adjacent swaps, insertion sort and selection sort use the primitive
operation of swapping the $i$-th element with the $j$-th element, cycle sort uses cyclical shifts of subsequences,
pancake sort uses reversals of the prefixes of the list, et cetera. The choice of generators for our presentation is
important for the following reasons.

\begin{itemize}
  \item It affects the difficulty of solving the word problem in $\Sn$ and formalising the proof of its correctness.
  \item The choice of generators dictates which words become normal forms in this presentation of $\Sn$. These normal
        forms dictate the shape of the synthesised and normalised boolean circuits, which is the application we have in
        mind.
  \item Finally, the generators have to closely match the $\PiLang$ combinators so that we can quote back a permutation
        to a $\PiLang$ program, for the proof of completeness.
\end{itemize}

We will show that it is possible to encode all $\PiLang$ combinators using adjacent transpositions
(in~\cref{sec:equivalence}). Group presentations are built by adding equations to a \emph{free group}.

\begin{toappendix}
  \subsection{Groups}
  \label{subsec:groups}

  From universal algebra, a group is simply a set with a 0-ary constant $e$ (the neutral element), a binary operation
  $\blank\mult\blank$ for group multiplication, and a unary inverse operation $\inv{\blank}$. The neutral element has to
  satisfy unit and inverse laws, and the multiplication has to be associative (see~\cref{def:group}).

  A very simple example of a group is $\mathbb{Z}$, where the neutral element is 0, the inverse of $k$ is $-k$, and the
  group multiplication is given by integer addition.

  \begin{definition}[Group]
    \label{def:group}
    In type theory, a group $G$ can be defined as a set $S$ with the following pieces of data:

    \begin{enumerate}
      \item a unit or neutral element $e : S$
      \item a multiplication function $m : S \times S \to S$ written as $(g_{1}, g_{2}) \mapsto g_{1} \mult g_{2}$, that satisfies
            \begin{enumerate}
              \item the unit laws, for all $g : S$, that \( g \mult e \id g \) and \( e \mult g \id g \)
              \item the associativity law, for all $g_{1}, g_{2}, g_{3} : S$, that \( g_{1} \mult (g_{2} \mult g_{3}) \id (g_{1} \mult g_{2}) \mult g_{3} \)
            \end{enumerate}
      \item an inversion function $i : S \to S$ written as $g \mapsto \inv{g}$, that satisfies
            \begin{enumerate}
              \item the inverse laws, for all $g : S$, that \( g \mult \inv{g} \id e \) and \( \inv{g} \mult g \id e \)
            \end{enumerate}
    \end{enumerate}
  \end{definition}
\end{toappendix}

\subsection{Free groups}

Usually, there are are many equations, besides the group axioms, that hold for the elements of a group. For example, in
the group $\Aut[\Bool]$, or $\mathbb{Z}_2$, we have an equation $1 + 1 = 0$, which is not a consequence of the group
axioms, but is specific to this particular group. A free group has the property that no other equations hold except the
ones directly implied by the group axioms. For example, the additive group of integers $\mathbb{Z}$ is the free group on
the singleton set.

\begin{toappendix}
  \begin{definition}[Free group]
    \label{def:free-group}
    Given a set $A$, the free group $F(A)$ on it is given by a higher inductive type with the following point and path
    constructors. Notice the similarity with the definition of a group structure (\cref{def:group}), but note that each
    operation here is a generator for $F(A)$.
    \begin{itemize}
      \item An inclusion function $\eta_{A} : A \to F(A)$
      \item A multiplication function $m : F(A) \times F(A) \to F(A)$
      \item An element $e : F(A)$
      \item An inverse function $i : F(A) \to F(A)$
    \end{itemize}
    \smallskip
    \begin{itemize}
      \item For every $x, y, z : F(A)$, a path $\term{assoc} : m(x, m(y, z)) \id m(m(x, y), z)$
      \item For every $x : F(A)$, paths $\term{unitr} : m(x, e) \id x$ and $\term{unitl} : m(e, x) \id x$
      \item For every $x : F(A)$, paths $\term{invr} : m(x, i(x)) \id e$ and $\term{invl} : m(i(x), x) \id e$
      \item A 0-truncation, for every $x, y : F(A)$ and $p, q : x \id y$, a 2-path $\term{trunc} : p \id q$
    \end{itemize}
  \end{definition}
\end{toappendix}

A group homomorphism between groups $G$ and $H$ is a function $f : G \to H$ between the underlying sets that preserves
the group structure. Giving a group homomorphism out of the free group is equivalent to giving a function out of the
generating set. This is the universal property of free groups, stemming from the free-forgetful adjunction between the
category of groups and sets.

% Informally, it states that if we know how a map $f$ acts on the
% generating set $A$, we know exactly how it acts on every element of the group $F(A)$.

\begin{propositionrep}[Universal Property of $F(A)$]
  \label{prop:free-groups}
  Given a group $G$ and a map $f : A \to G$, there is a unique group homomorphism $\extend{f} : \term{Hom}(F(A), G)$
  such that $\extend{f} \comp \eta_A \htpy f$. Equivalently, composition with $\eta_A$ gives an equivalence
  $\term{Hom}(F(A),G) \eqv A \to G$.
\end{propositionrep}

\begin{toappendix}
  Alternatively, the type of group homomorphisms $h : \term{Hom}(F(A),G)$ satisfying $h \comp \eta_A \htpy f$ is
  contractible.

  % https://q.uiver.app/?q=WzAsMyxbMCwyLCJBIl0sWzAsMCwiRihBKSJdLFsyLDAsIkciXSxbMCwxLCJcXGV0YV9BIl0sWzAsMiwiZiIsMl0sWzEsMiwiXFxleHRlbmR7Zn0iLDAseyJzdHlsZSI6eyJib2R5Ijp7Im5hbWUiOiJkYXNoZWQifX19XSxbMyw0LCJcXGlkIiwwLHsic2hvcnRlbiI6eyJzb3VyY2UiOjIwLCJ0YXJnZXQiOjIwfSwic3R5bGUiOnsiYm9keSI6eyJuYW1lIjoibm9uZSJ9LCJoZWFkIjp7Im5hbWUiOiJub25lIn19fV1d
  \[\begin{tikzcd}
      {F(A)} && G \\
      \\
      A
      \arrow[""{name=0, anchor=center, inner sep=0}, "{\eta_A}", from=3-1, to=1-1]
      \arrow[""{name=1, anchor=center, inner sep=0}, "f"', from=3-1, to=1-3]
      \arrow["{\extend{f}}", dashed, from=1-1, to=1-3]
      \arrow["\id", Rightarrow, draw=none, from=0, to=1]
    \end{tikzcd}\]
\end{toappendix}

Following the universal-algebraic definition, in HoTT, we could use a naive higher inductive type to define the free
group, which enforces the group axioms by adding path constructors (see~\cref{def:free-group}). Using the induction
principle, we can easily verify the universal property. However, since this definition of $F(A)$ has lots of path
constructors corresponding to each group axiom, characterising its path space is difficult.

Instead, we will think about elements of the free group as words over an alphabet of letters drawn from the generating
set \emph{and} the set of their formal inverses. If we take the disjoint union of $A$ with itself, that is, $A + A$ as
the group's underlying set, we can use $\inl/\inr$ to mark the elements -- $\inl{a}$ means $a$ and $\inr{a}$ means
$\inv{a}$. Then, we can encode the free group using the free monoid, that is, lists of $A + A$. Additionally, we need to
ensure that the inverse laws hold, so we have to coalesce adjacent occurences of $a$ and $\inv{a}$.

\begin{definition}[Free group]
  Let $A$ be a set, and $\List[\blank]$ the free monoid. The free group $F(A)$ on $A$ is the set-quotient of $\List[A +
      A]$ by the congruence closure of the relation $a \cons \inv{a} \cons \nil \sim \nil$ and $\inv{a} \cons a \cons \nil
    \sim \nil$.
\end{definition}

\begin{proposition}
  $F(A) \defeq \quot{\List[A + A]}{\sim^{\ast}}$ has a group structure, with the empty list $\nil$ for the neutral
  element, multiplication given by list append $\append$, and inverse given by flipping $\inl$ and $\inr$, followed by
  reversing the list. Further, $F(A)$ with $\eta_A(a) \defeq \inl(a) \cons \nil$ satisfies the universal property of
  free groups, as stated in~\cref{prop:free-groups}.
\end{proposition}

\subsection{Group presentations}

A presentation of a group builds it by starting from the free group $F(A)$ and introducing additional equations that are
satisfied in the resulting group. For example, if we take $F(\unit) \defeq \mathbb{Z}$ and add an equation $1 + 1 = 0$,
the resulting group would be $\mathbb{Z}_2 \eqv \Aut[\Bool]$. Note that not all groups have finite (or computable)
presentations, and, a group can have any number of different presentations.

\begin{definition}[Group presentation]
  \label{def:presentation}
  Let $A$ be a set and $R : \List[A + A] \to \List[A + A] \to \UU$ a binary relation on $\List[A + A]$. The group
  $F(\langle A ; R \rangle)$ presented by $A$ and $R$, is given by the set-quotient of the free group $F(A)$ by the
  congruence closure of $R$.
\end{definition}

The universal property of the above definition is similar to~\cref{prop:free-groups} except the relation has to be
preserved by the function mapping out of the generating set.

\begin{proposition}[Universal property of $F(\langle A ; R \rangle)$]
  Given a group $G$ and a map $f : A \to G$, such that $f$ extended to $F(A)$ respects $R$, there is a unique group
  homomorphism $\extend{f} : \term{Hom}(F(\langle A ; R \rangle), G)$ such that $\extend{f} \comp \eta_A \htpy f$.
\end{proposition}

Before, the only way to decide the equality of two elements in a group was to evaluate and check them on the nose, but
in a group presentation, this is reduced to deciding whether one word -- a representative of the equivalence class of
the group's elements, can be reduced to another word, using the group's relations. However, these equations are not
directed, so it is not always possible to construct a well-behaved rewriting system. In general, the word problem for
groups is undecidable.

\paragraph{Coxeter Presentation} To present the group $\Sn$, the primitive operations we use will be adjacent swaps.
When dealing with permutations on an $n + 1$-element set, there are $n$ adjacent transpositions -- transposition number
$k$ swaps elements at indices $k$ and $k+1$. Thus, the generating set is $\Fin[n]$. There are three relations that we're
going to specify for this presentation -- we visualise them as braid diagrams in~\cref{fig:coxeter-braid}.

\begin{enumerate}[leftmargin=*]
  \item[\labelcref{fig:coxeter-a}] Swapping the same two elements twice in a row should be the same as doing nothing.
  \item[\labelcref{fig:coxeter-b}] When swapping two distinct pairs of elements, the order in which swapping happens
    should not matter, that is, we can slide the wires freely.
  \item[\labelcref{fig:coxeter-c}] There are two equivalent ways of swapping the first and last elements in a sequence
    of three elements.
\end{enumerate}

\begin{figure}
  \centering
  \begin{subfigure}[b]{0.25\textwidth}
    \centering
    \begin{tikzpicture}
      \pic[local bounding box=my braid,braid/.cd,
        number of strands = 2,
        width = 0.4cm,
        height = 0.4cm,
        border height = 0.3cm,
        thick] at (0, 0)
      {braid={ s_1, s_1}};
      \node[font=\large] at (1, 0.7) {\(=\)};
      \pic[local bounding box=my braid,braid/.cd,
        number of strands = 2,
        width = 0.4cm,
        height = 0.4cm,
        border height = 0.3cm,
        thick] at (1.6, 0)
      {braid={ 1, 1}};
    \end{tikzpicture}
    \caption{$\cancel$}
    \label{fig:coxeter-a}
  \end{subfigure}
  \begin{subfigure}[b]{0.4\textwidth}
    \centering
    \begin{tikzpicture}
      \pic[local bounding box=my braid,braid/.cd,
        number of strands = 2,
        width = 0.4cm,
        height = 0.4cm,
        border height = 0.3cm,
        thick] at (0, 0)
      {braid={ s_1, 1}};
      \node[] at (0.7, 0.7) {\(\dots\)};
      \pic[local bounding box=my braid,braid/.cd,
        number of strands = 2,
        width = 0.4cm,
        height = 0.4cm,
        border height = 0.3cm,
        thick] at (1, 0)
      {braid={ 1, s_1 }};
      \node[font=\large] at (1.9, 0.7) {\(=\)};
      \pic[local bounding box=my braid,braid/.cd,
        number of strands = 2,
        width = 0.4cm,
        height = 0.4cm,
        border height = 0.3cm,
        thick] at (2.4, 0)
      {braid={ 1, s_1}};
      \node[] at (3.1, 0.7) {\(\dots\)};
      \pic[local bounding box=my braid,braid/.cd,
        number of strands = 2,
        width = 0.4cm,
        height = 0.4cm,
        border height = 0.3cm,
        thick] at (3.4, 0)
      {braid={ s_1, 1}};
    \end{tikzpicture}
    \caption{$\swap$}
    \label{fig:coxeter-b}
  \end{subfigure}
  \begin{subfigure}[b]{0.25\textwidth}
    \centering
    \begin{tikzpicture}
      \pic[local bounding box=my braid,braid/.cd,
        number of strands = 3,
        width = 0.4cm,
        height = 0.4cm,
        border height = 0.1cm,
        thick] at (0, 0)
      {braid={ s_2, s_1, s_2}};
      \node[font=\large] at (1.4, 0.7) {\(=\)};
      \pic[local bounding box=my braid,braid/.cd,
        number of strands = 3,
        width = 0.4cm,
        height = 0.4cm,
        border height = 0.1cm,
        thick] at (2, 0)
      {braid={ s_1, s_2, s_1}};
    \end{tikzpicture}
    \caption{$\braid$}
    \label{fig:coxeter-c}
  \end{subfigure}
  \caption{Braiding diarams for Coxeter relations.}
  \label{fig:coxeter-braid}
\end{figure}

\noindent
This construction is called a Coxeter presentation of $\Sn$. Writing it formally, we encode the rules discussed above
using a relation $\cox$ on $\List[\Fin[n]]$ (\cref{def:cox}), and then take its congruence closure $\cox*$
(\cref{def:coxstar}).

\begin{definition}[$\cox : {\List[\Fin[n]]} \to {\List[\Fin[n]]} \to {\UU}$]
  \label{def:cox}
  \begin{align*}
    \cancel
     & : \forall n \to (n \cons n \cons \nil) \cox \nil                                                     \\
    \swap
     & : \forall k, n \to (\suc[k] < n) \to (n \cons k \cons \nil) \cox (k \cons n \cons \nil)              \\
    \braid
     & : \forall n \to (\suc[n] \cons n \cons \suc[n] \cons \nil) \cox (n \cons \suc[n] \cons n \cons \nil)
  \end{align*}
\end{definition}

\begin{toappendix}
  \begin{definition}[$\cox* : {\List[\Fin[n]]} \to {\List[\Fin[n]]} \to {\UU}$]
    \label{def:coxstar}
    \begin{align*}
      \reflr{\cox}
       & : \forall w \to w \cox* w                                                                                                           \\
      \symr{\cox}
       & : \forall w_{1}, w_{2} \to w_{1} \cox* w_{2} \to w_{2} \cox* w_{1}                                                                  \\
      \transr{\cox}
       & : \forall w_{1}, w_{2}, w_{3} \to  w_{1} \cox* w_{2} \to w_{2} \cox* w_{3} \to w_{1} \cox* w_{3}                                    \\
      \congrf{\cox}{\append}
       & : \forall w_{1}, w_{2}, w_{3}, w_{4} \to  w_{1} \cox* w_{2} \to w_{3} \cox* w_{4} \to w_{1} \append w_{3} \cox* w_{2} \append w_{4} \\
      \relr{\cox}
       & : \forall w_{1}, w_{2} \to w_{1} \cox w_{2} \to w_{1} \cox* w_{2}
    \end{align*}
  \end{definition}
\end{toappendix}

The idea for solving the word problem for $\Sn$ is to turn these undirected relations into a rewriting
system $(\List[\Fin[n]],\cox*)$, so that, by repeatedly applying the reduction rules as long as possible, any two
$\cox*$-equal terms would eventually converge to the same normal form.

For this to work, we first need the system to have the termination property, meaning that there are no infinite
reductions. We observe that after throwing out reflexivity and symmetry, the right hand sides of the relations $\cox*$
are strictly smaller than the left hand sides, in terms of the lexicographical ordering on words in $\Fin[n]$ (which is
well-founded). Thus, by directing the relation from left to right, we would get the termination property out of the box.
Second, we need the normal forms to be unique, so that we can get a normalisation function. This will be true if the
rewriting system is confluent -- meaning that all critical pairs, that is, terms with overlapping possible reduction
rules, have to converge. For example, in our system, the pair in~\cref{fig:critical-pairs-converging} converges.
Unfortunately, this is not true for all critical pairs -- an  example is in~\cref{fig:critical-pairs-non-converging},
where left and right endpoints are normal with respect to the $\cox*$ relation.

% \begin{figure}
% \[
%   \begin{array}{lcr}
%     \gspan[\braid][\braid]{\tau_2\tau_1\tau_2\tau_1\tau_2}{\tau_1\tau_2\tau_1\tau_1\tau_2}{\tau_2\tau_1\tau_1\tau_2\tau_1}
%      &
%     \text{or}
%      &
%     \gspan[\braid][\cancel]{\tau_2\tau_1\tau_2\tau_2}{\tau_1\tau_2\tau_1\tau_2}{\tau_2\tau_1}
%   \end{array}
% \]
% \caption{Critical pairs}
% \label{fig:critical-pairs}
% \end{figure}
%  \begin{subfigure}[]{0.45\textwidth}
%    % https://q.uiver.app/?q=WzAsNSxbMiwwLCJcXHRhdV8yXFx0YXVfMVxcdGF1XzJcXHRhdV8yIl0sWzAsMSwiXFx0YXVfMVxcdGF1XzJcXHRhdV8xXFx0YXVfMiJdLFsyLDQsIlxcdGF1XzJcXHRhdV8xIl0sWzAsMiwiXFx0YXVfMVxcdGF1XzJcXHRhdV8xXFx0YXVfMiJdLFsxLDMsIlxcdGF1XzFcXHRhdV8xXFx0YXVfMlxcdGF1XzEiXSxbMCwxLCJicmFpZCIsMix7InN0eWxlIjp7ImJvZHkiOnsibmFtZSI6InNxdWlnZ2x5In19fV0sWzAsMiwiY2FuY2VsIiwwLHsic3R5bGUiOnsiYm9keSI6eyJuYW1lIjoic3F1aWdnbHkifX19XSxbMSwzLCJicmFpZCIsMix7InN0eWxlIjp7ImJvZHkiOnsibmFtZSI6InNxdWlnZ2x5In19fV0sWzMsNCwiYnJhaWQiLDIseyJzdHlsZSI6eyJib2R5Ijp7Im5hbWUiOiJzcXVpZ2dseSJ9fX1dLFs0LDIsImNhbmNlbCIsMix7InN0eWxlIjp7ImJvZHkiOnsibmFtZSI6InNxdWlnZ2x5In19fV1d
%    \adjustbox{scale=\scalef,center}{
%      \begin{tikzcd}
%        && {\tau_2\tau_1\tau_2\tau_2} \\
%        {\tau_1\tau_2\tau_1\tau_2} \\
%        {\tau_1\tau_2\tau_1\tau_2} \\
%        & {\tau_1\tau_1\tau_2\tau_1} \\
%        && {\tau_2\tau_1}
%        \arrow["\braid"', squiggly, from=1-3, to=2-1]
%        \arrow["\cancel", squiggly, from=1-3, to=5-3]
%        \arrow["\braid"', squiggly, from=2-1, to=3-1]
%        \arrow["\braid"', squiggly, from=3-1, to=4-2]
%        \arrow["\cancel"', squiggly, from=4-2, to=5-3]
%      \end{tikzcd}
%    }
%  \end{subfigure}
%   \begin{subfigure}[]{0.45\textwidth}
%    $\gspan[\braid][\swap]{\tau_3\tau_2\tau_3\tau_1}{\tau_2\tau_3\tau_2\tau_1}{\tau_3\tau_2\tau_1\tau_3}$
%    \caption{Non-converging critical pairs}
%    \label{fig:critical-pairs-non-converging}
%  \end{subfigure}

% a + \UOLoverbrace{b +}[c + d]Ë†x \UOLunderbrace{+ e}_y + f

\begin{figure}
  \centering
  \begin{subfigure}[b]{0.35\textwidth}
    % https://q.uiver.app/?q=WzAsNixbMSwwLCJcXHRhdV8yXFx0YXVfMVxcdGF1XzJcXHRhdV8xXFx0YXVfMiJdLFswLDEsIlxcdGF1XzFcXHRhdV8yXFx0YXVfMVxcdGF1XzFcXHRhdV8yIl0sWzIsMSwiXFx0YXVfMlxcdGF1XzFcXHRhdV8xXFx0YXVfMlxcdGF1XzEiXSxbMCwyLCJcXHRhdV8xXFx0YXVfMlxcdGF1XzIiXSxbMSwzLCJcXHRhdV8xIl0sWzIsMiwiXFx0YXVfMlxcdGF1XzJcXHRhdV8xIl0sWzAsMSwiYnJhaWQiLDIseyJzdHlsZSI6eyJib2R5Ijp7Im5hbWUiOiJzcXVpZ2dseSJ9fX1dLFswLDIsImJyYWlkIiwwLHsic3R5bGUiOnsiYm9keSI6eyJuYW1lIjoic3F1aWdnbHkifX19XSxbMSwzLCJjYW5jZWwiLDIseyJzdHlsZSI6eyJib2R5Ijp7Im5hbWUiOiJzcXVpZ2dseSJ9fX1dLFszLDQsImNhbmNlbCIsMix7InN0eWxlIjp7ImJvZHkiOnsibmFtZSI6InNxdWlnZ2x5In19fV0sWzIsNSwiY2FuY2VsIiwwLHsic3R5bGUiOnsiYm9keSI6eyJuYW1lIjoic3F1aWdnbHkifX19XSxbNSw0LCJjYW5jZWwiLDAseyJzdHlsZSI6eyJib2R5Ijp7Im5hbWUiOiJzcXVpZ2dseSJ9fX1dXQ==
    \adjustbox{scale=\scalef,center}{
      \begin{tikzcd}
        & {\UOLoverline{\tau_2\tau_1}[\tau_2]\UOLunderline{\tau_1\tau_2}} \\
        {\tau_1\tau_2\overline{\tau_1\tau_1}\tau_2} && {\tau_2\underline{\tau_1\tau_1}\tau_2\tau_1} \\
        {\tau_1\overline{\tau_2\tau_2}} && {\underline{\tau_2\tau_2}\tau_1} \\
        & {\tau_1}
        \arrow["\braid"', squiggly, from=1-2, to=2-1]
        \arrow["\braid", squiggly, from=1-2, to=2-3]
        \arrow["\cancel"', squiggly, from=2-1, to=3-1]
        \arrow["\cancel"', squiggly, from=3-1, to=4-2]
        \arrow["\cancel", squiggly, from=2-3, to=3-3]
        \arrow["\cancel", squiggly, from=3-3, to=4-2]
      \end{tikzcd}
    }
    \caption{Converging critical pair}
    \label{fig:critical-pairs-converging}
  \end{subfigure}
  \begin{subfigure}[b]{0.55\textwidth}
    \adjustbox{scale=\scalef,center}{
      % https://q.uiver.app/?q=WzAsMyxbMSwwLCJcXHRhdV8zXFx0YXVfMlxcdGF1XzNcXHRhdV8xIl0sWzAsMiwiXFx0YXVfMlxcdGF1XzNcXHRhdV8yXFx0YXVfMSJdLFszLDEsIlxcdGF1XzNcXHRhdV8yXFx0YXVfMVxcdGF1XzMiXSxbMCwxLCJicmFpZCIsMix7InN0eWxlIjp7ImJvZHkiOnsibmFtZSI6InNxdWlnZ2x5In19fV0sWzAsMiwiYnJhaWQiLDAseyJzdHlsZSI6eyJib2R5Ijp7Im5hbWUiOiJzcXVpZ2dseSJ9fX1dLFsyLDEsIlxcbG9uZ2JyYWlkIiwwLHsic3R5bGUiOnsiYm9keSI6eyJuYW1lIjoic3F1aWdnbHkifX19XV0=
      \begin{tikzcd}
        & {\UOLoverline{\tau_3\tau_2}[\tau_3]\UOLunderline{\tau_1}} \\
        &&& {\underline{\tau_3\tau_2\tau_1\tau_3}} \\
        {\tau_2\tau_3\tau_2\tau_1}
        \arrow["\braid"', squiggly, from=1-2, to=3-1]
        \arrow["\swap", squiggly, from=1-2, to=2-4]
        \arrow["\longbraid", squiggly, from=2-4, to=3-1]
      \end{tikzcd}
    }
    \caption{Non-converging critical pair that converges with $\longbraid$}
    \label{fig:critical-pairs-non-converging}
  \end{subfigure}

  \caption{Critical Pairs in $\cox*$}
  \label{fig:critical-pairs}
\end{figure}

\subsection{Rewriting via Coxeter}

Because of this counter-example, the relations have to be changed. In this section, we formally define a rewriting
system $(\List[\Fin[n]], \longcox)$, partially based on the Coxeter relations, and prove that it has the desired
properties of confluence and termination. We prove that the new relation defined by this system is equivalent, in a
technical sense, to the standard Coxeter relation $\cox*$. First, we need to define a function $n \downf k$.

\begin{definition}[$\downf : (n : \Nat) \to (k : \Nat) \to {\List[\Fin[k + n]]}$]
  \begin{align*}
    n \downf \zero   & \defeq \nil                       \\
    n \downf \suc[k] & \defeq (k + n) \cons (n \downf k)
  \end{align*}
\end{definition}

\noindent The result of this function is the sequence \([k + n - 1, k + n - 2, k + n - 3, \ldots, n]\), which is a
sequence of transpositions that moves the element at index $k + n$ left by $k$ places, shifting all the elements in
between one place right (see~\cref{fig:downf}). Then, the directed relation $\longcox$ is defined with the following
generators (inlining the congruence closure in $\longcox$, allowing arbitrary reductions inside the list).

\begin{definition}[$\longcox : {\List[\Fin[n]]} \to {\List[\Fin[n]]} \to {\UU}$]
  \begin{align*}
    \longcancel
     & : \forall n, l, r \to (l \append n \cons n \cons r) \longcox (l \append r)                                                                      \\
    \longswap
     & : \forall n, k, l, r \to (\suc[k] < n) \to (l \append n \cons k \cons r) \longcox (l \append k \cons n \append r)                               \\
    \longbraid
     & : \forall n, k, l, r \to (l \append (n \downf 2 + k) \append (1 + k + n) \cons r) \longcox (l \append (k + n) \cons (n \downf 2 + k) \append r)
  \end{align*}
\end{definition}

\noindent Constructors $\longcancel$ and $\longswap$ correspond directly to the appropriate constructors of $\cox$ and
can be visualised in the same way as before. The remaining constructor $\longbraid$ uses the $\downf$ function to
exchange the order of a long sequence of transpositions and a single transposition afterwards. For example, for $n = 0$
and $k = 3$, it allows for the reduction $[4, 3, 2, 1, 0, 4] \longcox [3, 4, 3, 2, 1, 0]$ (see~\cref{fig:longcox} --
note the distinction between wires, where numbers represent the values, and transpositions, where numbers represent
which wires are crossing).

\begin{figure}
  \begin{subfigure}[b]{0.3\textwidth}
    \centering
    \begin{tikzpicture}
      \def\nstrandsdf{7}
      \pic[local bounding box=my braid,braid/.cd,
        number of strands = \nstrandsdf,
        width = 0.4cm,
        height = 0.4cm,
        border height = 0.1cm,
        thick,
        name prefix=braid]
      {braid={s_1, s_2, s_3, s_4, s_5, s_6}};
      % \draw[thick] % draws the top/bottom bars
      % ([xshift=-1ex]my braid.north west) --  ([xshift=1ex]my braid.north east)
      % ([xshift=-1ex]my braid.south west) --  ([xshift=1ex]my braid.south east);
      \foreach \n in {1,...,\nstrandsdf}{
          \pgfmathtruncatemacro{\nminusone}{\n - 1}
          \node at (braid-\n-s)[yshift = 2.8cm] {\nminusone};
        }
      % labels the bottom bar
      \node at (braid-1-e)[yshift = -2.8cm] {5};
      \node at (braid-2-e)[yshift = -2.8cm] {6};
      \node at (braid-3-e)[yshift = -2.8cm] {0};
      \node at (braid-4-e)[yshift = -2.8cm] {1};
      \node at (braid-5-e)[yshift = -2.8cm] {2};
      \node at (braid-6-e)[yshift = -2.8cm] {3};
      \node at (braid-7-e)[yshift = -2.8cm] {4};
    \end{tikzpicture}
    \caption{$0 \downf 6$}
    \label{fig:downf}
  \end{subfigure}
  \hfill
  \begin{subfigure}[b]{0.6\textwidth}
    \centering
    \begin{tikzpicture}
      \def\nstrandsbl{6}
      \pic[local bounding box=my braid,braid/.cd,
        number of strands = \nstrandsbl, % number of  strands
        width = 0.4cm,
        height = 0.4cm,
        border height = 0.1cm,
        thick,
        name prefix=braid] at (0, 0)
      {braid={s_5, s_1, s_2, s_3, s_4, s_5}};
      \node[font=\large] at (3, 1.3) {\(\rightarrow\)};
      % \draw[thick] % draws the top/bottom bars
      % ([xshift=-1ex]my braid.north west) --  ([xshift=1ex]my braid.north east)
      % ([xshift=-1ex]my braid.south west) --  ([xshift=1ex]my braid.south east);
      \foreach \n in {1,...,\nstrandsbl}{
          \pgfmathtruncatemacro{\nminusone}{\n - 1}
          \node at (braid-\n-s)[yshift = 2.8cm] {\nminusone};
        }
      % labels the bottom bar
      \node at (braid-1-e)[yshift = -2.8cm] {3};
      \node at (braid-2-e)[yshift = -2.8cm] {5};
      \node at (braid-3-e)[yshift = -2.8cm] {0};
      \node at (braid-4-e)[yshift = -2.8cm] {1};
      \node at (braid-5-e)[yshift = -2.8cm] {4};
      \node at (braid-6-e)[yshift = -2.8cm] {2};

      \def\nstrandsbr{6}
      \pic[local bounding box=my braid,braid/.cd,
        number of strands = \nstrandsbr,
        width = 0.4cm,
        height = 0.4cm,
        border height = 0.1cm,
        thick,
        name prefix=braid] at (4, 0)
      {braid={s_1, s_2, s_3, s_4, s_5, s_4}};
      % \draw[thick] % draws the top/bottom bars
      % ([xshift=-1ex]my braid.north west) --  ([xshift=1ex]my braid.north east)
      % ([xshift=-1ex]my braid.south west) --  ([xshift=1ex]my braid.south east);
      \foreach \n in {1,...,\nstrandsbl}{
          \pgfmathtruncatemacro{\nminusone}{\n - 1}
          \node at (braid-\n-s)[yshift = 2.8cm] {\nminusone};
        }
      % labels the bottom bar
      \node at (braid-1-e)[yshift = -2.8cm] {3};
      \node at (braid-2-e)[yshift = -2.8cm] {5};
      \node at (braid-3-e)[yshift = -2.8cm] {0};
      \node at (braid-4-e)[yshift = -2.8cm] {1};
      \node at (braid-5-e)[yshift = -2.8cm] {4};
      \node at (braid-6-e)[yshift = -2.8cm] {2};
    \end{tikzpicture}
    \caption{ $\longbraid$ with $n = 0$ and $k = 3$}
    \label{fig:longcox}
  \end{subfigure}
  \caption{Braiding diagrams for modified Coxeter relations.}
  \label{fig:coxeter-braid-mod}
\end{figure}
% in terms of the lexicographic order on $\List[\Fin[n]]$.

\begin{toappendix}
  \begin{definition}[$\longcoxstar : {\List[\Fin[n]]} \to {\List[\Fin[n]]} \to {\UU}$]
    \label{def:longcox-star}
    \begin{align*}
      \reflr{\longcox}
       & : \forall w \to w \longcoxstar w                                                                                  \\
      \transr{\longcox}
       & : \forall w_{1}, w_{2}, w_{3} \to  w_{1} \longcox w_{2} \to w_{2} \longcoxstar w_{3} \to w_{1} \longcoxstar w_{3}
    \end{align*}
  \end{definition}

  \begin{definition}[$\longcoxplus : {\List[\Fin[n]]} \to {\List[\Fin[n]]} \to {\UU}$]
    \label{def:longcox-plus}
    \begin{align*}
      \relr{\longcoxplus}
       & : \forall w_{1}, w_{2} \to w_{1} \longcox w_{2} \to w_{1} \longcoxplus w_{2}                                      \\
      \transr{\longcoxplus}
       & : \forall w_{1}, w_{2}, w_{3} \to  w_{1} \longcox w_{2} \to w_{2} \longcoxplus w_{3} \to w_{1} \longcoxplus w_{3}
    \end{align*}
  \end{definition}
\end{toappendix}

Note that the previous $\braid$ rule is a special case of $\longbraid$, with $k = 0$. As before, the left-hand sides of
the relation are (lexicographically) strictly larger than the right-hand sides. We define the transitive closure of
$\longcox$ to be $\longcoxplus$ (\cref{def:longcox-plus}) and its reflexive-transitive closure to be $\longcoxstar$
(\cref{def:longcox-star}).

Despite the increased complexity of the generators, the rewriting system $(\List[\Fin[n]],\longcox)$ has the properties
we desire. It satisfies local confluence, that is, the Church-Rosser (diamond) property -- for example, using
$\longbraid$, we can now show the problematic critical pair \cref{fig:critical-pairs-non-converging} converges, and, it
is terminating, so by Newman's lemma, it produces a unique normal form. We follow the terminology
of~\citet*{huetConfluentReductionsAbstract1980,krausCoherenceWellFoundednessTaming2020} to state our results formally.

\begin{theorem}
  \label{prop:nf}
  \leavevmode
  \begin{enumerate}
    \item $\longcox$ is (locally) confluent. For every span $\coxspan{w_{1}}{w_{2}}{w_{3}}$, there is a matching
          extended cospan $\coxcospan*{w_{2}}{w_{3}}{w}$.
    \item $\longcoxplus$ is terminating. For every $w \longcoxplus v$, it holds that $v < w$, where $<$ is the (well-founded)
          lexicographic ordering on $\List[\Fin[n]]$.
    \item $\longcoxstar$ is confluent. For every extended span $\coxspan*{w_{1}}{w_{2}}{w_{3}}$, there is a matching
          extended cospan $\coxcospan*{w_{2}}{w_{3}}{w}$.
    \item For every $w$, there exists a unique normal form $v$ such that $w \longcoxstar v$.~\label{prop:nf-uniqueness}
  \end{enumerate}
\end{theorem}

The modified form of the Coxeter relations are unwieldy and difficult to prove properties about by induction. However,
we can make the following observation relating it to $\cox*$.

\begin{proposition}
  \label{prop:coxlongcox}
  The relations $\cox*$ and $\longcoxstar$ are equivalent in the following sense: for every $w$ and $v$, $w \cox* v$ iff
  there is a $u$ such that $\coxcospan*{w}{v}{u}$.
\end{proposition}

By~\cref{prop:nf}~\ref{prop:nf-uniqueness}, we get a unique choice function $\normf : {\List[\Fin[n]]} \to
  {\List[\Fin[n]]}$ that produces a normal form for terms of $\List[\Fin[n]]$. We state two important properties enjoyed
by $\normf$.

\begin{proposition}
  \leavevmode
  \begin{enumerate}
    \item For all $l : \List[\Fin[n]]$, we have that $l \cox* \normf(l)$.
    \item $\normf$ is idempotent, that is, $\normf \comp \normf \htpy \normf$.
  \end{enumerate}
\end{proposition}

\noindent Finally, we define the type $\Sn$ as the set-quotient of $\List[\Fin[n]]$ by $\cox*$,

\begin{definition}[$\Sn$]
  \(\Sn \defeq \quot{\List(\Fin[n])}{\cox*}\)
\end{definition}

\noindent Note that reductions need not be unique, hence $w \cox* v$ is not necessarily a proposition. So, the quotient
$\Sn$ is not effective, that is, $\quotrel : w \cox* v \to q(w) \id q(v)$ is not an equivalence. Using the $\normf$
function, we could instead define a new relation $\approx$ to equate those terms that have the same normal form, $(w
  \approx v) \defeq (\normf(w) \id \normf(v))$. This relation is prop-valued, and we could quotient $\List[\Fin[n]]$ by
$\approx$, obtaining an equivalent definition for $\Sn$.

\begin{proposition}
  \leavevmode
  \begin{enumerate}
    \item $\normf$ splits into a section-retraction pair, that is, we have ${\List[\Fin[n]]} \xrightarrow{s} \Sn[n]
            \xrightarrow{r} {\List[\Fin[n]]}$ such that $s \comp r \htpy \normf$ and $r \comp s \htpy \idfunc_{\Sn[n]}$.
    \item \(\im{\quotinc} \eqv \Sn \eqv \im{\normf} \), where $\quotinc : \List[\Fin[n]] \to \Sn$ is the mapping into
          the quotient.
  \end{enumerate}
\end{proposition}

\noindent
Finally, we need to show that $\Sn$ and is indeed a group presentation.

\begin{propositionrep}
  \label{prop:group-structure-Sn}
  There is a group structure on $\Sn$, where the identity element is $\nil$, multiplication is given by list append, and
  inverse is given by list reversal.
\end{propositionrep}

\begin{proof}
  The operation $\append$ is associative, with $\nil$ as the neutral element, and the constructor $\cancel$ makes each
  element an inverse of itself, so the inverse in the group is indeed given by list reversal.
\end{proof}

\noindent
Notice however, that for a group presentation, as defined in~\cref{def:presentation}, the relation needs to be on the
set of words $A + A$, where the right copy corresponds to the set of formal inverses of the generators. The following
proposition lets us lift a group structure on $\List[A]$ to a group presentation.

\begin{propositionrep}
  \label{prop:generated-group-generalised}
  Given a set $A$ and a congruence relation $R$ on $\List[A]$ with the group structure given by append and reversal,
  there is a generated group structure $F(\langle A ; \liftrel{R} \rangle)$, where $\liftrel{R}$ is the relation $R$
  lifted to $\List[A+A]$ along the codiagonal map $\nabla_{A} : A + A \to A$.
\end{propositionrep}

\begin{proof}
  Let $G$ be the group on $\List[A]$. We construct the group homomorphism from $F(\langle A ; \liftrel{R} \rangle)$ to
  $G$ using the universal property of the group presentation, where the map on generators is given by taking the
  singleton list. To construct the group homomorphism from $G$, we use the universal property of the set quotient, where
  the map on the underlying set is given by mapping $\inl$ on the list. Using that the relation is a congruence, we show
  that this consttitutes a group isomorphism.
\end{proof}

\begin{corollary}
  The group $\Sn$ is isomorphic to the group presentation given by ${F(\langle \Fin[n] ; \liftrel{\cox*} \rangle)}$.
\end{corollary}

\noindent To decide if two words in $\List[\Fin[n]]$ are $\cox*$-equal, we simply have to compute their normal forms using
$\normf$. They correspond to the same permutation if and only if these normal forms are equal, which is decidable for
$\List[\Fin[n]]$.

\subsection{Lehmer Codes}
\label{subsec:lehmer}

To prove the equivalence between $\Aut[\Fin[n]]$ and $\Sn[n]$, we will need to define functions back and forth between
the two types. The terms in $\Sn$ can be identified with equivalence classes of terms in $\List[\Fin[n]]$ with respect
to the Coxeter relation $\cox*$. The easiest way to define a function out of this presentation is to define it on the
representatives. We know that these are the unique normal forms in the set-quotient given by $\quotinc \comp \normf$,
but now we will explicitly describe what these representatives look like, using an encoding called Lehmer
codes~\cite{lehmerTeachingCombinatorialTricks1960}.

Lehmer codes are known in Combinatorial Analysis~\cite{bellmanCombinatorialAnalysis1960} where they are sometimes called
"subexcedant sequences", or "factoriadics". They can be written as a decimal number in the factorial number system, or
as a tuple encoding the digits~\cite*{knuthArtComputerProgramming1997,laisantNumerationFactorielleApplication1888}. This
gives a convenient way of representing permutations on a computer, partly because they are
bitwise-optimal~\cite{bergerTeachingOrdinalPatterns2019a}.

Formally, we define $\Lehmer[n]$ to be an $n+1$-element tuple, where the position $k \leq n$ stores an element of
$\Fin[k]$. Since the 0-th position is trivial, in practice it is
ignored~\cite{duboisTestsProofsCustom2018,vajnovszkiNewEulerMahonian2011}.

\begin{definition}[$\Lehmer : \Nat \to \UU$]
  \begin{align*}
    \Lehmer[\zero]   & \defeq \Fin[\suc[\zero]]                     \\
    \Lehmer[\suc[n]] & \defeq \Lehmer[n] \times \Fin[\suc[\suc[n]]]
  \end{align*}
  % \begin{aligned}
  %   \lzero & : \Lehmer[\zero]                                                     \\
  %   \lsuc  & : \forall n, r, (r \leq \suc[n]) \to \Lehmer[n] \to \Lehmer[\suc[n]]
  % \end{aligned}
\end{definition}

The inversion count of an element is the number of smaller elements appearing after it in the permutation.

\begin{definition}[Inversion count]
  Given a permutation $\sigma : \Aut[\Fin[n]]$, the inversion count of an element $i: \Fin[n]$ is given by
  \[ \invcount{i} \defeq \#\Set{j < i | \sigma(j) > \sigma(i)}. \]
\end{definition}

Knowing the inversion counts for all the elements, one can reconstruct the starting permutation. Also, observe that
$\invcount{i} < i$, thus fitting in the $i$-th place of a Lehmer code tuple. As an example, consider the following
tabulated presentation of a permutation of $\Fin[5]$.
\[
  \sigma \defeq
  \begin{pmatrix}
    0      & 1      & 2      & 3      & 4      \\
    \el{2} & \el{1} & \el{4} & \el{0} & \el{3} \\
  \end{pmatrix}
\]

% The inversion count for $\el{0}$ is 0 (because there are no smaller elements at all), for $\el{1}$ is 1 (because of
% $\el{0}$ appearing after), for $\el{2}$ is 2 (because of $\el{0}$ and $\el{1}$), for $\el{3}$ is 0 (because it comes
% last in the sequence), and for $\el{4}$ is 2 (because of $\el{3}$ and $\el{0}$).

\noindent The Lehmer code for the permutation $\sigma$ is then the 5-tuple
\[
  l \equiv (\invcount{0}, \invcount{1}, \invcount{2}, \invcount{3}, \invcount{4}) \equiv (0, 1, 2, 0, 2)
\]

\noindent To decode the permutation back from this Lehmer code, we perform an algorithm similar to \emph{insertion
  sort}. The element of the Lehmer code being currently processed is highlighted in the left column of the table below.
Starting from a sorted list, the element at index $k$ has to be given $l[k]$ inversions. Because of the invariant
that all the elements before newly processed one are smaller than it, the proper number of inversions is created by
simply shifting the element $l[k]$ places left.

\begin{center}
  \begin{tabular}{l|r}
    (\highlight{{0}}, 1, 2, 0, 2) & $[\highlightAlt{\el{0}}, \el{1}, \el{2}, \el{3}, \el{4}]$ \\
    (0, \highlight{{1}}, 2, 0, 2) & $[\highlightAlt{\el{1}}, \el{0}, \el{2}, \el{3}, \el{4}]$ \\
    (0, 1, \highlight{{2}}, 0, 2) & $[\highlightAlt{\el{2}}, \el{1}, \el{0}, \el{3}, \el{4}]$ \\
    (0, 1, 2, \highlight{{0}}, 2) & $[\el{2}, \el{1}, \el{0}, \highlightAlt{\el{3}}, \el{4}]$ \\
    (0, 1, 2, 0, \highlight{{2}}) & $[\el{2}, \el{1}, \highlightAlt{\el{4}}, \el{0}, \el{3}]$ \\
  \end{tabular}
\end{center}

Writing formally, to turn a Lehmer code into a word in $\Sn$, we define a function $\immersion$. As described above, the
number $r$ at position $k$ in the tuple describes how many inversions the element $\el{k}$ has. Thus, we need to perform
$r$ many adjacent transpositions to get to the desired position, which is given by $(\suc[n] - r) \downf r$.

\begin{definition}[$\immersion : (n : \Nat) \to {\Lehmer[n]} \to {\List[\Fin[\suc[n]]]}$]
  \begin{align*}
    \immersion_{\zero}(\zero)    & \defeq \nil                                               \\
    \immersion_{\suc[n]}((r, l)) & \defeq \immersion_{n}(l) \append ((\suc[n] - r) \downf r)
  \end{align*}
\end{definition}

\noindent We can show that the function $\immersion_{n}$ gives an equivalence betweeen $\Lehmer[n]$ and $\im{\normf}$.

\begin{theoremrep}
  \leavevmode
  \begin{enumerate}
    \item For any Lehmer code $c$, $\immersion_{n}(c)$ is a normal form with respect to $\longcoxstar$, that is,
          $\immersion_{n}(c)$ is in $\im{\normf}$.
    \item Any element of $\im{\normf}$ can be constructed from a unique Lehmer code by $\immersion$, that is, the fibers
          of $\immersion_{n} : \Lehmer[n] \to {\im{\normf}}$ are contractible.
  \end{enumerate}
  Therefore, there is an equivalence between $\Lehmer[n]$ and $\im{\normf}$ (see~\cref{prop:three-chars-equiv}).
\end{theoremrep}

\begin{proof}
  For any code $c : \Lehmer[n]$, we have that
  \[
    \immersion_{n}(c) = (r_0 \downf k_0) \append (r_1 \downf k_1) \append \dots \append (r_{m-1} \downf k_{m-1})
  \]
  is a concatenation of $n \geq m \geq 0$ non-empty strictly decreasing lists. Reductions in $\longcox$ cannot happen
  inside any of the strictly decreasing $(r \downf k)$: $\longcancel$ requires repeating elements, $\longswap$ acts when
  consecutive numbers differ by at least 2, and $\longbraid$ acts on a non-monotone sequence. This leaves the case of
  reduction happening on a fragment that borders two (or more) subsequences. Again, $\longcancel$ requires two equal
  consecutive numbers, which would then have to be the last one in some $(r_i \downf k_i)$ sequence, and the first one
  in the next $(r_{i+1} \downf k_{i+1})$. But the first number in a sequence $(r_{i+1} \downf k_{i+1})$ is larger than
  every number in $(r_{i} \downf k_i)$ -- which also shows why $\longswap$ cannot happen. The remaining case of
  $\longbraid$ follows similarly, since its argument is a decreasing sequence followed immediately by a number equal to
  the first element of this sequence.
\end{proof}
% \jk{Review:}
% To see that Lehmer codes under $\immersion$ are normal with respect to $\longcoxstar$, let us look at the example code
% $c = (0, 1, 2, 3, 4)$ -- for the full proof, see accompanying Agda code. We have that
% \[
%   \immersion(c) = (0 \downf 1) \append (0 \downf 2) \append (0 \downf 3) \append (0 \downf 4) = [0, 1, 0, 2, 1, 0, 3, 2, 1, 0]
% \]
% is concatenation of four decreasing lists . Where could a reduction happen?

% First, it can't happen inside any of the strictly decreasing $(n \downf k)$: $\longcancel$ requires repeating elements,
% $\longswap$ acts when consecutive numbers differ by at least 2, and $\longbraid$ acts on a non-monotone
% sequence. This leaves the case of reduction happening on a fragment that borders two (or more) subsequences. Again,
% $\longcancel$ requires two equal consecutive numbers, which would then have to be the last one in some $(0 \downf k)$
% sequence, and the first one in the next $(0 \downf \suc[k])$. But the first number in a sequence $(0 \downf \suc[k])$ is
% larger than every number in $(0 \downf k)$ -- which also shows why $\longswap$ cannot happen. The remaining case of
% $\longbraid$ follows similarly, since its argument is a decreasing sequence followed immediately by a number equal to
% the first element of the list.

% We also established an equivalence between $\im{\normf}$ and $\Sn$, which gives the following.
\begin{corollary}
  \label{prop:sn-im-lehmer-equiv}
  For all $n : \Nat$, \( \Sn \eqv \im{\normf} \eqv \Lehmer[n] \).
\end{corollary}

\subsection{Running Lehmer codes}

Finally, it is time to complete our goal of characterising the permutation groups. Having produced a Lehmer code by
normalising words in $\Sn$, we need to run it to produce a concrete bijection of finite sets, and, given a bijection
between finite sets, we need to encode it as a Lehmer code. We will prove that these maps construct an equivalence
between the types $\Lehmer[n]$ and $\Aut[\Fin[\suc[n]]]$~\footnote{Note that the indices for the type of permutations
  are off-by-one, because we chose $\Fin[n]$ to represent generators for permutations on $\Fin[\suc[n]]$.}. The idea for
this proof is borrowed from~\citet{Molzer-cubical}.

\begin{definition}[${\FinExcept{n}} : {\Fin[n]} \to \UU$]
  For $n : \Nat$, the type family $\FinExcept{n}$ picks out all elements in $\Fin[n]$ except the one in the argument.
  \[
    \FinExcept{n}[i] \defeq \dsum*{j : \Fin[n]}{i \neq j}
  \]
\end{definition}

\noindent Note that $\FinExcept{n}[i]$ for $i : \Fin[n]$ is a subtype of $\Fin[n]$ and is hence a set. We state and
prove a few auxiliary lemmas about how $\FinExcept{n}$ interacts with $\Fin$ -- these are obtained by counting arguments
using the fact that $\Fin[n]$ and $\FinExcept{n}$ both have decidable equality.

\begin{lemmarep}
  \label{prop:fin-finexcept}
  \leavevmode
  \begin{enumerate}
    % \item For any $k : \Fin[n]$, $\unit \sqcup \FinExcept{n}[k] \eqv \Fin[n]$. \label{prop:fin-finexcept-1}
    \item For any $k : \Fin[\suc[n]]$, we have $\FinExcept{\suc[n]}[k] \eqv \Fin[n]$. \label{prop:fin-finexcept-2}
    \item For any $n : \Nat$, we have \( \Aut[\Fin[\suc[n]]] \eqv \dsum*{k : \Fin[\suc[n]]}{(\FinExcept{\suc[n]}[n] \eqv
            \FinExcept{\suc[n]}[n - k])} \). \label{prop:fin-finexcept-3}
  \end{enumerate}
\end{lemmarep}

\begin{proof}
  The first and second propositions follow from simply constructing the bijections using the decidable equality of
  $\Fin[n]$, and making sure to punch-in and punch-out the element $k$ at the right place.

  The third proposition performs some combinatorial tricks. On the left, we have the type of automorphisms of
  $\Fin[\suc[n]]$. Assume a particular $\sigma : \Fin[\suc[n]] \xrightarrow{\sim} \Fin[\suc[n]]$. Pick $k$ to be the
  inversion count of $n$, the largest element in $\Fin[\suc[n]]$. Then, the image of $n$ under $\phi$ has to be $n - k$,
  since all other elements in the set are smaller. Removing those two from the domain and codomain of $\phi$, the rest
  of the elements are fixed by $\sigma$, so we compute the bijection between the rest of the elements.

  For the other direction, if we are given a $k$ and a bijection $\pi$ between $\FinExcept{\suc[n]}[n]$ and
  $\FinExcept{\suc[n]}[n - k]$, we can extend $\pi$ to $\sigma : \Fin[\suc[n]] \eqv \Fin[\suc[n]]$ by inserting the
  element $n$ at the position $n - k$, resulting in the element $n$ having inversion count $k$.
\end{proof}

\noindent Using these facts, we can now prove the main result of this section.

\begin{theorem}
  \label{prop:lehmer-aut-equiv}
  For all $n:\Nat$, \( \Lehmer[n] \eqv \Aut[\Fin[\suc[n]]] \).
\end{theorem}

\begin{proof}
  For $n = \zero$, note that $\Lehmer[\zero]$ is contractible, and so is $\Aut[\Fin[\suc[\zero]]]$, hence we have that
  ${\Lehmer[\zero] \eqv \unit \eqv \Aut[\Fin[\suc[\zero]]]}$. For $n = \suc[m]$, we compute the following chain of equivalences.
  \[
    \arraycolsep=0.5em\def\arraystretch{1.3}
    \begin{array}{rlr}
           & \Lehmer[\suc[m]]                                                                                    &                                                                     \\
      \eqv & \Fin[\suc[\suc[m]]] \times \Lehmer[m]                                                               & \text{by definition}                                                \\
      \eqv & \Fin[\suc[\suc[m]]] \times \Aut[\Fin[\suc[m]]]                                                      & \text{induction hypothesis}                                         \\
      \eqv & \dsum*{k : \Fin[\suc[\suc[m]]]}{\Fin[\suc[m]] \eqv \Fin[\suc[m]]}                                   & \text{$\Sigma$ over a constant family}                              \\
      \eqv & \dsum*{k : \Fin[\suc[\suc[m]]]}{\FinExcept{\suc[\suc[m]]}[m] \eqv \Fin[\suc[m]]}                    & \text{by~\cref{prop:fin-finexcept}~part~\ref{prop:fin-finexcept-2}} \\
      \eqv & \dsum*{k : \Fin[\suc[\suc[m]]]}{\FinExcept{\suc[\suc[m]]}[m] \eqv \FinExcept{\suc[\suc[m]]}[m - k]} & \text{by~\cref{prop:fin-finexcept}~part~\ref{prop:fin-finexcept-2}} \\
      \eqv & \Aut[\Fin[\suc[\suc[m]]]]                                                                           & \text{by~\cref{prop:fin-finexcept}~part~\ref{prop:fin-finexcept-3}}
    \end{array}
  \]
\end{proof}

\noindent By composing~\cref{prop:lehmer-aut-equiv} and~\cref{prop:sn-im-lehmer-equiv}, we obtain the final equivalence.

\begin{corollary}
  \label{prop:sn-lehmer-fin-equiv}
  For all $n : \Nat$,
  \(
  \Sn \eqv \Lehmer[n] \eqv \Aut[\Fin[\suc[n]]]
  \).
\end{corollary}

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "main"
%%% fill-column: 120
%%% End:
