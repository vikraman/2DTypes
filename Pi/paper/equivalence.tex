\section{Correspondence between \texorpdfstring{$\PiLang$}{Pi} and \texorpdfstring{$\UFin$}{UFin}}
\label{sec:equivalence}

In this section, we first translate $\PiLang$ to its additive fragment $\PiPlusLang$. This is the language that we
interpret to $\UFin$ and back, using the tools developed in the previous sections. Further, we go through an
intermediate step of the language $\PiHatLang$, which is a simplified variant of $\PiPlusLang$ that uses adjacent
transpositions for combinators, while preserving all the required structure.

% https://q.uiver.app/?q=WzAsNCxbMCwwLCJcXFBpTGFuZyJdLFsyLDAsIlxcUGlQbHVzTGFuZyJdLFs0LDAsIlxcUGlIYXRMYW5nIl0sWzYsMCwiXFxVRmluIl0sWzAsMSwiXFxldmFsdCJdLFsxLDIsIlxcZXZhbGgiLDAseyJjdXJ2ZSI6LTR9XSxbMiwzLCJcXGV2YWx0IiwwLHsiY3VydmUiOi00fV0sWzIsMSwiXFxxdW90ZWgiLDAseyJjdXJ2ZSI6LTR9XSxbMywyLCJcXHF1b3RldCIsMCx7ImN1cnZlIjotNH1dXQ==
\[\begin{tikzcd}
    \PiLang && \PiPlusLang && \PiHatLang && \UFin
    \arrow["\evalt", from=1-1, to=1-3]
    \arrow["\evalp", curve={height=-24pt}, from=1-3, to=1-5]
    \arrow["\evalh", curve={height=-24pt}, from=1-5, to=1-7]
    \arrow["\quotep", curve={height=-24pt}, from=1-5, to=1-3]
    \arrow["\quoteh", curve={height=-24pt}, from=1-7, to=1-5]
  \end{tikzcd}\]

We present the types and 1-combinators of $\PiPlusLang$ and $\PiHatLang$ in~\cref*{fig:piplus,fig:pihat} respectively,
eliding the 2-combinators for brevity. We enforce that there is a unique 2-combinator between compatible 1-combinators,
by relating them with a truncation. These can be found in~\cref{app:leveltwo} and in the accompanying Agda code.

The translations between the languages are defined separately on types, 1-combinators, and 2-combinators. Following the
terminology of Normalisation by Evaluation (NbE), the translations from the left to the right, going from the syntax
towards the semantics, are called $\evalt$ and the translations the other way are called $\quotet$.

To state our results formally, we organise the syntax for each language using its syntactic category. We define them
formally in the appendix, and only state our results here. For each of the $\PiLang$, $\PiPlusLang$ and $\PiHatLang$
languages, their syntactic categories, respectively $\PiCat$, $\PiPlusCat$ and $\PiHatCat$, have 0-cells for types ($U$,
$\UPlus$, and $\UHat$), 1-cells for 1-combinators ($\iso$, $\isop$, and $\isoh$), and 2-cells for 2-combinators ($\Iso$,
$\Isop$, and $\Isoh$). These syntactic categories here are actually $(2,0)$-categories, since all the 1-cells and
2-cells are invertible. They are also locally-strict, or locally-posetal, because there is at most one 2-cell between
compatible 1-cells.

\begin{toappendix}
  \begin{proposition}
    We can form a weak 2-category $\PiCat$ with
    \begin{itemize}
      \item $\PiLang$ types ($U$) for 0-cells,
      \item for $X, Y : U$, a collection of 1-cells $X \iso Y$,
      \item for $p, q : X \iso Y$, a collection of 2-cells $p \Iso q$.
    \end{itemize}
  \end{proposition}

  \begin{proposition}
    We can form a weak 2-category $\PiPlusCat$ with
    \begin{itemize}
      \item $\PiPlusLang$ types ($\UPlus$) for 0-cells,
      \item for $X, Y : \UPlus$, a collection of 1-cells $X \isop Y$,
      \item for $p, q : X \isop Y$, a collection of 2-cells $p \Isop q$.
    \end{itemize}
  \end{proposition}

  \begin{proposition}
    We can form a weak 2-category $\PiHatCat$ with
    \begin{itemize}
      \item $\PiHatCat$ types ($\UHat$) for 0-cells,
      \item for $X, Y : \UHat$, a collection of 1-cells $X \isoh Y$,
      \item for $p, q : X \isoh Y$, a collection of 2-cells $p \Isoh q$.
    \end{itemize}
  \end{proposition}
\end{toappendix}

We use the $\evalt/\quotet$ translation maps to construct functors between these categories. We only name the maps on
the 0, 1, and 2-cells -- the coherences hold by definition or by calculation, which is shown in our accompanying Agda
code. We use these functors to state our results establishing the equivalences between the languages.

\subsection{$\PiLang$ to $\PiPlusLang$}

First, we show how to translate $\PiLang$ programs to $\PiPlusLang$, which is the additive fragment of $\PiLang$. The
syntax for 1-combinators is given in~\cref{fig:piplus}.

\begin{figure}[t]
  {\scalebox{\scalef}{$
        \begin{array}{rrcll}
          \idc :     & A           & \isop & A           & : \idc     \\
          \identlp : & \zerot + A  & \isop & A           & : \identrp \\
          \swapp :   & A + B       & \isop & B + A       & : \swapp   \\
          \assoclp : & A + (B + C) & \isop & (A + B) + C & : \assocrp \\ [1.5ex]
        \end{array}$}}

  {\scalebox{\scalef}{
      \Rule{}
      {\jdg{}{}{c_1 : A \isop B} \quad \vdash c_2 : B \isop C}
      {\jdg{}{}{c_1 \circledcirc c_2 : A \isop C}}
      {}

      \Rule{}
      {\jdg{}{}{c_1 : A \isop B} \quad \vdash c_2 : C \isop D}
      {\jdg{}{}{c_1 \oplus c_2 : A + C \isop B + D}}
      {}
    }}
  \caption{$\PiPlusLang$ syntax}
  \label{fig:piplus}
\end{figure}

$\PiLang$ has two 0-ary type constructors, and two binary type constructors -- the additive tensor product and the
multiplicative one. $\PiPlusLang$ has all the type constructors of $\PiLang$ except multiplication. However, we will
show how to recover the multiplicative structure, by defining multiplication as repeated addition. We encode $\times$ in
terms of $+$ as follows.

\begin{definition}[$\times : \UPlus \to \UPlus \to \UPlus$]
  \begin{align*}
    \zerot \times Y      & \defeq \zerot                      \\
    \onet \times Y       & \defeq Y                           \\
    (X_1 + X_2) \times Y & \defeq X_1 \times Y + X_2 \times Y
  \end{align*}
\end{definition}

\begin{lemma}
  There are two symmetric monoidal structures on $\PiPlusCat$, given by $(\zerot, +)$ and $(\onet, \times)$, with
  $\times$ distributing over $+$, giving it a rig structure.
\end{lemma}

\noindent Using this rig structure, we translate $\PiLang$ to $\PiPlusLang$, constructing a rig equivalence from
$\PiCat$ to $\PiPlusCat$.

\begin{definition}[$\evalt$]
  \begin{align*}
    \evalt_{0} & : U \to \UPlus                                             \\
    \evalt_{1} & : (c : X \iso Y) \to \evalt_{0}(X) \iso \evalt_{0}(Y)      \\
    \evalt_{2} & : (\alpha : p \Iso q) \to \evalt_{1}(p) \Iso \evalt_{1}(q)
  \end{align*}
\end{definition}

\begin{theorem}
  $\evalt$ gives a rig equivalence between $\PiCat$ and $\PiPlusCat$.
\end{theorem}

\subsection{$\PiPlusLang$ to $\PiHatLang$}

Next, we show how to translate $\PiPlusLang$ programs to $\PiHatLang$ and back. $\PiHatLang$ is a simplified variant of
$\PiPlusLang$, with (unary) natural numbers for 0-cells, 1-combinators generated by adjacent transpositions, and an
appropriate set of 2-combinators. We give the syntax, again omitting 2-combinators, in~\cref{fig:pihat}.

\begin{figure}[t]
  {\scalebox{\scalef}{$
        \begin{array}{rrcll}
          \idc :   & n             & \isoh & n             & : \idc   \\
          \swapc : & \suc[\suc[n]] & \isoh & \suc[\suc[n]] & : \swapc \\[1.5ex]
        \end{array}
      $}}

  {\scalebox{\scalef}{
      \Rule{}
      {\jdg{}{}{c_1 : n \isoh m} \quad \vdash c_2 : m \isoh o}
      {\jdg{}{}{c_1 \circledcirc c_2 : n \isoh o}}
      {}

      \Rule{}
      {\jdg{}{}{c : n \isoh m}}
      {\jdg{}{}{\oplus(c) : \suc[n] \isoh \suc[m]}}
      {}
    }}
  \caption{$\PiHatLang$ syntax}
  \label{fig:pihat}
\end{figure}

As described, $\PiHatLang$ doesn't have a tensor product, but we can build it simply by adding up natural numbers, and,
we need to verify that this indeed equips $\PiHatCat$ with a symmetric monoidal structure. Since each object is a
natural number, this makes $\PiHatCat$ a \emph{PROP}, that is, a products and permutations category.

To produce a braiding $n + m \isoh m + n$ from adjacent transpositions, we recursively traverse the left subexpression,
swapping each element using adjacent transpositions along the elements on the right, placing it in the correct position.
The computational content of this translation can be visualised using tree transformations, for the recursive case
in~\cref{fig:plusplusswap}. The challenging part is showing that these moves are coherent with respect to 2-combinators.

\begin{figure}
   \[
      \Tree [ [ {\tiny 1} {\tiny n} ] {\tiny m} ] ~\xrightarrow{}~
      \Tree [ {\tiny 1} [ {\tiny n} {\tiny m} ] ] ~\xrightarrow{}~
      \Tree [ [ {\tiny n} {\tiny m} ] {\tiny 1} ] ~\xrightarrow{}~
      \Tree [ [ {\tiny m} {\tiny n} ] {\tiny 1} ] ~\xrightarrow{}~
      \Tree [ {\tiny m} [ {\tiny n} {\tiny 1} ] ] ~\xrightarrow{}~
      \Tree [ {\tiny m} [ {\tiny 1} {\tiny n} ] ] ~
    \]
    \caption{Braiding from transpositions, recursive case}
    \label{fig:plusplusswap}
\end{figure}

\begin{lemma}
  $\PiHatCat$ has a symmetric monoidal structure, with the unit given by 0 and the tensor product given by natural
  number addition.
\end{lemma}

\noindent Using this symmetric monoidal structure, we translate from $\PiPlusLang$ to $\PiHatLang$.

\begin{definition}[$\evalp$]
  \begin{align*}
    \evalp_{0} & : \UPlus \to \UHat                                                           \\
    \evalp_{1} & : (c : t_{1} \isop t_{2}) \to \evalp_{0}(t_{1}) \isoh \evalp_{0}(t_{2})      \\
    \evalp_{2} & : (\alpha : c_{1} \Isop c_{2}) \to \evalp_{1}(c_{1}) \Isoh \evalp_{1}(c_{2})
  \end{align*}
\end{definition}

To go back from $\PiHatLang$ to $\PiPlusLang$, we turn a natural number into a $\PiPlusLang$ type, using right-biased
addition, that is, the natural number $n$ gets mapped to the type $\onet + (\onet + (\onet + \ldots + \zerot))$. Since
the types are already right-biased, an adjacent transposition in $\PiHatLang$ is easily encoded by using the braiding in
$\PiPlusLang$, as shown in~\cref{fig:transpfrombraid}. Again, these are shown to be coherent.

\begin{figure}
  \[
    \Tree [ {\tiny $\onet$} [ {\tiny $\onet$} {\tiny X} ] ] ~\xrightarrow{\assoclp}~
    \Tree [ [ {\tiny $\onet$} {\tiny $\onet$} ] {\tiny X} ] ~\xrightarrow[\swapp\phantom{xx}]{\phantom{xx}\idc}~
    \Tree [ [ {\tiny $\onet$} {\tiny $\onet$} ] {\tiny X} ] ~\xrightarrow{\assocrp}~
    \Tree [ {\tiny $\onet$} [ {\tiny $\onet$} {\tiny X} ] ] ~
  \]
  \caption{Transpositions from braiding}
  \label{fig:transpfrombraid}
\end{figure}

\begin{definition}[$\quotep$]
  \begin{align*}
    \quotep_{0} & : \UHat \to \UPlus                                                            \\
    \quotep_{1} & : (p : X_{1} \isoh X_{2}) \to \quotep_{0}(X_{1}) \iso \quotep_{0}(X_{2})      \\
    \quotep_{2} & : (\alpha : p_{1} \Isoh p_{2}) \to \quotep_{1}(p_{1}) \Iso \quotep_{1}(p_{2})
  \end{align*}
\end{definition}

\begin{theorem}
  $\evalp/\quotep$ give a symmetric monoidal equivalence between $\PiPlusCat$ and $\PiHatCat$.
\end{theorem}

\subsection{$\PiHatLang$ to $\UFin$}

Finally, we show how to interpret $\PiHatLang$ to $\UFin$, and back from $\UFin$ to $\PiHatLang$. Types in $\PiHatLang$
are interpreted as 0-cells in $\UFin$, that is, a natural number $n$ is mapped to $\Fin[n]$. The 1-combinators in
$\PiHatLang$ are mapped to 1-paths in $\UFin$, that is, 1-loops in each connected component, equivalent to
$\Aut[\Fin[n]]$. In $\PiHatLang$, the 1-combinators are generated by adjacent transpositions, so these can be mapped to
words in $\Sn$ and then to automorphisms using~\cref{prop:sn-lehmer-fin-equiv}. Finally, 2-combinators are mapped to
2-paths between loops in $\UFin$.

\begin{definition}[$\evalh$]
  \label{def:evalh}
  \begin{align*}
    \evalh_{0} & : \UHat \to \UFin                                                          \\
    \evalh_{1} & : (c : t_{1} \isoh t_{2}) \to \evalh_{0}(t_{1}) \id \evalh_{0}(t_{2})      \\
    \evalh_{2} & : (\alpha : c_{1} \Isoh c_{2}) \to \evalh_{1}(c_{1}) \id \evalh_{1}(c_{2})
  \end{align*}
\end{definition}

\noindent 0-cells in $\UFin$ are mapped to their cardinalities in $\PiHatLang$, 1-loops are decoded to words in $\Sn$ to
generate a sequence of adjacent transpositions, producing a 1-combinator in $\PiHatLang$. Finally, 2-paths are quoted
back to 2-combinators in $\PiHatLang$.

\begin{definition}[$\quoteh$]
  \begin{align*}
    \quoteh_{0} & : \UFin \to \UHat                                                            \\
    \quoteh_{1} & : (p : X_{1} \id X_{2}) \to \quoteh_{0}(X_{1}) \isoh \quoteh_{0}(X_{2})      \\
    \quoteh_{2} & : (\alpha : p_{1} \id p_{2}) \to \quoteh_{1}(p_{1}) \Isoh \quotet_{1}(p_{2})
  \end{align*}
\end{definition}

% $\UFin$ as a 1-groupoid, is a (locally strict) weak $(2,0)$-category, and we use this to state our final equivalence.

\begin{theorem}
  $\evalh/\quoteh$ give a symmetric monoidal equivalence between $\PiHatCat$ and $\UFin$.
\end{theorem}

The semantics that we presented here takes a different route to constructing the permutation from a $\PiLang$
combinator, compared to the direct interpretation given using the big-step interpreter in~\cref{subsec:denotational}. We
verify that the two semantics agree, establishing that the semantics is adequate and fully abstract.

\begin{definition}[${\gdenot{\blank}}$]
  \begin{gather*}
    \begin{aligned}
      \gdenot{\blank}_{0} & : U \to \UFin                                       \\
      \gdenot{\blank}_{0} & \defeq \evalh_{0} \comp \evalp_{0} \comp \evalt_{0}
    \end{aligned}
    \qquad
    \begin{aligned}
      \gdenot{\blank}_{1} & : (c : X \iso Y) \to \gdenot{X}_{0} \id_{\UFin} \gdenot{Y}_{0} \\
      \gdenot{\blank}_{1} & \defeq \evalh_{1} \comp \evalp_{1} \comp \evalt_{1}
    \end{aligned}
  \end{gather*}
\end{definition}

\begin{theorem}[Full Abstraction and Adequacy]
  For any $c_1, c_2 : X \iso Y$, we have that
  \[
    \denot{c_1} = \denot{c_2} \text{ if and only if } \gdenot{c_1}_{1} = \gdenot{c_2}_{1}
  \]
\end{theorem}

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "main"
%%% fill-column: 120
%%% End:
