\documentclass[format=acmlarge,review,natbib]{acmart}

% \usepackage{fdsymbol}
\usepackage{bbold}
\usepackage{bussproofs}
\usepackage{keystroke}
\usepackage{comment}

%% \usepackage{hyphenat}
%% \usepackage{color}
%% \usepackage{url}
%% \usepackage{amssymb}
%% \usepackage{amsmath}
%% \usepackage{mdwtab}
%% \usepackage{mdwlist}
%% \usepackage{listings}
%% \lstMakeShortInline[columns=fullflexible]|
%% \lstnewenvironment{code}{\lstset{basicstyle={\sffamily\footnotesize}}}{}

\newcommand{\unitepl}{\texttt{unitepl}}
\newcommand{\unitipl}{\texttt{unitipl}}
\newcommand{\unitepr}{\texttt{unitepr}}
\newcommand{\unitipr}{\texttt{unitipr}}
\newcommand{\swap}{\texttt{swap}}
\newcommand{\swapp}{\texttt{swapp}}
\newcommand{\assoclp}{\texttt{assoclp}}
\newcommand{\assocrp}{\texttt{assocrp}}
\newcommand{\unitetl}{\texttt{unitetl}}
\newcommand{\unititl}{\texttt{unititl}}
\newcommand{\unitetr}{\texttt{unitetr}}
\newcommand{\unititr}{\texttt{unititr}}
\newcommand{\swapt}{\texttt{swapt}}
\newcommand{\assoclt}{\texttt{assoclt}}
\newcommand{\assocrt}{\texttt{assocrt}}
\newcommand{\absorbr}{\texttt{absorbr}}
\newcommand{\absorbl}{\texttt{absorbl}}
\newcommand{\factorzr}{\texttt{factorzr}}
\newcommand{\factorzl}{\texttt{factorzl}}
\newcommand{\factor}{\texttt{factor}}
\newcommand{\distl}{\texttt{distl}}
\newcommand{\dist}{\texttt{dist}}
\newcommand{\factorl}{\texttt{factorl}}
\newcommand{\id}{\texttt{id}}
\newcommand{\compc}[2]{#1 \circ #2}
\newcommand{\compcc}[2]{#1 \bullet #2}
\newcommand{\respcomp}[2]{#1 \odot #2}

\newcommand{\alt}{~\mid~}
\newcommand{\patht}[1]{\textsc{PATHS}(#1,#1)}
\newcommand{\fpatht}[1]{\textsc{FREEPATHS}(#1,\Box)}
\newcommand{\fpathp}[2]{\textsc{freepath}~#1~#2}
\newcommand{\pathind}[2]{\textsc{pathind}~#1~#2}
\newcommand{\invc}[1]{!\;#1}
\newcommand{\evalone}[2]{eval(#1,#2)}
\newcommand{\evalbone}[2]{evalB(#1,#2)}
\newcommand{\reflp}{\textsc{refl}}
\newcommand{\reflh}{\mathit{refl}_{\sim}}
\newcommand{\symh}[1]{\mathit{sym}_{\sim}~#1}
\newcommand{\transh}[2]{\mathit{trans}_{\sim}~#1~#2}
\newcommand{\reflq}{\mathit{refl}_{\simeq}}
\newcommand{\symq}[1]{\mathit{sym}_{\simeq}~#1}
\newcommand{\transq}[2]{\mathit{trans}_{\simeq}~#1~#2}
\newcommand{\isequiv}[1]{\mathit{isequiv}(#1)}
\newcommand{\idc}{\mathit{id}_{\boolt}}
\newcommand{\swapc}{\mathit{swap}_{\boolt}}
\newcommand{\assocc}{\mathit{assoc}}
\newcommand{\invl}{\mathit{invl}}
\newcommand{\invr}{\mathit{invr}}
\newcommand{\invinv}{\mathit{inv}^2}
\newcommand{\idlc}{\mathit{idl}}
\newcommand{\idrc}{\mathit{idr}}
\newcommand{\swapswap}{\swapc^2}
\newcommand{\compsim}{\compc_{\isotwo}}
\newcommand{\iso}{\leftrightarrow}
\newcommand{\isotwo}{\Leftrightarrow}
\newcommand{\piso}{\multimapdotbothB~~}
\newcommand{\zt}{\mathbb{0}}
\newcommand{\ot}{\mathbb{1}}
\newcommand{\fc}{\mathit{false}}
\newcommand{\tc}{\mathit{true}}
\newcommand{\boolt}{\mathbb{B}}
\newcommand{\univ}{\mathcal{U}}
\newcommand{\uzero}{\mathcal{U}_0}
\newcommand{\uone}{\mathcal{U}_1}
\newcommand{\Rule}[2]{
\makebox{
$\displaystyle
\frac{\begin{array}{l}#1\\\end{array}}
{\begin{array}{l}#2\\\end{array}}$}}
\newcommand{\proves}{\vdash}
\newcommand{\jdgg}[3]{#1 \proves #2 : #3}
\newcommand{\jdg}[2]{\proves #1 : #2}
\newcommand{\jdge}[3]{\proves #1 = #2 : #3}
%% codes
%% denotations

\newcommand{\amr}[1]{\fbox{\begin{minipage}{0.8\textwidth}\color{red}{Amr says: {#1}}\end{minipage}}}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{document}

\title{Univalent Universes and Completness of Reversible Programs}

\author{X}
\affiliation{
  \institution{Y}
  \country{Z}}
\email{A@B.C}

\begin{abstract}
\end{abstract}

\maketitle

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Story and Conjecture}

There is a cottage industry of reversible programming languages, reversible logic, programming applications of type isomorphisms, etc. This work seems it should be connected to HoTT and univalence but there aren't any precise connections or theorems.

Our conjecture:

\begin{itemize}
\item Let $\mathcal{U}$ be the univalent subuniverse generated by $0$, $1$, $+$, and $*$ suitably 1-truncated.
\item Let $\Pi$ be the previously  described reversible programming with 1-paths and 2-paths
\item We conjecture that $\Pi$ includes codes for \emph{all} paths in $\mathcal{U}$
\end{itemize}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{The Bool Case}

To get started let's look at the case of $\mathbb{2}$ instead of the entire set of finite types defined using $0$, $1$, $+$, and $*$.

%%%%%
\subsection{$\Pi$}

The restriction of $\Pi$ is the following:

\[\begin{array}{rcl}
\tau &::=& \mathbb{2} \\
\\
v &::=& \begin{array}[t]{lrcl}
                    & \fc &:& \mathbb{2} \\
              \alt & \tc &:& \mathbb{2}
               \end{array} \\
\\
c &::=& \begin{array}[t]{lrcl}
              & \id &:& \tau \iso \tau \\
               \alt & \swap &:& \mathbb{2} \iso \mathbb{2} \\
               \alt & \circ &:& (\tau_1 \iso \tau_2) \rightarrow (\tau_2 \iso \tau_3)
                              \rightarrow (\tau_1 \iso \tau_3)
               \end{array} \\
\\
! &:& (\tau_1 \iso \tau_2) \rightarrow (\tau_2 \iso \tau_1) \\
\invc{\id} &=& \id \\
\invc{\swap} &=& \swap \\
\invc{(\compc{c_1}{c_2})} &=& \compc{\invc{c_2}\;}{\;\invc{c_1}} \\
\\
\alpha &::=& \begin{array}[t]{lrcl}
               & \id &:& c \isotwo c \\
               \alt & \assocc &:& \compc{c_1}{(\compc{c_2}{c_3})} \isotwo
                                              \compc{(\compc{c_1}{c_2})}{c_3} \\
               \alt & \idlc &:& \compc{\id}{c} \isotwo c \\
               \alt & \idrc &:& \compc{c}{\id} \isotwo c \\
               \alt & \invl &:& \compc{c\;}{\;\invc{c}} \isotwo \id \\
               \alt & \invr &:& \compc{\invc{c}}{c} \isotwo \id \\
               \alt & \bullet &:& (c_1 \isotwo c_2) \rightarrow (c_2 \isotwo c_3)
                                            \rightarrow (c_1 \isotwo c_3) \\
               \alt & \odot &:& (c_1 \isotwo c_1') \rightarrow (c_2 \isotwo c_2')
                                            \rightarrow (\compc{c_1}{c_2} \isotwo \compc{c_1'}{c_2'}) \\
             \end{array}
\end{array}\]
The 2-combinators $\alpha$ also have inverses \ldots

%%%%%
\subsection{$\mathcal{U}$}

We assume an ambient univalent universe defined like in the HoTT book and including dependent pairs, a unit type, coproducts, identity types, and constants $\textsc{funext}$ and $\textsc{univalence}$. Our universe $\mathcal{U}$ is the subuniverse of this ambient universe defined as $\Sigma_{X:\mathbf{Type}} \| X \equiv \mathbb{2} \|_1$ where:

\begin{itemize}

\item $\Sigma$ is the type former for dependent pairs: it comes equipped with an introduction rule, an induction principle, and a computational rule.

\item $\mathbb{2}$ is the type of booleans which comes with the two points, an induction principle, and computational rules.

\item $\equiv$ is the identity type former which comes with $\reflp$, an induction principle $J$, and a computation rule.

\item $\| A \|_1$ is the 1-truncation of $A$ defined as follows: for all $x,y:A$ and $p,q : x \equiv y$ and $\alpha,\beta : p \equiv q$, we have $\alpha=\beta$.

\end{itemize}

%%%%%
\subsection{Equivalence}

Now we claim that $\mathcal{U}_\Pi$ is equivalent to $\mathcal{U}$ where $\mathcal{U}_\Pi$ is a universe which includes types $\tau$ as a points, combinators $c : \tau_1 \iso \tau_2$ as 1-paths, and 2-combinators $\alpha : c_1 \isotwo c_2$ as 2-paths.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%
\section{Generalizations}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\bibliographystyle{acm}
{\footnotesize
\bibliography{cites}
}
\end{document}
