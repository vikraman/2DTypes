\section{Introduction}~\label{sec:introduction}

\paragraph*{Synthesis of Reversible Core of Quantum Circuits.} Most current quantum algorithms start with generating superpositions, evolving them using a unitary transformation, and then projecting them with a measurement operator. The middle stage is essentially a reversible classical computation (executed in a quantum-parallel fashion). We illustrate that middle stage in detail by synthesizing a reversible circuit implementing boolean disjunction ($\vee$). Following~\citet{Toffoli:1980}, the first step is to write a specification for the desired reversible function:
\[
\mathit{reversibleOr}(h,b_1,b_2) ~=~ (h \,\underline{\vee}\, (b_1 \vee b_2), ~b_1, ~b_2)
\]
where $\underline{\vee}$ is the exclusive-or operation. From the definition of $\underline{\vee}$ it is evident that setting $h=0$, we can compute the desired disjunction by observing the first component of the result. The $\mathit{reversibleOr}$ function has the following truth table (in binary on the left and in a more convenient decimal notation on the right):

\begin{center}\begin{tabular}{|ccc|ccc|@{\qquad\qquad}|c|c|}
0 & 0 & 0 &     0 & 0 & 0     & 0 & 0 \\
0 & 0 & 1 &     1 & 0 & 1     & 1 & 5 \\
0 & 1 & 0 &     1 & 1 & 0    & 2 & 6 \\
0 & 1 & 1 &     1 & 1 & 1    & 3 & 7 \\
1 & 0 & 0 &     1 & 0 & 0    & 4 & 4 \\
1 & 0 & 1 &     0 & 0 & 1    & 5 & 1 \\
1 & 1 & 0 &     0 & 1 & 0    & 6 & 2 \\
1 & 1 & 1 &     0 & 1 & 1    & 7 & 3
\end{tabular}\end{center}

\noindent where it is evident that it is a bijective function, i.e., reversible.

The above embedding of an irreversible function into a reversible function with additional inputs and outputs is completely general and is the starting point for specifications of quantum circuits. The challenge is to synthesize a program / circuit from this specification. Of course, writing this program in a conventional (irreversible) language defeats the purpose. The challenge is to construct the desired program / circuit exclusively using reversible primitives, e.g., the standard set of universal reversible gates used in frameworks like Qiskit which consists of the computational gates \textsf{not} (boolean negation, called \verb|x|), \textsf{cnot} (conditional negation of the second input if the first is true; called \verb|cx|), and \textsf{toffoli} (conditional negation of the third input if both the first two inputs are true; called \verb|ccx|) gates, and the ability re-arrange the layout of wires. For concreteness, here is a possible implementation of the desired function in Qiskit:

\begin{center}
  \begin{minipage}[c]{0.4\linewidth}
\begin{verbatim}
reversibleOr.qasm:

  // setup
  ccx q[1], q[2], q[0];
  cx  q[1], q[0];
  cx  q[2], q[0];
  // measure

% ./qasm -t reversibleOr.qasm
+-------+-------+
| 0 0 0 | 0 0 0 |
| 0 0 1 | 1 0 1 |
| 0 1 0 | 1 1 0 |
| 0 1 1 | 1 1 1 |
| 1 0 0 | 1 0 0 |
| 1 0 1 | 0 0 1 |
| 1 1 0 | 0 1 0 |
| 1 1 1 | 0 1 1 |
+-------+-------+
  \end{verbatim}
  \end{minipage}
  \qquad
  \includegraphics[scale=0.7]{reversibleOr.png}
\end{center}

\noindent This implementation was manually produced using a standard synthesis algorithm for reversible
circuits~\cite{10.1145/775832.775915}. To gain some intuition, we trace the evaluation of the circuit for input
\verb|011|. In this context, the most significant bit is at index 0. Thus the first \verb|ccx| gate negates \verb|q[0]|
since both \verb|q[1]| and \verb|q[2]| are true producing \verb|111|; the following \verb|cx| gate produces \verb|011|; finally the last \verb|cx| produces the result \verb|111|.

There is wealth of manual and algorithmic approaches for such synthesis problems each optimizing along  different dimensions~\cite{XXX}. Here is the circuit produced using an approach that analyzes the recursive structure of the circuit (and would generalize to computing the disjunction of more than two inputs):

\begin{center}
  \begin{minipage}[c]{0.4\linewidth}
\begin{verbatim}
reversibleOr2.qasm:

  // setup
  cx  q[1], q[0];
  x   q[1];
  ccx q[1], q[2], q[0];
  x   q[1];
  // measure
  \end{verbatim}
  \end{minipage}
  \qquad
  \includegraphics[scale=0.7]{reversibleOr2.png}
\end{center}

\noindent The evaluation of this circuit prints the same truth table as above confirming their equivalence. Tracing the
evaluation on the same input value \verb|011| goes through the stages \verb|111|, \verb|101|, \verb|101|, and finally \verb|111|.

The situation for Shor's algorithm is just as described above but with a more involved function of the form $f(r) = a^{r} \mod N$ for fixed $a$ and $N$. The specification of the circuit is relatively straightforward to calculate. Here it is for $a=11$ and $N=15$:
\[\begin{array}{rcll}
g(r,h) &=& \left\{ \begin{array}{ll}
                     (r,h+1) & \mbox{when~$r$~even~and~$h$~even} \\
                     (r,h-1) & \mbox{when~$r$~even~and~$h$~odd} \\
                     (r,11-h) & \mbox{when~$r$~odd~and~$4 > h \geq 0$~or~$12 > h \geq 8$} \\
                     (r,19-h) & \mbox{when~$r$~odd~and~$8 > h \geq 4$~or~$16 > h \geq 12$}
                                \end{array}\right.
\end{array}\]

\noindent However, as explained in standard accounts of the algorithm (e.g., the Qiskit implementation), producing an efficient
modular exponentiation circuit from this specification  is not straightforward and is actually the bottleneck in Shorâ€™s algorithm. Typical
derivations of the circuit start from elementary gates, build a circuit for reversible disjunction and conjunction of
booleans, a circuit for a half-adder, a circuit for computing the carry, progressing to a circuit for modular addition,
which is used to build a circuit for modular multiplication, and then finally a circuit for modular exponentiation
taking care at each step to avoid the exponential blowup (e.g., by implementing exponentiation by squaring instead of repeated
multiplication)~\cite{shorefficient}.

\paragraph*{Our Technical Results.} The main result of the paper is a proof, formalized in the HoTT-Agda library, that
the category of finite sets and bijections is the free rig groupoid; its structure is illustrated diagrammatically below:

\[\begin{tikzcd}
    \PiLang && \PiPlusLang && \PiHatLang && \UFin
    \arrow["\evalt", from=1-1, to=1-3]
    \arrow["\evalp", curve={height=-24pt}, from=1-3, to=1-5]
    \arrow["\evalh", curve={height=-24pt}, from=1-5, to=1-7]
    \arrow["\quotep", curve={height=-24pt}, from=1-5, to=1-3]
    \arrow["\quoteh", curve={height=-24pt}, from=1-7, to=1-5]
  \end{tikzcd}\]

\noindent The nodes $\PiLang$, $\PiPlusLang$, and $\PiHatLang$ in the diagram each represent a syntactic weak 2-category
(groupoid actually as all morphisms are isomorphisms) where the 0-cells represent types, the 1-cells represent
reversible circuits, and the 2-cells represent circuit equivalences. In $\PiLang$, the circuits represent arbitrary
permutations among finite sets with products and coproducts; in $\PiPlusLang$, the circuits represent arbitrary
permutations among finite sets with only coproducts; and in $\PiHatLang$, the permutations are expressed using adjacent
transpositions.

The syntactic groupoid $\PiPlusLang$ is the free rig groupoid; $\UFin$ is the groupoid of finite sets and bijections
represented as the \emph{univalent subuniverse of all finite types}. The $\evalp/\quotep$ and $\evalh/\quoteh$ arrows establish a
\emph{symmetric monoidal biequivalence} between these two groupoids. To get a taste of the involved complexity of this
result, consider the obvious fact that, semantically, i.e., in $\UFin$, there is only one bijection
from the empty set to itself. However, in the free groupoid, there are an infinite number of isomorphisms from the empty
type to itself that go through arbitrary complex subtypes, e.g.,
$\zerot \isot \zerot \times A \isot \zerot \times (A + \zerot) \isot (\zerot \times A) + (\zerot \times \zerot) \isot
(\zerot \times \zerot) + (\zerot \times A) \isot \zerot + (\zerot \times A) \isot \zerot + \zerot \isot \zerot$, and all
such isomorphisms must be identified using appropriate coherence laws. The technical device to achieve this
normalization is as
follows. First, we observe that 1-paths in $\UFin$ are permutations on finite sets with a fixed cardinality $n$, given by $\Aut[\Fin[n]]$,
which produce the permutation group on $\Fin[n]$, or the symmetric group $\Sn$. By giving a presentation of $\Sn$ using
generators and relations, we build a rewriting system using the Coxeter relations~\cite{XXX} on the set of words $\List[\Fin[n]]$,
and show that it is (locally) confluent and strongly normalizing. We then establish that the symmetric group $\Sn$ is the
set-quotient of $\List[\Fin[n]]$ by the Coxeter relations, and show that it produces a group presentation, as a quotient
of the free group. Using this strongly normalizing rewriting system, we establish that normal forms for words in $\Sn$
are Lehmer codes~\cite{lehmerTeachingCombinatorialTricks1960}, which are a convenient and compact representation of
permutations. Finally, we show that there is an equivalence between Lehmer codes and permutations
$\Aut[\Fin[n]]$ given by the Lehmer encode-decode algorithm.

Below we reduce $\mathsf{swap} : 2 + 2 \leftrightarrow 2 + 2$ to a sequence of adjacent swaps. This is an example of
a translation from $\PiPlusLang$ to $\PiHatLang$.

\begin{align*}
  \begin{tikzpicture}[scale=0.4,every node/.style={scale=0.4}]
    \begin{knot}[clip width=3]
      \filldraw (0,4) circle (2pt) node[above] {0};
      \filldraw (1,4) circle (2pt) node[above] {1};
      \filldraw (2,4) circle (2pt) node[above] {2};
      \filldraw (3,4) circle (2pt) node[above] {3};
      \filldraw (0,0) circle (2pt) node[below] {2};
      \filldraw (1,0) circle (2pt) node[below] {3};
      \filldraw (2,0) circle (2pt) node[below] {0};
      \filldraw (3,0) circle (2pt) node[below] {1};
      \strand (0,4) .. controls (0.5,1.5) and (1.5,2.5) .. (2,0);
      \strand (1,4) .. controls (1.5,1.5) and (2.5,2.5) .. (3,0);
      \strand (2,4) .. controls (1.5,1.5) and (1.5,2.5) .. (0,0);
      \strand (3,4) .. controls (2.5,1.5) and (2.5,2.5) .. (1,0);
    \end{knot}
  \end{tikzpicture}
\quad=\quad
  \begin{tikzpicture}[scale=0.4,every node/.style={scale=0.4}]
    \begin{knot}[clip width=3]
      \filldraw (0,4) circle (2pt) node[above] {0};
      \filldraw (1,4) circle (2pt) node[above] {1};
      \filldraw (2,4) circle (2pt) node[above] {2};
      \filldraw (3,4) circle (2pt) node[above] {3};
      \filldraw (0,0) circle (2pt) node[below] {0};
      \filldraw (1,0) circle (2pt) node[below] {2};
      \filldraw (2,0) circle (2pt) node[below] {1};
      \filldraw (3,0) circle (2pt) node[below] {3};
      \strand (0,4) to (0,0);
      \strand (1,4) .. controls (0.5,2) and (2.5,2) .. (2,0);
      \strand (2,4) .. controls (2.5,2) and (0.5,2) .. (1,0);
      \strand (3,4) to (3,0);
    \end{knot}
  \end{tikzpicture}
  &&
    \begin{tikzpicture}[scale=0.4,every node/.style={scale=0.4}]
      \begin{knot}[clip width=3]
        \filldraw (0,4) circle (2pt) node[above] {0};
        \filldraw (1,4) circle (2pt) node[above] {2};
        \filldraw (2,4) circle (2pt) node[above] {1};
        \filldraw (3,4) circle (2pt) node[above] {3};
        \filldraw (0,0) circle (2pt) node[below] {2};
        \filldraw (1,0) circle (2pt) node[below] {0};
        \filldraw (2,0) circle (2pt) node[below] {1};
        \filldraw (3,0) circle (2pt) node[below] {3};
        \strand (0,4) .. controls (-0.5,2) and (1.5,2) .. (1,0);
        \strand (1,4) .. controls (1.5,2) and (-0.5,2) .. (0,0);
        \strand (2,4) to (2,0);
        \strand (3,4) to (3,0);
      \end{knot}
    \end{tikzpicture}
  &&
  \begin{tikzpicture}[scale=0.4,every node/.style={scale=0.4}]
    \begin{knot}[clip width=3]
      \filldraw (0,4) circle (2pt) node[above] {2};
      \filldraw (1,4) circle (2pt) node[above] {0};
      \filldraw (2,4) circle (2pt) node[above] {1};
      \filldraw (3,4) circle (2pt) node[above] {3};
      \filldraw (0,0) circle (2pt) node[below] {2};
      \filldraw (1,0) circle (2pt) node[below] {0};
      \filldraw (2,0) circle (2pt) node[below] {3};
      \filldraw (3,0) circle (2pt) node[below] {1};
      \strand (0,4) to (0,0);
      \strand (1,4) to (1,0);
      \strand (2,4) .. controls (1.5,2) and (3.5,2) .. (3,0);
      \strand (3,4) .. controls (3.5,2) and (1.5,2) .. (2,0);
    \end{knot}
  \end{tikzpicture}
  &&
    \begin{tikzpicture}[scale=0.4,every node/.style={scale=0.4}]
      \begin{knot}[clip width=3]
        \filldraw (0,4) circle (2pt) node[above] {2};
        \filldraw (1,4) circle (2pt) node[above] {0};
        \filldraw (2,4) circle (2pt) node[above] {3};
        \filldraw (3,4) circle (2pt) node[above] {1};
        \filldraw (0,0) circle (2pt) node[below] {2};
        \filldraw (1,0) circle (2pt) node[below] {3};
        \filldraw (2,0) circle (2pt) node[below] {0};
        \filldraw (3,0) circle (2pt) node[below] {1};
        \strand (0,4) to (0,0);
        \strand (1,4) .. controls (0.5,2) and (2.5,2) .. (2,0);
        \strand (2,4) .. controls (2.5,2) and (0.5,2) .. (1,0);
        \strand (3,4) to (3,0);
      \end{knot}
    \end{tikzpicture}
\end{align*}

\note{Show codes; normalize; explain the dense paragraph above using that example}


The technical result implies several immediate applications to reversible circuits: (i) a reversible circuit expressed
in $\PiPlusLang$ can be automatically generated from a permutation in $\UFin$ \emph{and the generation comes equipped
  with a proof of correctness establishing its equivalence between the circuit and the original permutation}; (ii)
circuits in $\PiLang$ or $\PiPlusLang$ can be reduced to a circuit normal form using a normalization by evaluation
process that evaluates them to a permutation in $\UFin$ and quotes it back; (iii) equivalence of circuits in either
$\PiLang$ or $\PiPlusLang$ can be decided by reducing them to normal forms; (i) a circuit can be verified against a
given permutation by evaluating it; and (v) the induced circuit equivalences in $\PiLang$ and $\PiPlusLang$ form a sound
and complete calculus for reasoning about and optimizing circuits. (See Sec.~\ref{sec:informal} for more details.)

  \note{perhaps a note about the result being folklore; assumed in many places; but no proof; and certainly none
    formalized in a proof assistant. In some sense, what we have done is to take MacLane's coherence theorem and
    formalized it in HoTT, and given presentations for it using Pi's syntax. Also relevant is that the equivalence
    result hides implicit isomorphisms that have computational relevance. For example, transporting properties across
    equivalences of finite types can be done via executing permutations, something which has a clear computational cost
    and which itself depends on the choice of representations of the permutations.}

% \begin{itemize}[leftmargin=*]
%   \item We take the $\PiLang$ family of reversible languages~\cite{jamesInformationEffects2012} and show how to encode
%         various boolean reversible circuits in the language. The circuits are implemented using 1-combinators in the
%         language, and circuit optimisations are realized as 2-combinators between these reversible programs.
%   \item We show how to encode reversible circuits on a fixed number of bits as permutations of finite sets with the
%         appropriate cardinality. We observe that reversible programs can be translated to bijective functions between
%         finite sets and equality of reversible programs can be witnessed as extensional equality of these bijective
%         functions.
%   \item We review a few basics of Homotopy Type Theory~\cite{univalentfoundationsprogramHomotopyTypeTheory2013}, and
%         exhibit some results that we use in our technical development. We define the notion of a universe \`{a} la
%         Tarski internally in HoTT, which is given by a type for codes $U$ and a decoding function to a univalent
%         universe $\El : U \to \UU$. We say that this universe is univalent, if the decoding fibration is univalent, that
%         is, the decoding function $\El$ reflects the path space of the underlying univalent universe. We exhibit some
%         examples of univalent subuniverses, in particular, we define the subuniverse of finite types, $\UFin$, which
%         classifies all finite types, and show that it is univalent. Using this, we establish a characterization of the
%         path space of the universe of finite types.
%   \item We observe that 1-paths in $\UFin$ are permutations on finite sets with a fixed cardinality $n$, given by
%         $\Aut[\Fin[n]]$, which produces the permutation group on $\Fin[n]$, or the symmetric group $\Sn$. We then
%         proceed to give a presentation of $\Sn$ using generators and relations, by defining the Coxeter relations. We
%         build a rewriting system using the Coxeter relations on the set of words $\List[\Fin[n]]$, and show that it is
%         (locally) confluent and strongly normalising. We define the the symmetric group $\Sn$ to be the set-quotient of
%         $\List[\Fin[n]]$ by the Coxeter relations, and show that it produces a group presentation, as a quotient of the
%         free group. Using our strongly normalising rewriting system, we establish that normal forms for words in $\Sn$
%         are Lehmer codes~\cite{lehmerTeachingCombinatorialTricks1960}, which are a convenient and compact representation
%         of permutations for permutations. Finally, we show that there is an equivalence between Lehmer codes and
%         permutations $\Aut[\Fin[n]]$ given by the Lehmer encode-decode algorithm.
%   \item Finally, we show how to interpret the language $\PiLang$ into our groupoid $\UFin$, in stages. First we define a
%         subset of the language $\PiPlusLang$ which only includes the additive monoidal structure. We translate $\PiLang$
%         programs to $\PiPlusLang$ by defining multiplication as repeated addition. Then, we further define a normalized
%         form for for this language called $\PiHatLang$, which has normalized 1-combinators and 2-combinators
%         corresponding to adjacent transpositions. We show that $\PiPlusLang$ can be translated to $\PiHatLang$ and back,
%         using adjacent transpositions to generate arbitrary swaps. Then, we show how to interpret this language
%         $\PiHatLang$ into $\UFin$ -- the 1-combinators are translated into permutations via words in $\Sn$, and
%         2-combinators are interpreted as 2-paths in $\UFin$. We further show how to quote back a permutation in $\UFin$
%         into a 1-combinator using the normal form for words in $\Sn$.
%   \item We give some applications of this translation by showing how to normalise a circuit written in $\PiLang$ to a
%         normal form in $\PiPlusLang$ and $\PiHatLang$, which uses fewer gates.~\todo{Here, or earlier?}
% \end{itemize}

% Our results are formalized in the proof assistant Agda using the HoTT-Agda library.

\begin{center}
  \includegraphics[scale=0.3]{outline.png}
\end{center}

\note{Redo this figure or delete ??}

\note{Spiel about reversible computing and logical reversibility ??}

\note{Spiel about using groupoids for denotational semantics ??}

\note{Could we include a short paragraph about entropy and bits and logical reversibility ??}

\note{Novel interpretation of the univalence axiom, operational and denotational semantics and adequacy.}

-------


% * STLC(first) is the type theory for CCC
%   HoTT is type theory for weak infty groupoids(first)
%   Correspondence between TT and categories are fruitful:
%   answer hard questions about syntax without worrying about presentation
%   normalization of lcal with strong sums: if you have specific syntax; no obvious induction on syntax
%   Lawvere thesis


% * Rig groupoids are interesting! WHY????
%   Add monoidal structure to weak groupoids. Easy. Lists
%   How symmetry is going to act on higher dimension
%   Higher-dim all symmetric; topology higher things abelian groups

% * What is the corresponding type theory ?
%   We give it for the free symmetric groupoid; for other groupoids build on it and add more




%%% Local Variables:
%%% mode: latex
%%% TeX-master: "main"
%%% fill-column: 120
%%% End:
