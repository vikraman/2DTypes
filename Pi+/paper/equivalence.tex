\section{Correspondence between \texorpdfstring{$\PiLang$}{Pi} and \texorpdfstring{$\UFin$}{UFin}}
\label{sec:equivalence}

In this section, we first translate $\PiLang$ to its additive fragment $\PiPlusLang$. This is the language that we
interpret to $\UFin$ and back, using the tools developed in the previous sections. Further, we go through an
intermediate step of the language $\PiHatLang$, which is a simplified variant of $\PiPlusLang$ that uses adjacent
transpositions for combinators, while preserving all the required structure.

% https://q.uiver.app/?q=WzAsNCxbMCwwLCJcXFBpTGFuZyJdLFsyLDAsIlxcUGlQbHVzTGFuZyJdLFs0LDAsIlxcUGlIYXRMYW5nIl0sWzYsMCwiXFxVRmluIl0sWzAsMSwiXFxldmFsdCJdLFsxLDIsIlxcZXZhbGgiLDAseyJjdXJ2ZSI6LTR9XSxbMiwzLCJcXGV2YWx0IiwwLHsiY3VydmUiOi00fV0sWzIsMSwiXFxxdW90ZWgiLDAseyJjdXJ2ZSI6LTR9XSxbMywyLCJcXHF1b3RldCIsMCx7ImN1cnZlIjotNH1dXQ==
\[\begin{tikzcd}
    \PiLang && \PiPlusLang && \PiHatLang && \UFin
    \arrow["\evalt", from=1-1, to=1-3]
    \arrow["\evalp", curve={height=-24pt}, from=1-3, to=1-5]
    \arrow["\evalh", curve={height=-24pt}, from=1-5, to=1-7]
    \arrow["\quotep", curve={height=-24pt}, from=1-5, to=1-3]
    \arrow["\quoteh", curve={height=-24pt}, from=1-7, to=1-5]
  \end{tikzcd}\]

We present the types and 1-combinators of $\PiPlusLang$ and $\PiHatLang$ in~\Cref*{fig:piplus,fig:pihat} respectively,
eliding the 2-combinators for brevity. We enforce that there is a unique 2-combinator between compatible 1-combinators,
by relating them with a truncation. These can be found in~\cref{app:leveltwo} and in the accompanying Agda code.

The translations between the languages are defined separately on types, 1-combinators, and 2-combinators. Following the
terminology of Normalisation by Evaluation, the translations from the left to the right, going from the syntax towards
the semantics, are called $\evalt$ and the translations the other way are called $\quotet$.

To state our results formally, we organise the syntax for each language using a technical device, called a syntactic
category. We define them formally in the appendix, and only state our results here. For each of the $\PiLang$,
$\PiPlusLang$ and $\PiHatLang$ languages, their syntactic categories, respectively $\PiCat$, $\PiPlusCat$ and
$\PiHatCat$, have 0-cells for types, 1-cells for 1-combinators, and 2-cells for 2-combinators. We can show that these
syntactic categories here are actually $(2,0)$-categories, since all the 1-cells and 2-cells are invertible. They are
also locally-strict, or locally-posetal, because there is at most one 2-cell between compatible 1-cells.

\begin{toappendix}
  \begin{proposition}
    We can form a weak 2-category $\PiCat$ with
    \begin{itemize}
      \item $\PiLang$ types ($U$) for 0-cells,
      \item for $X, Y : U$, a collection of 1-cells $X \iso Y$,
      \item for $p, q : X \iso Y$, a collection of 2-cells $p \Iso q$.
    \end{itemize}
  \end{proposition}

  \begin{proposition}
    We can form a weak 2-category $\PiPlusCat$ with
    \begin{itemize}
      \item $\PiPlusLang$ types ($\UPlus$) for 0-cells,
      \item for $X, Y : \UPlus$, a collection of 1-cells $X \isop Y$,
      \item for $p, q : X \isop Y$, a collection of 2-cells $p \Isop q$.
    \end{itemize}
  \end{proposition}

  \begin{proposition}
    We can form a weak 2-category $\PiHatCat$ with
    \begin{itemize}
      \item $\PiHatCat$ types ($\UHat$) for 0-cells,
      \item for $X, Y : \UHat$, a collection of 1-cells $X \isoh Y$,
      \item for $p, q : X \isoh Y$, a collection of 2-cells $p \Isoh q$.
    \end{itemize}
  \end{proposition}
\end{toappendix}

We use the $\evalt/\quotet$ translation maps to construct functors between these categories. We only name the maps on
the 0, 1, and 2-cells -- the coherences hold by definition or by calculation, which is shown in our accompanying Agda
code. We use these functors to state our results establishing the equivalences between the languages.

\subsection{$\PiLang$ to $\PiPlusLang$}

First, we show how to translate $\PiLang$ programs to $\PiPlusLang$, which is the additive fragment of $\PiLang$. The
syntax for 1-combinators is given in~\Cref{fig:piplus}.

\begin{figure}[t]
  {\scalebox{\scalef}{$
        \begin{array}{rrcll}
          \idc :     & A           & \iso & A           & : \idc     \\
          \identlp : & \zerot + A  & \iso & A           & : \identrp \\
          \swapp :   & A + B       & \iso & B + A       & : \swapp   \\
          \assoclp : & A + (B + C) & \iso & (A + B) + C & : \assocrp \\ [1.5ex]
        \end{array}$}}

  {\scalebox{\scalef}{
      \Rule{}
      {\jdg{}{}{c_1 : A \iso B} \quad \vdash c_2 : B \iso C}
      {\jdg{}{}{c_1 \fatsemi c_2 : A \iso C}}
      {}

      \Rule{}
      {\jdg{}{}{c_1 : A \iso B} \quad \vdash c_2 : C \iso D}
      {\jdg{}{}{c_1 \oplus c_2 : A + C \iso B + D}}
      {}
    }}
  \caption{$\PiPlusLang$ syntax}
  \label{fig:piplus}
\end{figure}

$\PiLang$ has two 0-ary type constructors, and two binary type constructors -- the additive tensor product and the
multiplicative one. $\PiPlusLang$ has all the type constructors of $\PiLang$ except multiplication. However, we will
show how to recover the multiplicative structure, by defining multiplication as repeated addition. We encode $\times$ in
terms of $+$ as follows.

\begin{definition}[$\times : \UPlus \to \UPlus \to \UPlus$]
  \begin{align*}
    \zerot \times Y      & \defeq \zerot                      \\
    \onet \times Y       & \defeq Y                           \\
    (X_1 + X_2) \times Y & \defeq X_1 \times Y + X_2 \times Y
  \end{align*}
\end{definition}

\begin{lemma}
  There are two symmetric monoidal structures on $\PiPlusCat$, given by $(\zerot, +)$ and $(\onet, \times)$, with
  $\times$ distributing over $+$, giving it a rig structure.
\end{lemma}

\noindent Using this rig structure, we translate $\PiLang$ to $\PiPlusLang$, constructing a rig equivalence from
$\PiCat$ to $\PiPlusCat$.

\begin{definition}[$\evalt$]
  \begin{align*}
    \evalt_{0} & : U \to \UPlus                                             \\
    \evalt_{1} & : (c : X \iso Y) \to \evalt_{0}(X) \iso \evalt_{0}(Y)      \\
    \evalt_{2} & : (\alpha : p \Iso q) \to \evalt_{1}(p) \Iso \evalt_{1}(q)
  \end{align*}
\end{definition}

\begin{theorem}
  $\evalt$ gives a rig equivalence between $\PiCat$ and $\PiPlusCat$.
\end{theorem}

\subsection{$\PiPlusLang$ to $\PiHatLang$}

Next, we show how to translate $\PiPlusLang$ programs to $\PiHatLang$ and back. $\PiHatLang$ is a simplified variant of
$\PiPlusLang$, with (unary) natural numbers for 0-cells, 1-combinators generated by adjacent transpositions, and an
appropriate set of 2-combinators. We give the syntax, again omitting 2-combinators, in~\Cref{fig:pihat}.

\begin{figure}[t]
  {\scalebox{\scalef}{$
        \begin{array}{rrcll}
          \idc :   & n             & \isoh & n             & : \idc   \\
          \swapc : & \suc[\suc[n]] & \isoh & \suc[\suc[n]] & : \swapc \\
        \end{array}
      $}}

  {\scalebox{\scalef}{
      \Rule{}
      {\jdg{}{}{c_1 : n \isoh m} \quad \vdash c_2 : m \isoh o}
      {\jdg{}{}{c_1 \fatsemi c_2 : n \isoh o}}
      {}

      \Rule{}
      {\jdg{}{}{c : n \isoh m}}
      {\jdg{}{}{\oplus(c) : \suc[n] \isoh \suc[m]}}
      {}
    }}
  \caption{$\PiHatLang$ syntax}
  \label{fig:pihat}
\end{figure}

As described, $\PiHatLang$ doesn't have a tensor product, but we can build it simply by adding up natural numbers, and,
we need to verify that this indeed equips $\PiHatCat$ with a symmetric monoidal structure.~\footnote{Since each object
is a natural number, this makes $\PiHatCat$ a \emph{PROP}, that is, a products and permutations category.}

To produce a braiding $n + m \isoh m + n$ from adjacent tranpositions, we recursively traverse the left subexpression,
swapping each element using adjacent transpositions along the elements on the right, placing it in the right position.
The computational content of this translation can be visualised using tree transformations, for the recursive case
in~\cref{fig:plusplusswap}. The challenging part is showing that these moves are coherent with respect to 2-combinators.

\begin{figure}
   \[
      \Tree [ [ {\tiny 1} {\tiny n} ] {\tiny m} ] ~\xrightarrow{}~
      \Tree [ {\tiny 1} [ {\tiny n} {\tiny m} ] ] ~\xrightarrow{}~
      \Tree [ [ {\tiny n} {\tiny m} ] {\tiny 1} ] ~\xrightarrow{}~
      \Tree [ [ {\tiny m} {\tiny n} ] {\tiny 1} ] ~\xrightarrow{}~
      \Tree [ {\tiny m} [ {\tiny n} {\tiny 1} ] ] ~\xrightarrow{}~
      \Tree [ {\tiny m} [ {\tiny 1} {\tiny n} ] ] ~
    \]
    \caption{Braiding from transpositions, recursive case}
    \label{fig:plusplusswap}
\end{figure}

\begin{lemma}
  $\PiHatCat$ has a symmetric monoidal structure, with the unit given by 0 and the tensor product given by natural
  number addition.
\end{lemma}

\noindent Using this symmetric monoidal structure, we translate from $\PiPlusLang$ to $\PiHatLang$.

\begin{definition}[$\evalp$]
  \begin{align*}
    \evalp_{0} & : \UPlus \to \UHat                                                           \\
    \evalp_{1} & : (c : t_{1} \isop t_{2}) \to \evalp_{0}(t_{1}) \isoh \evalp_{0}(t_{2})      \\
    \evalp_{2} & : (\alpha : c_{1} \Isop c_{2}) \to \evalp_{1}(c_{1}) \Isoh \evalp_{1}(c_{2})
  \end{align*}
\end{definition}

To go back from $\PiHatLang$ to $\PiPlusLang$, we turn a natural number into a $\PiPlusLang$ type, using right-biased
addition, that is, the natural number $n$ gets mapped to the type $\onet + (\onet + (\onet + \ldots + \zerot))$. Since
the types are already right-biased, an adjacent transposition in $\PiHatLang$ is easily encoded by using the braiding in
$\PiPlusLang$, as shown in~\cref{fig:transpfrombraid}. Again, these are shown to be coherent.

\begin{figure}
  \[
    \Tree [ {\tiny $\onet$} [ {\tiny $\onet$} {\tiny X} ] ] ~\xrightarrow{\assoclp}~
    \Tree [ [ {\tiny $\onet$} {\tiny $\onet$} ] {\tiny X} ] ~\xrightarrow[\swapp\phantom{xx}]{\phantom{xx}\idc}~
    \Tree [ [ {\tiny $\onet$} {\tiny $\onet$} ] {\tiny X} ] ~\xrightarrow{\assocrp}~
    \Tree [ {\tiny $\onet$} [ {\tiny $\onet$} {\tiny X} ] ] ~
  \]
  \caption{Transpositions from braiding}
  \label{fig:transpfrombraid}
\end{figure}

\begin{definition}[$\quotep$]
  \begin{align*}
    \quotep_{0} & : \UHat \to \UPlus                                                            \\
    \quotep_{1} & : (p : X_{1} \isoh X_{2}) \to \quotep_{0}(X_{1}) \iso \quotep_{0}(X_{2})      \\
    \quotep_{2} & : (\alpha : p_{1} \Isoh p_{2}) \to \quotep_{1}(p_{1}) \Iso \quotep_{1}(p_{2})
  \end{align*}
\end{definition}

\begin{theorem}
  $\evalp/\quotep$ give a symmetric monoidal equivalence between $\PiPlusCat$ and $\PiHatCat$.
\end{theorem}

\subsection{$\PiHatLang$ to $\UFin$}

Finally, we show how to interpret $\PiHatLang$ to $\UFin$, and back from $\UFin$ to $\PiHatLang$. Types in $\PiHatLang$
are interpreted as 0-cells in $\UFin$, that is, a natural number $n$ is mapped to $\Fin[n]$. The 1-combinators in
$\PiHatLang$ are mapped to 1-paths in $\UFin$, that is, 1-loops $\Aut[\Fin[n]]$, in each connected component. In
$\PiHatLang$, the 1-combinators are generated by adjacent transpositions, so these can be mapped to words in $\Sn$ and
then to automorphisms using~\Cref{prop:sn-lehmer-fin-equiv}. Finally, 2-combinators are mapped to 2-paths between loops
in $\UFin$.

\begin{definition}[$\evalh$]
  \begin{align*}
    \evalh_{0} & : \UHat \to \UFin                                                          \\
    \evalh_{1} & : (c : t_{1} \isoh t_{2}) \to \evalh_{0}(t_{1}) \id \evalh_{0}(t_{2})      \\
    \evalh_{2} & : (\alpha : c_{1} \Isoh c_{2}) \to \evalh_{1}(c_{1}) \id \evalh_{1}(c_{2})
  \end{align*}
\end{definition}

\noindent 0-cells in $\UFin$ are mapped to their cardinalities in $\PiHatLang$, 1-loops are decoded to words in $\Sn$ to
generate a sequence of adjacent transpositions, producing a 1-combinator in $\PiHatLang$. Finally, 2-paths are quoted
back to 2-combinators in $\PiHatLang$.

\begin{definition}[$\quoteh$]
  \begin{align*}
    \quoteh_{0} & : \UFin \to \UHat                                                            \\
    \quoteh_{1} & : (p : X_{1} \id X_{2}) \to \quoteh_{0}(X_{1}) \isoh \quoteh_{0}(X_{2})      \\
    \quoteh_{2} & : (\alpha : p_{1} \id p_{2}) \to \quoteh_{1}(p_{1}) \Isoh \quotet_{1}(p_{2})
  \end{align*}
\end{definition}

% $\UFin$ as a 1-groupoid, is a (locally strict) weak $(2,0)$-category, and we use this to state our final equivalence.

\begin{theorem}
  $\evalh/\quoteh$ give a symmetric monoidal equivalence between $\PiHatCat$ and $\UFin$.
\end{theorem}

The semantics that we presented here takes a different route to constructing the permutation from a $\PiLang$
combinator, compared to the direct interpretation given using the big-step interpreter in~\Cref{subsec:denotational}. We
verify that the two semantics agree, establishing that the semantics is adequate and fully abstract.

\begin{definition}[${\gdenot{\blank}}$]
  \begin{gather*}
    \begin{aligned}
      \gdenot{\blank}_{0} & : U \to \UFin                                       \\
      \gdenot{\blank}_{0} & \defeq \evalh_{0} \comp \evalp_{0} \comp \evalt_{0}
    \end{aligned}
    \qquad
    \begin{aligned}
      \gdenot{\blank}_{1} & : (c : X \iso Y) \to \gdenot{X}_{0} \id_{\UFin} \gdenot{Y}_{0} \\
      \gdenot{\blank}_{1} & \defeq \evalh_{1} \comp \evalp_{1} \comp \evalt_{1}
    \end{aligned}
  \end{gather*}
\end{definition}

\begin{theorem}[Full Abstraction and Adequacy]
  For any $c_1, c_2 : X \iso Y$, we have that
  \[
    \denot{c_1} = \denot{c_2} \text{ if and only if } \gdenot{c_1}_{1} = \gdenot{c_2}_{1}
  \]
\end{theorem}

\section{Normalisation of Reversible Circuits}
\label{sec:applications}

Using our semantics, we can normalise, synthesise, prove equivalence, and generally reason about~$\PiLang$ programs. The
two key definitions are presented below.

\begin{definition}[Normalisation of $\PiLang$ programs]
  \begin{gather*}
    \begin{aligned}
      \normt_{0} & : U \to \UPlus                                            \\
      \normt_{0} & = \quotep_{0} \comp \quoteh_{0} \comp \gdenot{\blank}_{0}
    \end{aligned}
    \qquad
    \begin{aligned}
      \normt_{1} & : (c : X \iso Y) \to \normt_{0}(X) \iso \normt_{0}(Y)     \\
      \normt_{1} & = \quotep_{1} \comp \quoteh_{1} \comp \gdenot{\blank}_{1}
    \end{aligned}
  \end{gather*}
\end{definition}

\noindent Normalisation consists of translating $\PiLang$ programs to $\PiHatLang$, computing a permutation, and quoting
back to $\PiPlusLang$. Note that the normalisation happens in the step from $\PiHatLang$ to $\UFin$ and back to
$\PiHatLang$ and that normalisation also provides a decision procedure for program equivalence. Synthesis consists of
quoting permutations. More general, user-guided, reasoning can be done using the sound and complete level-2
combinators to rewrite $\PiLang$ programs.

Recall the specification of reversible disjunction from \Cref{sec:examples}, the two Qiskit circuits for implementing it, and the
corresponding $\PiLang$ definitions \Afun{reversibleOr1} and \Afun{reversibleOr2}. The normal forms for both circuit is
computes to the following, establishing their equivalence:

\medskip
\resetnormtwo{}

Instead of manually producing $\Pi$-programs to implement the reversible disjunction specification, it is also possible
to simply quote the desired permutation:

\medskip
\resetperm{}

\noindent The permutation uses the canonical encoding of sequences of bits as natural numbers (e.g., (\textsf{false},
\textsf{true},\textsf{true}) is encoded as 011 or 3).  The second entry maps index 1 (= 001) to the value 5 (= 101)
which states that since one of the right bits is set in 001 then the leftmost bit in the output is set. Quoting this
permutation generates the same normalised program which can then be composed with a map from $\PiLang$ to
$\PiPlusLang$ to produce a program matching the desired structured types.

% \paragraph*{Program synthesis.} The NbE process embodies a quoting mechanism that synthesizes programs from
% permutations. Indeed, instead of writing a program for \Afun{reset 2}, one could simply specify the desired permutation
% as:

%%\begin{minipage}{.65\textwidth}
%%  \PiRESET{}
%%\end{minipage}
%%\begin{minipage}{.30\textwidth}
%%  \begin{center}
%%  \resizebox{0.5\textwidth}{!}{\input{diagrams/reset.tikz}}
%%  \end{center}
%%\end{minipage}

%% \resettwo{}

% \noindent The syntax will be explained in detail in the next section and the full definitions of the helpers are
% provided in the supplementary material. For now, it is sufficient to know that there is some program that implements the
% reversible function of interest and that applying \Afun{reset} to 2 produces \verb|reversibleOr2| from the introduction.

% In principle, the normalised program can be produced following two strategies: (i) by repeatedly applying the rewrite
% rules of our calculus of reversible functions (explained in Sec.~\ref{sec:reversibletwo}), or (ii) in the case above by
% using a NbE process that evaluates the program to a permutation on a finite set of 8
% elements and reifies that permutation back to a program. The key idea of the NbE process is a systematic way to express
% permutations as sequences of adjacent swaps as illustrated in the following small example where the permutation on the
% left is compiled to the sequence of four adjacent transpositions on the right:

% \note{Motivation: There are two reversible circuits which describe the following permutation. They can be shown to be
%   equal using the 2-combinators.}

% \[
%   \begin{tikzpicture}
%     \begin{knot}[clip width=5]
%       \filldraw (0,5) circle (2pt) node[above] {0};
%       \filldraw (1,5) circle (2pt) node[above] {1};
%       \filldraw (2,5) circle (2pt) node[above] {2};
%       \filldraw (3,5) circle (2pt) node[above] {3};
%       \filldraw (4,5) circle (2pt) node[above] {4};
%       \filldraw (0,0) circle (2pt) node[below] {1};
%       \filldraw (1,0) circle (2pt) node[below] {4};
%       \filldraw (2,0) circle (2pt) node[below] {0};
%       \filldraw (3,0) circle (2pt) node[below] {3};
%       \filldraw (4,0) circle (2pt) node[below] {2};
%       \strand (0,5) .. controls (0.5,0.5) and (1.5,3.5) .. (2,0);
%       \strand (1,5) .. controls (0.75,0.5) and (0.25,3.5) .. (0,0);
%       \strand (2,5) .. controls (2.5,2.5) and (3.5,1.5) .. (4,0);
%       \strand (3,5) .. controls (4.5,2.5) and (4,1.5) .. (3,0);
%       \strand (4,5) .. controls (3.5,2.5) and (1.5,2.5) .. (1,0);
%       \flipcrossings{4,5};
%     \end{knot}
%   \end{tikzpicture}
% \]

% \paragraph*{Program equivalence.} The permutation above reveals another way to think about the desired program: it is a
% special addition circuit that keeps 0 and 4 fixed but otherwise adds 4 modulo 8 to its input. From this specification,
% one can use a standard synthesis algorithm for reversible circuits~\cite{10.1145/775832.775915} to generate the
% following program:

% \adder{}

% \noindent The \Afun{adder3} program looks nothing like the original \Afun{reset 2} program and yet they both have the
% same normal form thus establishing their equivalence. The reader can check that this circuit is the same as
% \verb|reversibleOr1| from the introduction.

% Now imagine we want to write the following reversible function:

% 0 -> 0
% 8 -> 8
% n -> n + 8 `mod` 16

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "main"
%%% fill-column: 120
%%% End:
