\section{Going from \texorpdfstring{$\PiLang$}{Pi} to \texorpdfstring{$\UFin$}{UFin} and back}
\label{sec:equivalence}

% https://q.uiver.app/?q=WzAsNCxbMCwwLCJcXFBpTGFuZyJdLFsyLDAsIlxcUGlQbHVzTGFuZyJdLFs0LDAsIlxcUGlIYXRMYW5nIl0sWzYsMCwiXFxVRmluIl0sWzAsMSwiXFxldmFsdCJdLFsxLDIsIlxcZXZhbGgiLDAseyJjdXJ2ZSI6LTR9XSxbMiwzLCJcXGV2YWx0IiwwLHsiY3VydmUiOi00fV0sWzIsMSwiXFxxdW90ZWgiLDAseyJjdXJ2ZSI6LTR9XSxbMywyLCJcXHF1b3RldCIsMCx7ImN1cnZlIjotNH1dXQ==
\[\begin{tikzcd}
    \PiLang && \PiPlusLang && \PiHatLang && \UFin
    \arrow["\evalt", from=1-1, to=1-3]
    \arrow["\evalp", curve={height=-24pt}, from=1-3, to=1-5]
    \arrow["\evalh", curve={height=-24pt}, from=1-5, to=1-7]
    \arrow["\quotep", curve={height=-24pt}, from=1-5, to=1-3]
    \arrow["\quoteh", curve={height=-24pt}, from=1-7, to=1-5]
  \end{tikzcd}\]

In this section, we consider the additive fragment $\PiPlusLang$ of $\PiLang$. This is the language that we interpret to
$\UFin$ and back, using the tools developed in the previous sections. Further, we go through an intermediate step of the
language $\PiHatLang$, which is a simplified variant of $\PiPlusLang$ that uses adjacent transpositions for combinators,
while preserving all the required structure.

We present the types and 1-combinators of $\PiPlusLang$ and $\PiHatLang$ in~\Cref*{fig:piplus,fig:pihat} respectively,
eliding the 2-combinators for brevity. \note{We enforce that there is a unique 2-combinator between compatible
1-combinators, by introducing a level 3, which is trivial in the same way as in the case of $\PiLang$, as described
before.} They can be found in the appendix and in the accompanying Agda code.

The translations between the languages are defined separately on types, 1-combinators, and 2-combinators. Following the
terminology of Normalisation by Evaluation, the translations from the left to the right, going from the syntax towards
the semantics, are called $\evalt$ and the translations the other way are called $\quotet$.

To state our results formally, we organise the syntax for each language using a technical device, called a syntactic
category. Since the languages have higher-dimensional structure, the syntactic categories here are actually
(locally-strict) weak 2-categories. We define them formally in the appendix, and only state our results here.

For each of the $\PiLang$, $\PiPlusLang$ and $\PiHatLang$ languages, their syntactic categories, respectively $\PiCat$,
$\PiPlusCat$ and $\PiHatCat$, have 0-cells for types, 1-cells for 1-combinators, and 2-cells for 2-combinators. We can
show that these are $(2,0)$-categories, since all the 1-cells and 2-cells are invertible. They are also locally-strict,
or locally-posetal, because there is at most one 2-cell between compatible 1-cells.

\begin{toappendix}
  \todo{What is U?}
  \begin{proposition}
    We can form a weak 2-category $\PiCat$ with
    \begin{itemize}
      \item $\PiLang$ types for 0-cells,
      \item for $X, Y : U$, a collection of 1-cells $X \iso Y$,
      \item for $p, q : X \iso Y$, a collection of 2-cells $p \Iso q$.
    \end{itemize}
  \end{proposition}

  \begin{proposition}
    We can form a weak 2-category $\PiPlusCat$ with
    \begin{itemize}
      \item $\PiPlusLang$ types for 0-cells,
      \item for $X, Y : \UPlus$, a collection of 1-cells $X \isop Y$,
      \item for $p, q : X \isop Y$, a collection of 2-cells $p \Isop q$.
    \end{itemize}
  \end{proposition}

  \begin{proposition}
    We can form a weak 2-category $\PiHatCat$ with
    \begin{itemize}
      \item $\PiHatCat$ types for 0-cells,
      \item for $X, Y : \UHat$, a collection of 1-cells $X \isoh Y$,
      \item for $p, q : X \isoh Y$, a collection of 2-cells $p \Isoh q$.
    \end{itemize}
  \end{proposition}
\end{toappendix}

We use the $\evalt/\quotet$ translation maps to construct functors between these categories. We only name the maps on
the 0, 1, and 2-cells -- the coherences hold by definition or by calculation, which is shown in our accompanying Agda
code. We use these functors to state our results establishing the equivalences between the languages.

\subsection{$\PiLang$ to $\PiPlusLang$}

First, we show how to translate $\PiLang$ programs to $\PiPlusLang$, which is the additive fragment of $\PiLang$. The
syntax is given in~\Cref{fig:piplus}.

\begin{figure}[t]
  {\scalebox{\scalef}{$
        \begin{array}{rrcll}
          \idc :     & A           & \iso & A           & : \idc     \\
          \identlp : & \zerot + A  & \iso & A           & : \identrp \\
          \swapp :   & A + B       & \iso & B + A       & : \swapp   \\
          \assoclp : & A + (B + C) & \iso & (A + B) + C & : \assocrp \\ [1.5ex]
        \end{array}$}}

  {\scalebox{\scalef}{
      \Rule{}
      {\jdg{}{}{c_1 : A \iso B} \quad \vdash c_2 : B \iso C}
      {\jdg{}{}{c_1 \fatsemi c_2 : A \iso C}}
      {}

      \Rule{}
      {\jdg{}{}{c_1 : A \iso B} \quad \vdash c_2 : C \iso D}
      {\jdg{}{}{c_1 \oplus c_2 : A + C \iso B + D}}
      {}
    }}
  \caption{$\PiPlusLang$ syntax}
  \label{fig:piplus}
\end{figure}

$\PiLang$ has two 0-ary type constructors, and two binary type constructors -- the additive tensor product and the
multiplicative one. $\PiPlusLang$ has all the type constructors of $\PiLang$ except multiplication. However, we will
show how to recover the multiplicative structure, by defining multiplication as repeated addition. We encode $\times$ in
terms of $+$ as follows.

\begin{definition}[$\times : \UPlus \to \UPlus \to \UPlus$]
  \begin{align*}
    \zerot \times Y      & \defeq \zerot                      \\
    \onet \times Y       & \defeq Y                           \\
    (X_1 + X_2) \times Y & \defeq X_1 \times Y + X_2 \times Y
  \end{align*}
\end{definition}

\begin{proposition}
  There are two symmetric monoidal structures on $\PiPlusCat$, given by $(\zerot, +)$ and $(\onet, \times)$, with
  $\times$ distributing over $+$, giving it a rig structure, as described in \todo{cite earlier section}.
\end{proposition}
\todo{either prove it or cite something}

Using this rig structure, we translate $\PiLang$ to $\PiPlusLang$, constructing a rig equivalence from $\PiCat$ to
$\PiPlusCat$.

\begin{definition}
  \begin{align*}
    \evalt_{0} & : U \to \UPlus                                             \\
    \evalt_{1} & : (c : X \iso Y) \to \evalt_{0}(X) \iso \evalt_{0}(Y)      \\
    \evalt_{2} & : (\alpha : p \Iso q) \to \evalt_{1}(p) \Iso \evalt_{1}(q)
  \end{align*}
\end{definition}

\begin{proposition}
  $\evalt$ gives a rig biequivalence between $\PiCat$ and $\PiPlusCat$.
\end{proposition}

\subsection{$\PiPlusLang$ to $\PiHatLang$}

Next, we show how to translate $\PiPlusLang$ programs to $\PiHatLang$ and back. $\PiHatLang$ is a simplified variant of
$\PiPlusLang$, with (unary) natural numbers for 0-cells, 1-combinators generated by adjacent transpositions, and an
appropriate set of 2-combinators. We give the syntax, again omitting 2-combinators, in~\Cref{fig:pihat}.

\begin{figure}[t]
  {\scalebox{\scalef}{$
        \begin{array}{rrcll}
          \idc :   & n             & \isoh & n             & : \idc   \\
          \swapc : & \suc[\suc[n]] & \isoh & \suc[\suc[n]] & : \swapc \\
        \end{array}
      $}}

  {\scalebox{\scalef}{
      \Rule{}
      {\jdg{}{}{c_1 : n \isoh m} \quad \vdash c_2 : m \isoh o}
      {\jdg{}{}{c_1 \fatsemi c_2 : n \isoh o}}
      {}

      \Rule{}
      {\jdg{}{}{c : n \isoh m}}
      {\jdg{}{}{\oplus(c) : \suc[n] \isoh \suc[m]}}
      {}
    }}
  \caption{$\PiHatLang$ syntax}
  \label{fig:pihat}
\end{figure}

As described, $\PiHatLang$ doesn't have a tensor product, but we can build it simply by adding up natural numbers, and,
we need to verify that this indeed equips $\PiHatCat$ with a symmetric monoidal structure. Since each object is a
natural number generated by $\zero$ and $\suc$, this makes $\PiHatCat$ similar to a \emph{PROP}, that is, a products and
permutations category.

\begin{proposition}
  $\PiHatCat$ has a symmetric monoidal structure, with the unit given by 0 and the tensor product given by natural
  number addition.
\end{proposition}

Using this symmetric monoidal structure, we translate from $\PiPlusLang$ to $\PiHatLang$.

\begin{definition}
  \begin{align*}
    \evalp_{0} & : \UPlus \to \UHat                                                          \\
    \evalp_{1} & : (c : t_{1} \iso t_{2}) \to \evalp_{0}(t_{1}) \isoh \evalp_{0}(t_{2})      \\
    \evalp_{2} & : (\alpha : c_{1} \Iso c_{2}) \to \evalp_{1}(c_{1}) \Isoh \evalp_{1}(c_{2})
  \end{align*}
\end{definition}

To go back from $\PiHatLang$ to $\PiPlusLang$, we turn a natural number into a $\PiPlusLang$ type, using right-biased
addition, that is, the natural number $n$ gets mapped to the type $\onet + (\onet + (\onet + \ldots + \zerot))$. The
non-trivial part is coherently generating a $\PiPlusLang$ combinator from $\PiHatLang$ combinators, using adjacent swaps
to generate the braiding.

\begin{definition}
  \begin{align*}
    \quotep_{0} & : \UHat \to \UPlus                                                            \\
    \quotep_{1} & : (p : X_{1} \isoh X_{2}) \to \quotep_{0}(X_{1}) \iso \quotep_{0}(X_{2})      \\
    \quotep_{2} & : (\alpha : p_{1} \Isoh p_{2}) \to \quotep_{1}(p_{1}) \Iso \quotep_{1}(p_{2})
  \end{align*}
\end{definition}

\begin{proposition}
  $\evalp/\quotep$ give a symmetric monoidal biequivalence between $\PiPlusCat$ and $\PiHatCat$.
\end{proposition}

\subsection{$\PiHatLang$ to $\UFin$}

Finally, we show how to interpret $\PiHatLang$ to $\UFin$, and go back from $\UFin$ to $\PiHatLang$.

Types in $\PiHatLang$ are interpreted as 0-cells in $\UFin$, that is, a natural number $n$ is mapped to $\Fin[n]$. The
1-combinators in $\PiHatLang$ are mapped to 1-paths in $\UFin$, that is, 1-loops $\Aut[\Fin[n]]$, in each connected
component. In $\PiHatLang$, the 1-combinators are generated by adjacent transpositions, so these can be easily mapped to
words in $\Sn$ and then to automorphisms using~\Cref{prop:sn-lehmer-fin-equiv}. Finally, 2-combinators are mapped to
2-paths between loops in $\UFin$.

\begin{definition}
  \begin{align*}
    \evalh_{0} & : \UHat \to \UFin                                                          \\
    \evalh_{1} & : (c : t_{1} \isoh t_{2}) \to \evalh_{0}(t_{1}) \id \evalh_{0}(t_{2})      \\
    \evalh_{2} & : (\alpha : c_{1} \Isoh c_{2}) \to \evalh_{1}(c_{1}) \id \evalh_{1}(c_{2})
  \end{align*}
\end{definition}

0-cells in $\UFin$ are mapped to their cardinalities in $\PiHatLang$, 1-loops are decoded to words in $\Sn$ to generate
a sequence of adjacent transpositions, producing a 1-combinator in $\PiHatLang$. Finally, 2-paths are quoted back to
2-combinators in $\PiHatLang$.

\begin{definition}
  \begin{align*}
    \quoteh_{0} & : \UFin \to \UHat                                                            \\
    \quoteh_{1} & : (p : X_{1} \id X_{2}) \to \quoteh_{0}(X_{1}) \isoh \quoteh_{0}(X_{2})      \\
    \quoteh_{2} & : (\alpha : p_{1} \id p_{2}) \to \quoteh_{1}(p_{1}) \Isoh \quotet_{1}(p_{2})
  \end{align*}
\end{definition}

$\UFin$ as a 1-groupoid, is a (locally strict) weak $(2,0)$-category, and we use this to state our final equivalence.

\begin{proposition}
  $\evalh/\quoteh$ give a symmetric monoidal biequivalence between $\PiHatCat$ and $\UFin$.
\end{proposition}

The semantics that we presented here takes a different route to constructing the permutation from a $\PiLang$
combinator, compared to the direct interpretation given using the big-step interpreter in~\Cref{subsec:denotational}. We
verify that the two semantics agree, establishing that the semantics is adequate and fully abstract.

\begin{definition}[${\gdenot{\blank}} : U \to {\UFin}$]
  \begin{gather*}
    \begin{aligned}
      \gdenot{\blank}_{0} &\defeq \evalh_{0} \comp \evalp_{0} \comp \evalt_{0}
    \end{aligned}
    \qquad
    \begin{aligned}
      \gdenot{\blank}_{1} &\defeq \evalh_{1} \comp \evalp_{1} \comp \evalt_{1}
    \end{aligned}
  \end{gather*}
\end{definition}

\begin{proposition}
  If $c_1, c_2 : X \iso Y$, then $\denot{c_1} = \denot{c_2}$ iff $\gdenot{c_1}_{1} = \gdenot{c_2}_{1}$.
\end{proposition}

\section{Normalisation of Reversible Circuits}
\label{sec:applications}

Using our semantics, we can normalise, synthesise, prove equivalence, and generally reason about~$\PiLang$
programs. The two key definitions are presented below.

\begin{definition}[Normalisation of $\PiLang$ programs]
  \begin{gather*}
    \begin{aligned}
      \normt_{0} & : U \to \UPlus                                            \\
      \normt_{0} & = \quotep_{0} \comp \quoteh_{0} \comp \gdenot{\blank}_{0}
    \end{aligned}
    \qquad
    \begin{aligned}
      \normt_{1} & : (c : X \iso Y) \to \normt_{0}(X) \iso \normt_{0}(Y)     \\
      \normt_{1} & = \quotep_{1} \comp \quoteh_{1} \comp \gdenot{\blank}_{1}
    \end{aligned}
  \end{gather*}
\end{definition}

\noindent Normalisation consists of translating $\PiLang$ programs to $\PiHatLang$, computing a permutation, and quoting
back to $\PiPlusLang$. Note that the normalisation happens in the step from $\PiHatLang$ to $\UFin$ and back to
$\PiHatLang$ and that normalisation also provides a decision procedure for program equivalence. Synthesis consists of
quoting permutations. More general, user-guided, reasoning can be done using the sound and complete level-2
combinators to rewrite $\PiLang$ programs.

Recall the specification of reversible disjunction from \Cref{sec:examples}, the two Qiskit circuits for implementing it, and the
corresponding $\PiLang$ definitions \Afun{reversibleOr1} and \Afun{reversibleOr2}. The normal for both circuit is
computed to be, establishing their equivalence:

\medskip
\resetnormtwo{}

Instead of manually producing $\Pi$-programs to implement the reversible disjunction specification, it is also possible
to simply quote the desired permutation:

\medskip
\resetperm{}

\noindent The permutation uses the canonical encoding of sequences of bits as natural numbers (e.g., (\textsf{false},
\textsf{true},\textsf{true}) is encoded as 011 or 3).  The second entry maps index 1 (= 001) to the value 5 (= 101)
which states that since one of the right bits is set in 001 then the leftmost bit in the output is set. Quoting this
permutation generates the same normalised program which can then be composed with a map from $\PiLang$ to
$\PiPlusLang$ to produce a program matching the desired structured types.

% \paragraph*{Program synthesis.} The NbE process embodies a quoting mechanism that synthesizes programs from
% permutations. Indeed, instead of writing a program for \Afun{reset 2}, one could simply specify the desired permutation
% as:

%%\begin{minipage}{.65\textwidth}
%%  \PiRESET{}
%%\end{minipage}
%%\begin{minipage}{.30\textwidth}
%%  \begin{center}
%%  \resizebox{0.5\textwidth}{!}{\input{diagrams/reset.tikz}}
%%  \end{center}
%%\end{minipage}

%% \resettwo{}

% \noindent The syntax will be explained in detail in the next section and the full definitions of the helpers are
% provided in the supplementary material. For now, it is sufficient to know that there is some program that implements the
% reversible function of interest and that applying \Afun{reset} to 2 produces \verb|reversibleOr2| from the introduction.

% In principle, the normalised program can be produced following two strategies: (i) by repeatedly applying the rewrite
% rules of our calculus of reversible functions (explained in Sec.~\ref{sec:reversibletwo}), or (ii) in the case above by
% using a NbE process that evaluates the program to a permutation on a finite set of 8
% elements and reifies that permutation back to a program. The key idea of the NbE process is a systematic way to express
% permutations as sequences of adjacent swaps as illustrated in the following small example where the permutation on the
% left is compiled to the sequence of four adjacent transpositions on the right:

% \note{Motivation: There are two reversible circuits which describe the following permutation. They can be shown to be
%   equal using the 2-combinators.}

% \[
%   \begin{tikzpicture}
%     \begin{knot}[clip width=5]
%       \filldraw (0,5) circle (2pt) node[above] {0};
%       \filldraw (1,5) circle (2pt) node[above] {1};
%       \filldraw (2,5) circle (2pt) node[above] {2};
%       \filldraw (3,5) circle (2pt) node[above] {3};
%       \filldraw (4,5) circle (2pt) node[above] {4};
%       \filldraw (0,0) circle (2pt) node[below] {1};
%       \filldraw (1,0) circle (2pt) node[below] {4};
%       \filldraw (2,0) circle (2pt) node[below] {0};
%       \filldraw (3,0) circle (2pt) node[below] {3};
%       \filldraw (4,0) circle (2pt) node[below] {2};
%       \strand (0,5) .. controls (0.5,0.5) and (1.5,3.5) .. (2,0);
%       \strand (1,5) .. controls (0.75,0.5) and (0.25,3.5) .. (0,0);
%       \strand (2,5) .. controls (2.5,2.5) and (3.5,1.5) .. (4,0);
%       \strand (3,5) .. controls (4.5,2.5) and (4,1.5) .. (3,0);
%       \strand (4,5) .. controls (3.5,2.5) and (1.5,2.5) .. (1,0);
%       \flipcrossings{4,5};
%     \end{knot}
%   \end{tikzpicture}
% \]

% \paragraph*{Program equivalence.} The permutation above reveals another way to think about the desired program: it is a
% special addition circuit that keeps 0 and 4 fixed but otherwise adds 4 modulo 8 to its input. From this specification,
% one can use a standard synthesis algorithm for reversible circuits~\cite{10.1145/775832.775915} to generate the
% following program:

% \adder{}

% \noindent The \Afun{adder3} program looks nothing like the original \Afun{reset 2} program and yet they both have the
% same normal form thus establishing their equivalence. The reader can check that this circuit is the same as
% \verb|reversibleOr1| from the introduction.

% Now imagine we want to write the following reversible function:

% 0 -> 0
% 8 -> 8
% n -> n + 8 `mod` 16

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "main"
%%% fill-column: 120
%%% End:
