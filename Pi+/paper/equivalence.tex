\section{Going from \texorpdfstring{$\PiLang$}{Pi} to \texorpdfstring{$\UFin$}{UFin} and back}
\label{sec:equivalence}

% https://q.uiver.app/?q=WzAsNCxbMCwwLCJcXFBpTGFuZyJdLFsyLDAsIlxcUGlQbHVzTGFuZyJdLFs0LDAsIlxcUGlIYXRMYW5nIl0sWzYsMCwiXFxVRmluIl0sWzAsMSwiXFxldmFsdCJdLFsxLDIsIlxcZXZhbGgiLDAseyJjdXJ2ZSI6LTR9XSxbMiwzLCJcXGV2YWx0IiwwLHsiY3VydmUiOi00fV0sWzIsMSwiXFxxdW90ZWgiLDAseyJjdXJ2ZSI6LTR9XSxbMywyLCJcXHF1b3RldCIsMCx7ImN1cnZlIjotNH1dXQ==
\[\begin{tikzcd}
    \PiLang && \PiPlusLang && \PiHatLang && \UFin
    \arrow["\evalt", from=1-1, to=1-3]
    \arrow["\evalp", curve={height=-24pt}, from=1-3, to=1-5]
    \arrow["\evalh", curve={height=-24pt}, from=1-5, to=1-7]
    \arrow["\quotep", curve={height=-24pt}, from=1-5, to=1-3]
    \arrow["\quoteh", curve={height=-24pt}, from=1-7, to=1-5]
  \end{tikzcd}\]

\vc{ The groupoid of finite types is the free symmetric monoidal groupoid on one generator. This can be presented as an
  algebraic 2-theory, which is our syntax for $\PiHatLang$. Vertical categorification of natural numbers as a free
  commutative monoid. See groupoidification. }

In this section, we consider the additive fragment $\PiPlusLang$ of $\PiLang$. This is the language that we interpret to
$\UFin$ and back, using the tools developed in the previous sections. Further, we go through an intermediate step of the
language $\PiHatLang$, which is a simplified variant of $\PiPlusLang$ that uses adjacent transpositions for combinators,
while preserving all the required structure.

We present the types and 1-combinators of $\PiPlusLang$ and $\PiHatLang$ in~\cref*{fig:piplus,fig:pihat} respectively,
eliding the 2-combinators for brevity. \note{We enforce that there is a unique 2-combinator between compatible
  1-combinators, by introducing a level 3, which is trivial in the same way as in the case of $\PiLang$, as described
  before.} They can be found in the appendix and in the accompanying Agda code.

The translations between the languages are defined separately on types, 1-combinators, and 2-combinators. Following the
terminology of Normalisation by Evaluation, the translations from the left to the right, going from the syntax towards
the semantics, are called $\evalt$ and the translations the other way are called $\quotet$.

To state our results formally, we organise the syntax for each language using a technical device, called a syntactic
category. Since the language have higher-dimensional structure, the syntactic categories here are actually
(locally-strict) weak 2-categories. We define them formally in the appendix, and only state our results here.

For each of the $\PiLang$, $\PiPlusLang$ and $\PiHatLang$ languages, their syntactic categories, respectively $\PiCat$,
$\PiPlusCat$ and $\PiHatCat$, have 0-cells for types, 1-cells for 1-combinators, and 2-cells for 2-combinators. We can
show that these are $(2,0)$-categories, since all the 1-cells and 2-cells are invertible. They are also locally-strict,
or locally-posetal, because there is at most one 2-cell between compatible 1-cells.

\begin{toappendix}
  \todo{What is U?}
  \begin{proposition}
    We can form a weak 2-category $\PiCat$ with
    \begin{itemize}
      \item $\PiLang$ types for 0-cells,
      \item for $X, Y : U$, a collection of 1-cells $X \iso Y$,
      \item for $p, q : X \iso Y$, a collection of 2-cells $p \Iso q$.
    \end{itemize}
  \end{proposition}

  \begin{proposition}
    We can form a weak 2-category $\PiPlusCat$ with
    \begin{itemize}
      \item $\PiPlusLang$ types for 0-cells,
      \item for $X, Y : \UPlus$, a collection of 1-cells $X \isop Y$,
      \item for $p, q : X \isop Y$, a collection of 2-cells $p \Isop q$.
    \end{itemize}
  \end{proposition}

  \begin{proposition}
    We can form a weak 2-category $\PiHatCat$ with
    \begin{itemize}
      \item $\PiHatCat$ types for 0-cells,
      \item for $X, Y : \UHat$, a collection of 1-cells $X \isoh Y$,
      \item for $p, q : X \isoh Y$, a collection of 2-cells $p \Isoh q$.
    \end{itemize}
  \end{proposition}
\end{toappendix}

We use the $\evalt/\quotet$ translation maps to construct functors between these categories. We only name the maps on
the 0, 1, and 2-cells -- the coherences hold by definition or by calculation, which is shown in our accompanying Agda
code. We use these functors to state our results establishing the equivalences between the languages.

\subsection{$\PiLang$ to $\PiPlusLang$}

First, we show how to translate $\PiLang$ programs to $\PiPlusLang$, which is the additive fragment of $\PiLang$. The
syntax is given in~\cref{fig:piplus}.

\begin{figure}[t]
  {\scalebox{\scalef}{$
        \begin{array}{rrcll}
          \idc :     & A           & \iso & A           & : \idc     \\
          \identlp : & \zerot + A  & \iso & A           & : \identrp \\
          \swapp :   & A + B       & \iso & B + A       & : \swapp   \\
          \assoclp : & A + (B + C) & \iso & (A + B) + C & : \assocrp \\ [1.5ex]
        \end{array}$}}

  {\scalebox{\scalef}{
      \Rule{}
      {\jdg{}{}{c_1 : A \iso B} \quad \vdash c_2 : B \iso C}
      {\jdg{}{}{c_1 \fatsemi c_2 : A \iso C}}
      {}

      \Rule{}
      {\jdg{}{}{c_1 : A \iso B} \quad \vdash c_2 : C \iso D}
      {\jdg{}{}{c_1 \oplus c_2 : A + C \iso B + D}}
      {}
    }}
  \caption{$\PiPlusLang$ syntax}
  \label{fig:piplus}
\end{figure}

$\PiLang$ has two 0-ary type constructors, and two binary type constructors -- the additive tensor product and the
multiplicative one. $\PiPlusLang$ has all the type constructors of $\PiLang$ except multiplication. However, we will
show how to recover the multiplicative structure, by defining multiplication as repeated addition. We encode $\times$ in
terms of $+$ as follows.

\begin{definition}[$\times : \UPlus \to \UPlus \to \UPlus$]
  \begin{align*}
    \zerot \times Y      & \defeq \zerot                      \\
    \onet \times Y       & \defeq Y                           \\
    (X_1 + X_2) \times Y & \defeq X_1 \times Y + X_2 \times Y
  \end{align*}
\end{definition}

\begin{proposition}
  There are two symmetric monoidal structures on $\PiPlusCat$, given by $(\zerot, +)$ and $(\onet, \times)$, with
  $\times$ distributing over $+$, giving it a rig structure, as described in \todo{cite earlier section}.
\end{proposition}
\todo{either prove it or cite something}

Using this rig structure, we translate $\PiLang$ to $\PiPlusLang$, constructing a rig functor from $\PiCat$ to
$\PiPlusCat$.

\begin{definition}
  \begin{align*}
    \evalt_{0} & : U \to \UPlus                                             \\
    \evalt_{1} & : (c : X \iso Y) \to \evalt_{0}(X) \iso \evalt_{0}(Y)      \\
    \evalt_{2} & : (\alpha : p \Iso q) \to \evalt_{1}(p) \Iso \evalt_{1}(q) \\
  \end{align*}
\end{definition}

\subsection{$\PiPlusLang$ to $\PiHatLang$}

Next, we show how to translate $\PiPlusLang$ programs to $\PiHatLang$ and back. $\PiHatLang$ is a simplified variant of
$\PiPlusLang$, with (unary) natural numbers for 0-cells, 1-combinators generated by adjacent transpositions, and an
appropriate set of 2-combinators. We give the syntax, again omitting 2-combinators, in~\cref{fig:pihat}.

\begin{figure}[t]
  {\scalebox{\scalef}{$
        \begin{array}{rrcll}
          \idc :   & n             & \isoh & n             & : \idc   \\
          \swapc : & \suc[\suc[n]] & \isoh & \suc[\suc[n]] & : \swapc \\
        \end{array}
      $}}

  {\scalebox{\scalef}{
      \Rule{}
      {\jdg{}{}{c_1 : n \isoh m} \quad \vdash c_2 : m \isoh o}
      {\jdg{}{}{c_1 \fatsemi c_2 : n \isoh o}}
      {}

      \Rule{}
      {\jdg{}{}{c : n \isoh m}}
      {\jdg{}{}{\oplus(c) : \suc[n] \isoh \suc[m]}}
      {}
    }}
  \caption{$\PiHatLang$ syntax}
  \label{fig:pihat}
\end{figure}

As described, $\PiHatLang$ doesn't have a tensor product, but we can build it simply by adding up natural numbers, and,
we need to verify that this indeed equips $\PiHatCat$ with a symmetric monoidal strucuture. Since each object is a
natural number generated by $\zero$ and $\suc$, this makes $\PiHatCat$ similar to a \emph{PROP}, that is, a products and
permutations category.

\begin{proposition}
  $\PiHatCat$ has a symmetric monoidal structure, with the unit given by 0 and the tensor product given by natural
  number addition.
\end{proposition}

Using this symmetric monoidal structure, we translate from $\PiPlusLang$ to $\PiHatLang$.

\begin{definition}
  \begin{align*}
    \evalh_{0} & : \UPlus \to \UHat                                                          \\
    \evalh_{1} & : (c : t_{1} \iso t_{2}) \to \evalh_{0}(t_{1}) \isoh \evalh_{0}(t_{2})      \\
    \evalh_{2} & : (\alpha : c_{1} \Iso c_{2}) \to \evalh_{1}(c_{1}) \Isoh \evalh_{1}(c_{2}) \\
  \end{align*}
\end{definition}

To go back from $\PiHatLang$ to $\PiPlusLang$, we turn a natural number into a $\PiPlusLang$ type, using right-biased
addition, that is, the natural number $n$ gets mapped to the type $\onet + (\onet + (\onet + \ldots + \zerot))$. The
non-trivial part is coherently generating a $\PiPlusLang$ combinator from $\PiHatLang$ combinators, using adjacent swaps
to generate the braiding.

\begin{definition}
  \begin{align*}
    \quoteh_{0} & : \UHat \to \UPlus                                                            \\
    \quoteh_{1} & : (p : X_{1} \isoh X_{2}) \to \quoteh_{0}(X_{1}) \iso \quoteh_{0}(X_{2})      \\
    \quoteh_{2} & : (\alpha : p_{1} \Isoh p_{2}) \to \quoteh_{1}(p_{1}) \Iso \quoteh_{1}(p_{2}) \\
  \end{align*}
\end{definition}

\begin{proposition}
  $\evalh/\quoteh$ give a symmetric monoidal biequivalence between $\PiPlusCat$ and $\PiHatCat$.
\end{proposition}

\subsection{$\PiHatLang$ to $\UFin$}

Finally, we show how to interpret $\PiHatLang$ to $\UFin$, and go back from $\UFin$ to $\PiHatLang$.

\todo{Sn/Lehmer/Aut(Fin n) diagram here?}

Types in $\PiHatLang$ are interpreted as 0-cells in $\UFin$, that is, a natural number $n$ is mapped to $\Fin[n]$. The
1-combinators in $\PiHatLang$ are mapped to 1-paths in $\UFin$, that is, 1-loops $\Aut[\Fin[n]]$, in each connected
component. In $\PiHatLang$, the 1-combinators are generated by adjacent transpositions, so these can be easily mapped to
words in $\Sn$ and then to automorphisms using~\cref{prop:sn-lehmer-fin-equiv}. Finally, 2-combinators are mapped to
2-paths between loops in $\UFin$.

\begin{definition}
  \begin{align*}
    \evalt_{0} & : \UHat \to \UFin                                                          \\
    \evalt_{1} & : (c : t_{1} \isoh t_{2}) \to \evalh_{0}(t_{1}) \id \evalh_{0}(t_{2})      \\
    \evalt_{2} & : (\alpha : c_{1} \Isoh c_{2}) \to \evalt_{1}(c_{1}) \id \evalt_{1}(c_{2}) \\
  \end{align*}
\end{definition}

0-cells in $\UFin$ are mapped to their cardinalities in $\PiHatLang$, 1-loops are decoded to words in $\Sn$ to generate
a sequence of adjacent transpositions, producing a 1-combinator in $\PiHatLang$. Finally, 2-paths are quoted back to
2-combinators in $\PiHatLang$.

\begin{definition}
  \begin{align*}
    \quotet_{0} & : \UFin \to \UHat                                                            \\
    \quotet_{1} & : (p : X_{1} \id X_{2}) \to \quoteh_{0}(X_{1}) \isoh \quoteh_{0}(X_{2})      \\
    \quotet_{2} & : (\alpha : p_{1} \id p_{2}) \to \quoteh_{1}(p_{1}) \Isoh \quotet_{1}(p_{2}) \\
  \end{align*}
\end{definition}

$\UFin$ as a 1-groupoid, is a (locally strict) weak $(2,0)$-category, and we use this to state our final equivalence.

\begin{proposition}
  $\evalt/\quotet$ give a symmetric monoidal biequivalence between $\PiHatCat$ and $\UFin$.
\end{proposition}

\subsection{$\PiLang$ circuit normalisation}

To normalise a $\PiLang$ circuit, we translate it to $\PiHatLang$, compute a permutation, and quote it back to
$\PiPlusLang$. Note that the normalisation happens in going from $\PiHatLang$ to $\UFin$ and back to $\PiHatLang$.

\begin{definition}
  \begin{align*}
    \normt_{0} & : U \to \UPlus                                        \\
    \normt_{0} & = \quoteh_{0} \comp \evalt_{0}                        \\
    \\
    \normt_{1} & : (c : X \iso Y) \to \normt_{0}(X) \iso \normt_{0}(Y) \\
    \normt_{1} & = \quoteh_{1} \comp \evalt_{1}                        \\
  \end{align*}
\end{definition}

We now revisit the examples in the introduction but instead of working with circuits operating on sequences of bits, we
work with circuits operating on algebraic data types.

\paragraph*{Normalization by evaluation.} Consider the following reversible function:
$\Afun{RESET}(b,b_1,\ldots,b_n) = (b \; \underline{\vee} \; (\bigvee_{i=1}^n b_i),b_1,\ldots,b_n)$ where $\vee$ is
logical-or and $\underline{\vee}$ is exclusive-or. The function sets or resets the first bit depending on whether any of
the other bits is true or not. The natural definition for this function is recursive: modulo some re-shuffling of the
bits, the strategy is to examine the bits $b_i$ one-by-one: if we encounter a true value, we negate the first bit and
terminate; otherwise we continue making recursive calls until we reach the last bit at which point we return the
incoming value with no change:

%%\begin{minipage}{.65\textwidth}
%%  \PiRESET{}
%%\end{minipage}
%%\begin{minipage}{.30\textwidth}
%%  \begin{center}
%%  \resizebox{0.5\textwidth}{!}{\input{diagrams/reset.tikz}}
%%  \end{center}
%%\end{minipage}

\resettwo{}

\noindent The syntax will be explained in detail in the next section and the full definitions of the helpers are
provided in the supplementary material. For now, it is sufficient to know that there is some program that implements the
reversible function of interest and that applying \Afun{reset} to 2 produces \verb|reversibleOr2| from the
introduction. Our Agda infrastructure provides tools to normalize all programs to their normal form. For \Afun{reset 2}
we get:

\resetnormtwo{}

In principle, the normalized program can be produced following two strategies: (i) by repeatedly applying the rewrite
rules of our calculus of reversible functions (explained in Sec.~\ref{sec:reversibletwo}), or (ii) in the case above by
using a normalization-by-evaluation (NbE) process that evaluates the program to a permutation on a finite set of 8
elements and reifies that permutation back to a program. The key idea of the NbE process is a systematic way to express
permutations as sequences of adjacent swaps as illustrated in the following small example where the permutation on the
left is compiled to the sequence of four adjacent transpositions on the right:

% \note{Motivation: There are two reversible circuits which describe the following permutation. They can be shown to be
%   equal using the 2-combinators.}

% \[
%   \begin{tikzpicture}
%     \begin{knot}[clip width=5]
%       \filldraw (0,5) circle (2pt) node[above] {0};
%       \filldraw (1,5) circle (2pt) node[above] {1};
%       \filldraw (2,5) circle (2pt) node[above] {2};
%       \filldraw (3,5) circle (2pt) node[above] {3};
%       \filldraw (4,5) circle (2pt) node[above] {4};
%       \filldraw (0,0) circle (2pt) node[below] {1};
%       \filldraw (1,0) circle (2pt) node[below] {4};
%       \filldraw (2,0) circle (2pt) node[below] {0};
%       \filldraw (3,0) circle (2pt) node[below] {3};
%       \filldraw (4,0) circle (2pt) node[below] {2};
%       \strand (0,5) .. controls (0.5,0.5) and (1.5,3.5) .. (2,0);
%       \strand (1,5) .. controls (0.75,0.5) and (0.25,3.5) .. (0,0);
%       \strand (2,5) .. controls (2.5,2.5) and (3.5,1.5) .. (4,0);
%       \strand (3,5) .. controls (4.5,2.5) and (4,1.5) .. (3,0);
%       \strand (4,5) .. controls (3.5,2.5) and (1.5,2.5) .. (1,0);
%       \flipcrossings{4,5};
%     \end{knot}
%   \end{tikzpicture}
% \]

\paragraph*{Program synthesis.} The NbE process embodies a quoting mechanism that synthesizes programs from
permutations. Indeed, instead of writing a program for \Afun{reset 2}, one might simply specify the desired permutation as:

\resetperm{}

\noindent The permutation uses the canonical encoding of sequences of bits as natural numbers (e.g., (\textsf{false},
\textsf{true},\textsf{true}) is encoded as 011 or 3).  The second entry maps index 1 (= 001) to the value 5 (= 101)
which states that since one of the right bits is set in 001 then the leftmost bit in the output is set. Simply
``quoting'' this permutation generates the same normalized program \Afun{reset2Norm} above.

\paragraph*{Program equivalence.} The permutation above reveals another way to think about the desired program: it is a
special addition circuit that keeps 0 and 4 fixed but otherwise adds 4 modulo 8 to its input. From this specification,
one can use a standard synthesis algorithm for reversible circuits~\cite{10.1145/775832.775915} to generate the
following program:

\adder{}

\noindent The \Afun{adder3} program looks nothing like the original \Afun{reset 2} program and yet they both have the
same normal form thus establishing their equivalence. The reader can check that this circuit is the same as
\verb|reversibleOr1| from the introduction.

% Now imagine we want to write the following reversible function:

% 0 -> 0
% 8 -> 8
% n -> n + 8 `mod` 16

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "main"
%%% fill-column: 120
%%% End:
