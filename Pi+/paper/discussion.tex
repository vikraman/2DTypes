\section{Discussion \& Related Work}~\label{sec:discussion}

In this paper, we \ldots


Pi types -- Natural number -- Finite sets
1-combinator -- Generators of Sn -- 1-paths
2-combinator -- Relations of Sn -- 2-paths



Our work lies at the intersection of programming language theory, category theory, group theory, rewriting theory, and
formalised mathematics. We review related work in the literature for each topic.

\paragraph{Algebraic Theories} In universal algebra, algebraic theories are used to describe algebraic structures, such
as groups or rings. A specific group or ring is a model of the appropriate algebraic theory. Algebraic theories are
usually \emph{presented} in terms of logical syntax, that is, as first-order theories whose signatures allow only
functional symbols, and whose axioms are universally quantified equations. In his seminal
thesis~\cite{lawvereFUNCTORIALSEMANTICSALGEBRAIC1963}, Lawvere defined a presentation-free categorical notion of
universal algebraic structure, called a Lawvere theory.

Programming Languages, such as the $\lambda$-calculus, can be viewed as algebraic structures with variable-binding
operators, which can be formalised using second-order algebraic theories~\cite{fioreSecondOrderAlgebraicTheories2010},
or algebraic theories with closed structure~\cite{hylandClassicalLambdaCalculus2017}, called $\lambda$-theories, making
the $\lambda$-calculus the presentation of the initial $\lambda$-theory $\Lambda$.

Our family of reversible languages have been presented as first-order algebraic
2-theories~\cite{cohenCoherenceRewriting2theories2009,bekeCategorificationTermRewriting2011,yanofskySyntaxCoherence2000},
which are a categorification of algebraic theories. The types $\zerot$ and $\onet$ are nullary function symbols, the
type formers $+$ and $\times$ are binary function symbols, the 1-combinators are invertible reduction rules, and the
2-combinators are equations or coherence diagrams of compositions of reduction rules. Just like models of Lawvere
theories are given by algebras of (finitary) monads on $\SetCat$, models of 2-theories are given by algebras of 2-monads
on $\CatCat$. The particular one we're interested in here is the free symmetric monoidal completion 2-monad.

\paragraph{Free Symmetric Monoidal Category} The forgetful functor from $\SymMonCat$, the 2-category of (small)
symmetric monoidal categories, strong symmetric monoidal functors, and symmetric monoidal natural transformations, to
the 2-category $\CatCat$, has a left adjoint giving the free symmetric monoidal category $\FSM[\CCat{C}]$ on a category
$\CCat{C}$. This is a 2-monad on $\CatCat$~\cite{blackwellTwodimensionalMonadTheory1989}, and its construction is known
in the literature~\cite{abramskyAbstractScalarsLoops2005}. Concretely, the objects of $\FSM[\CCat{C}]$ are given by
lists of objects of $\CCat{C}$, that is, a pair $(n:\Nat, A:[n] \to \CCat{C}_{0})$. An morphism between $(n,A)$ and
$(n,B)$ is given by a pair $(\pi,\lambda)$ where $\pi$ is a permutation of $[n]$, and
$\lambda_{i} : A_{i} \to B_{\pi(i)}$ for $1 \leq i \leq n$. Abstractly, this is given by the Grothendieck construction
$\int F$ of the functor $F : \BFin \to \CatCat$ from the groupoid of finite sets and bijections to $\CatCat$, assigning
each natural number $n$ to the $n$-power $C^{n}$ of $C$, and each permutation on $[n]$ inducing an endofunctor on
$C^{n}$ by action. $\BFin$ is the free symmetric monoidal category (groupoid) on one generator, $\FSM[\unit]$. The free
symmetric monoidal category has been used to study concurrency~\cite{hylandSymmetricMonoidalSketches2004}, petri
nets~\cite{baezCategoriesNets2021}, combinatorial structures~\cite{fioreCartesianClosedBicategory2008}, quantum
mechanics~\cite{abramskyAbstractScalarsLoops2005}, bicategorical models of (differential) linear
logic~\cite{melliesTemplateGamesDifferential2019}. In HoTT, the free symmetric monoidal groupoid $\FSM[A]$ over a
groupoid $A$ can be given by $\dsum{X:\UFin}{A^{X}}$, or it can be presented as an algebraic 2-theory using 1-HITs.
These HITs and the proof of their universal property have been considered
in~\citet*{piceghelloCoherenceSymmetricMonoidal2019,choudhuryFinitemultisetConstructionHoTT2019}.

\paragraph{Curry-Howard-Lambek correspondence} In~\citet{curryCurryEssaysCombinatory1980}, Lambek extended the
Curry-Howard correspondence to cartesian-closed categories. In this work, we have established a correspondence between a
fragment of the $\PiLang$ family of languages and symmetric monoidal groupoids.

\paragraph{Rewriting} There exists an algorithm, due to~\citet{knuthSimpleWordProblems1970}, that, when succeeds,
constructs a well-behaved rewriting system for an arbitrary finite set of (undirected) equations. It did not work for
us, there were too many equations, and proving correctness and termination was intractable.

\paragraph{Computational group theory} Coxeter relations, Sn, other formalisations.

Univalent Subuniverses, Univalent Typoids.

Higher order rewriting theory in constructive type theory.

Free monoids, free commutative monoids, normalisation of monoids.

Coherence problems in type theory, coherence via Well-Foundedness.

Presentation of the free symmetric monoidal groupoid on one generator, proof of Mac Lane's coherence theorem in HoTT.

Alternatively, we can describe them using HITs, prove they have the universal property and hence equivalent.
The full Pi is FSMG 1, and the normalised fragment of Pi is M1.

Applications of FSMG and history of the coherence theorems.

Other proofs of coherence theorems, Joyal-Street.

Pi has other extensions (fractional/negative/recursive types).
What are the free X monoidal structures they're describing?

Using our presentation of $S_{n}$, we can construct the Eilenberg-Maclane space (using a HIT) $K(S_{n},1)$. Then, it
should be true that $\UFin \eqv \sqcup_{n:\Nat} K(S_{n},1)$. This is future work.

Other applications of symmetric groups.

Actions of symmetric groups, permutation groupoids.

\paragraph{Extensional vs. Intensional View of Permutations.}
Although the meaning of a permutation - that is, the specific bijective function
that it represents - is in some sense all there is, manipulating them
syntactically still has its advantages. By writing reversible programs, we think
of them in an intensional way. Comparing two programs for equality by evaluating
them on all points in the domain is a very crude - and maybe even inefficient -
way of doing that. ~\cite{Kuehlmann:2006:RBR:2298470.2300327,10.1007/978-3-540-24605-3_4,Yamashita:2010:FEQ:1835957.1835965}.

It is crude, because there is no way of enforcing additional constraints on the
process of transforming one program into another, and no way of inspecting what
transformation occurred. We can imagine a practical situation in which reversible
circuits admit one kind of optimization FPGA?, but do not admit another,
even though they are equivalent in the extensional sense - or maybe one of these
transformations is cheaper than another, or maybe it is important to know which
transformation did occur for the producer(?) to focus their resources of
improving this kind of transformations. By comparing the circuits extensionally,
the proof object = the path from one into the other - does not have any
structure,  it is just a check that the values match.

On the other hand, even though in general, the equality of circuits requires
exponential time jk{triple check}, the proof object can be still very small.
This creates structure that can possibly be exploited in a heuristic way.
Additionally, if the goal is to convince third-party that two circuits are
the same, we can just present the proof instead of showing the equality directly
- for example, by choosing a particularly short one.

Taking all this into account, it is clear that we must seek a syntactic way of
computing the meaning of the circuit, instead of just directly evaluating it to
$\Aut[\Fin[n]]$ - since when we go back and quote the permutation as a circuit
(in a normal form), there was no "trace" left to see what transformation (what
sequence of 2-paths) maps the old one into the new one.

We are additionally experimenting with user annotations that can guide
the search. Each level-2 combinator can be annotated with various
``cost'' annotations indicating whether it reduces the number of
gates, reduces the number of choice points, or other cost
functions. Then one can ask for a proof that takes no more than a
certain number of steps or a proof that does not create more than a
certain number of additional wires etc. We illustrate these ideas by
defining a simple cost function and using it to annotate level-2
combinators.

We define the \emph{length} $L(c)$ of a composite circuit $c$ as
follows: the length of a sequential composition of circuits is the sum
of the lengths of the subcircuits $L(f \odot g) = L(f) + L(g)$; and
the length of choice or parallel composition is the maximum of either
branch $L(f \oplus g) = L(f \otimes g) = \max(L(f),L(g))$. For
primitive gates, the length needs to be postulated to reflect the
``length'' of the computation involved in applying that primitive. As
examples, consider the following two level-2 combinators:

% \begin{code}
% linv◎l'  :  {t₁ t₂ : U} {c : t₁ ⟷ t₂} → (c ◎ ! c) ⇔ id⟷
% idl◎l'   :  {t₁ t₂ : U} {c : t₁ ⟷ t₂} → (id⟷ ◎ c) ⇔ c
% \end{code}
% \AgdaHide{
% \begin{code}
% linv◎l'  = ?
% idl◎l'   = ?
% \end{code}
% }

\noindent Assuming that $\idc$ takes a unit length of computation, the
first can be annotated with $L(c)*2 \isotwo 1$ and the second with $L(c)+1 \isotwo
L(c)$ indicating that the first combinator reduces the length of the
circuit from twice the length of $c$ to 1 and the second combinator
reduces the length of the circuit by 1. Such annotations can then be
used to constrain or guide the search for transformations between
circuits.



%%% Local Variables:
%%% mode: latex
%%% TeX-master: "main"
%%% fill-column: 120
%%% End:
