\section{Discussion \& Related Work}
\label{sec:discussion}

% In this paper, we \ldots

The main theme of our work is the semantic foundation of reversible languages. We prove that a programming language
presentation of reversible programming based on algebraic types matches---exactly---the categorified group-theoretic
semantics, thereby closing the circle on a complete Curry-Howard-Lambek correspondence for reversible
languages. Historically, the first such correspondence was between the $\lambda$-calculus, intuitionistic logic, and
cartesian-closed categories~\cite{curryCurryEssaysCombinatory1980}. For reversible languages, the Curry-Howard
correspondence was established by~\citet{sparksSuperstructuralReversibleLogic2014} and the Lambek correspondence
suggested by~\citet{Carette2016} and~\citet{threemodels} and established in this work.

In the remainder of this section, we discuss some broader related work.

% \begin{center}
%     \begin{tabular}{c c c}
%         \hline
%         $\PiLang$     & $\Sn$               & $\UFin$     \\
%         \hline
%         types         & Natural numbers     & Finite sets \\
%         \hline
%         1-combinators & Generators of $\Sn$ & 1-paths     \\
%         \hline
%         2-combinators & Relations of $\Sn$  & 2-paths     \\
%         \hline
%     \end{tabular}
% \end{center}

% \begin{center}
%     \begin{tabular}{c c c}
%         \hline
%         Logic                              & Program                       & Algebra                     \\
%         \hline
%         Propositions                       & Types                         & Objects                     \\
%         \hline
%         Proofs                             & Terms                         & Morphisms                   \\
%         \hline
%         $\blank$                           & Equations                     & Homotopies                  \\
%         \hline
%         Intuitionistic propositional logic & Simply typed Lambda Calculus  & Cartesian Closed Categories \\
%         \hline
%         Superstructural Reversible logic   & Reversible Language $\PiLang$ & Symmetric Rig Groupoids     \\
%         \hline
%         Connectives                        & Type constructors             & Bifunctors                  \\
%         \hline
%         ?                                  & Type normalisation            & ?                           \\
%         \hline
%         ?                                  & Program normalisation         & ?                           \\
%         \hline
%         ?                                  & Soundness of 2-combinators    & ?                           \\
%     \end{tabular}
% \end{center}

% \begin{center}
%     \begin{tabular}{c c c}
%         \hline
%         Reversible Logic             & Reversible Programming                  & Algebra                  \\
%         \hline
%         Free commutative rig         & Free symmetric rig groupoid             & $\UFin$                  \\
%         \hline
%         Propositions                 & Types                                   & Objects                  \\
%         \hline
%         Entailment?                  & Reversible programs                     & Isomorphisms             \\
%         \hline
%         $\blank$                     & 2-combinators                           & Homotopies               \\
%         \hline
%         Conjunction?                 & $\times$                                & $\otimes$                \\
%         \hline
%         Disjunction?                 & $+$                                     & $\oplus$                 \\
%         \hline
%         $A \land B \vdash B \land A$ & $\swapt$                                & $\mathcal{B}_{A,B}$      \\
%         \hline
%         True proposition             & $\onet$                                 & $F_1$                    \\
%         \hline
%         Decidability                 & Program Synthesis                       & Reachability in a graph? \\
%         \hline
%         Soundness/Completeness       & Soundness/Completeness of 1-combinators & ?                        \\
%     \end{tabular}
% \end{center}

%%%%%%%%%%%%%%
\paragraph{Rewriting} Higher-order term-rewriting systems and word problems have a long history of being formalised in
proof assistants like {homotopy.io}, Lean, Coq, and HoTT~\cite{krausCoherenceWellFoundednessTaming2020}. As part of the
proof of our main result, we developed a rewriting system for the Coxeter relations for $\Sn$ to solve its word problem
and formalised its correctness and termination in Agda. Our design based on encoding permutations as
adjacent transpositions led to an intuitive system whose correctness was straightforward to establish and whose termination
only required slightly modified variations on Church-Rosser theorems. Other encodings of permutations as listed vectors,
matrices, inductively generated trees (Motzkin trees), Young diagrams, or string diagrams, proved either difficult
formalise in type theory or difficult to relate directly to the primitive type isomorphisms of $\PiLang$. The automatic
\citet{knuthSimpleWordProblems1970} completion produced too many equations making proving correctness and termination
intractable.

%%%%%%%%%%%%%%
\paragraph{Computing with Univalence} In HoTT, univalence characterises the path type in the universe as equivalences of
types. The map $\term{idtoeqv} : A \id_{\UU} B \to A \eqv B$ can be easily constructed using path induction. The term
$\term{ua} : A \eqv B \to A \id_{\UU} B$, its computation rule $\term{ua_\beta} : (e : A \eqv B) \to
    \term{idtoeqv}(\term{ua}(e)) \id e$, and its extensionality rule $\term{ua_\eta} : (p : A \id_{\UU} B) \to p ==
    \term{ua}(\term{idtoeqv(p)})$ are generally added as postulates when formalising in Agda. Together, $\term{ua}$ and
$\term{ua}_\beta$ give the full univalence axiom $(A \eqv B) \eqv (A \id_{\UU} B)$.
% Let's think of the $\PiLang$ combinators as describing the inhabitants of the identity type of finite types.
By giving a computable presentation for a univalent subuniverse, we are able to describe its path space syntactically
via a complete equational axiomatisation of the equivalences between types in the subuniverse.
% By the property of being univalent, this subuniverse gives a model of the univalence axiom.
In the subuniverse of finite types, $\term{idtoeqv}$ corresponds to giving a denotation for a program (1-combinator),
which is easily done by induction.  The $\term{ua}$ map corresponds to synthesising a program from an equivalence
(which, in general, is of course undecidable~\cite{krogmeierDecidableSynthesisPrograms2020}). In case of reversible
boolean circuits, it is decidable, as we have shown, but still far from trivial, which matches the need to assert the
existence of $\term{ua}$ without giving a constructive argument. Then, the computation rule $\term{ua_\beta}$ expresses
the fact that program synthesis is sound, while $\term{ua_\eta}$ corresponds to the soundness of the equational theory
($\PiLang$ 2-combinators). Thus, our results suggests a new computational interpretation of the univalence principle, which
provides an intuition on why certain constructions are hard (or impossible in the general case).

% We could present a dependent type theory for the topos $\SetFin$, with an identity type for terms (generated by
% $\refl$), and one for types (generated by $\PiLang$ combinators). We can't talk about universes in $\SetFin$ since it
% doesn't have one, but we could show externally that it satisfies univalence.

% Univalent Fibrations were introduced by~\citet*{kapulkinUnivalenceSimplicialSets2018},
% to build a model of Voevodsky's \emph{univalence} principle in simplicial sets.
% \citet{christensenCharacterizationUnivalentFibrations2015} studied characterisations of univalent fibrations using the
% $\BAut$ construction. Univalent typoids~\cite{petrakisUnivalentTypoids2019a} are a different presentation of univalent
% subuniverses.

%%%%%%%%%%%%%%
% \paragraph{Univalent Fibrations}

% Coherence problems in type theory, coherence via Well-Foundedness.

% Formalised proofs of Mac Lane's coherence theorem.

% Applications of FSMG and history of the coherence theorems.

% Other proofs of coherence theorems, Joyal-Street.

% Pi has other extensions (fractional/negative/recursive types).
% What are the free X monoidal structures they're describing?

% Using our presentation of $S_{n}$, we can construct the Eilenberg-Maclane space (using a HIT) $K(S_{n},1)$. Then, it
% should be true that $\UFin \eqv \sqcup_{n:\Nat} K(S_{n},1)$. This is future work.

% Other applications of symmetric groups.

% Actions of symmetric groups, permutation groupoids.

%%%%%%%%%%%%%%
\paragraph{Algebraic Theories} In universal algebra, algebraic theories are used to describe structures such as groups
or rings. A specific group or ring is a model of the appropriate algebraic theory. Algebraic theories are usually
\emph{presented} in terms of logical syntax, that is, as first-order theories whose signatures allow only functional
symbols, and whose axioms are universally quantified equations. In his seminal thesis,
\citet{lawvereFUNCTORIALSEMANTICSALGEBRAIC1963} defined a presentation-free categorical notion of universal algebraic
structure, called a Lawvere theory. Programming Languages, such as the $\lambda$-calculus, can be viewed as algebraic
structures with variable-binding operators, which can be formalised using second-order algebraic
theories~\cite{fioreSecondOrderAlgebraicTheories2010}, or algebraic theories with closed
structure~\cite{hylandClassicalLambdaCalculus2017}, called $\lambda$-theories, making the $\lambda$-calculus the
presentation of the initial $\lambda$-theory $\Lambda$. Our family of reversible languages $\PiLang$ have been presented
as first-order algebraic
2-theories~\cite{cohenCoherenceRewriting2theories2009,bekeCategorificationTermRewriting2011,yanofskySyntaxCoherence2000},
which are a categorification of algebraic theories. The types $\zerot$ and $\onet$ are nullary function symbols, the
type formers $+$ and $\times$ are binary function symbols, the 1-combinators are invertible reduction rules, and the
2-combinators are equations or coherence diagrams of compositions of reduction rules. Just like models of Lawvere
theories are given by algebras of (finitary) monads on $\SetCat$, models of 2-theories are given by algebras of 2-monads
on $\CatCat$. The particular one related to our development is the free symmetric monoidal completion 2-monad.

%%%%%%%%%%%%%%
\paragraph{Free Symmetric Monoidal Category} The free symmetric monoidal category has been used to study
concurrency~\cite{hylandSymmetricMonoidalSketches2004}, Petri nets~\cite{baezCategoriesNets2021}, combinatorial
structures~\cite{fioreCartesianClosedBicategory2008}, quantum mechanics~\cite{abramskyAbstractScalarsLoops2005}, and
bicategorical models of (differential) linear logic~\cite{melliesTemplateGamesDifferential2019}. The forgetful functor
from $\SymMonCat$, the 2-category of (small) symmetric monoidal categories, strong symmetric monoidal functors, and
monoidal natural transformations, to the 2-category $\CatCat$, has a left adjoint giving the free symmetric monoidal
category $\FSM[\CCat{C}]$ on a category $\CCat{C}$. This is a 2-monad on
$\CatCat$~\cite{blackwellTwodimensionalMonadTheory1989}, whose algebras are (strict) symmetric monoidal categories. Its
construction is known in the literature~\cite{abramskyAbstractScalarsLoops2005}.  Concretely, the objects of
$\FSM[\CCat{C}]$ are given by lists of objects of $\CCat{C}$, that is, a pair $(n:\Nat, A:[n] \to \CCat{C}_{0})$;
morphisms between $(n,A)$ and $(n,B)$ are pairs $(\pi,\lambda)$ where $\pi$ is a permutation of $[n]$, and
$\lambda_{i} : A_{i} \to B_{\pi(i)}$ for $1 \leq i \leq n$. Abstractly, this is given by the Grothendieck construction
$\int F$ of the functor $F : \BFin \to \CatCat$ from the groupoid of finite sets and bijections to $\CatCat$, assigning
each natural number $n$ to the $n$-power $C^{n}$ of $C$, and each permutation on $[n]$ inducing an endofunctor on
$C^{n}$ by action. The groupoid $\BFin$ is the free symmetric monoidal category (groupoid) on one generator, $\FSM[\unit]$.

Coherence and normalisation problems for monoids in constructive type theory using coherence for monoidal categories
were studied by \citet{beylinExtractingProofCoherence1996}. In HoTT, coherence for the free monoidal groupoid over a
groupoid and the proof of its universal property has been considered
by~\citet{piceghelloCoherenceMonoidalGroupoids2020}. Free commutative monoids in type theory have been studied by
\citet{gylterudMultisetsTypeTheory2020}, and using HoTT by \citet{choudhuryFinitemultisetConstructionHoTT2019}. The free
symmetric monoidal groupoid $\FSM[A]$ over a groupoid $A$ can be given by $\dsum*{X:\UFin}{A^{X}}$, or it can be
presented as an algebraic 2-theory using 1-HITs. These HITs and the proof of their universal property have been
considered by \citet{piceghelloCoherenceSymmetricMonoidal2019,choudhuryFinitemultisetConstructionHoTT2019}. The proof of
the universal property of $\FSM$ is asserted by appealing to Mac Lane's coherence theorem for symmetric monoidal
categories, and using the fact that the finite symmetric group $\Sn$ encodes the permutation group on a finite set. The
existence of the proof is folklore. We have produced a proof and formalised it in constructive type theory.

%%%%%%%%%%%%%%
\paragraph{Reversible Programming Languages}

Pi has other extensions (fractional/negative/recursive types).
What are the free X monoidal structures they're describing?



%%%%%%%%%%%%%%
\paragraph{Extensional vs. Intensional View of Permutations.}
Although the meaning of a permutation - that is, the specific bijective function
that it represents - is in some sense all there is, manipulating them
syntactically still has its advantages. By writing reversible programs, we think
of them in an intensional way. Comparing two programs for equality by evaluating
them on all points in the domain is a very crude - and maybe even inefficient -
way of doing that. ~\cite{Kuehlmann:2006:RBR:2298470.2300327,10.1007/978-3-540-24605-3_4,Yamashita:2010:FEQ:1835957.1835965}.

It is crude, because there is no way of enforcing additional constraints on the
process of transforming one program into another, and no way of inspecting what
transformation occurred. We can imagine a practical situation in which reversible
circuits admit one kind of optimization FPGA?, but do not admit another,
even though they are equivalent in the extensional sense - or maybe one of these
transformations is cheaper than another, or maybe it is important to know which
transformation did occur for the producer(?) to focus their resources of
improving this kind of transformations. By comparing the circuits extensionally,
the proof object = the path from one into the other - does not have any
structure,  it is just a check that the values match.

On the other hand, even though in general, the equality of circuits requires
exponential time jk{triple check}, the proof object can be still very small.
This creates structure that can possibly be exploited in a heuristic way.
Additionally, if the goal is to convince third-party that two circuits are
the same, we can just present the proof instead of showing the equality directly
- for example, by choosing a particularly short one.

Taking all this into account, it is clear that we must seek a syntactic way of
computing the meaning of the circuit, instead of just directly evaluating it to
$\Aut[\Fin[n]]$ - since when we go back and quote the permutation as a circuit
(in a normal form), there was no "trace" left to see what transformation (what
sequence of 2-paths) maps the old one into the new one.

We are additionally experimenting with user annotations that can guide
the search. Each level-2 combinator can be annotated with various
``cost'' annotations indicating whether it reduces the number of
gates, reduces the number of choice points, or other cost
functions. Then one can ask for a proof that takes no more than a
certain number of steps or a proof that does not create more than a
certain number of additional wires etc. We illustrate these ideas by
defining a simple cost function and using it to annotate level-2
combinators.

We define the \emph{length} $L(c)$ of a composite circuit $c$ as
follows: the length of a sequential composition of circuits is the sum
of the lengths of the subcircuits $L(f \odot g) = L(f) + L(g)$; and
the length of choice or parallel composition is the maximum of either
branch $L(f \oplus g) = L(f \otimes g) = \max(L(f),L(g))$. For
primitive gates, the length needs to be postulated to reflect the
``length'' of the computation involved in applying that primitive. As
examples, consider the following two level-2 combinators:

% \begin{code}
% linv◎l'  :  {t₁ t₂ : U} {c : t₁ ⟷ t₂} → (c ◎ ! c) ⇔ id⟷
% idl◎l'   :  {t₁ t₂ : U} {c : t₁ ⟷ t₂} → (id⟷ ◎ c) ⇔ c
% \end{code}
% \AgdaHide{
% \begin{code}
% linv◎l'  = ?
% idl◎l'   = ?
% \end{code}
% }

\noindent Assuming that $\idc$ takes a unit length of computation, the
first can be annotated with $L(c)*2 \isotwo 1$ and the second with $L(c)+1 \isotwo
    L(c)$ indicating that the first combinator reduces the length of the
circuit from twice the length of $c$ to 1 and the second combinator
reduces the length of the circuit by 1. Such annotations can then be
used to constrain or guide the search for transformations between
circuits.

\todo{Why is this better than evaluating the permutation and checking each bit?}
\todo{Why care about an equational theory? Compilers, optimisation.}

% %%%%%%%%%%%%%%
% \paragraph{Computational group theory} Coxeter relations are used in computational group theory to study XXX problems.

% \todo{but computation is usually done by using Coxeter matrices~\cite{davisGeometryTopologyCoxeter2008}.}

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "main"
%%% fill-column: 120
%%% End:
