\section{Discussion \& Related Work}
\label{sec:discussion}

% In this paper, we \ldots

\paragraph{Computing with Univalence} In HoTT, univalence characterises the path type in the universe as equivalences of
types. The map $\term{idtoeqv} : A \id_{\UU} B \to A \eqv B$ can be easily constructed using path induction. The term
$\term{ua} : A \eqv B \to A \id_{\UU} B$, its computation rule $\term{ua-\beta} : (e : A \eqv B) \to
    \term{idtoeqv}(\term{ua}(e)) \id e$, and its extensionality rule $\term{ua-\eta} : (p : A \id_{\UU} B) \to p ==
    \term{ua}(\term{idtoeqv(p)})$ are generally added as postulates when formalising in Agda. Together, $\term{ua}$ and
$\term{ua}-\beta$ give the full univalence axiom $(A \eqv B) \eqv (A \id_{\UU} B)$.

% Let's think of the $\PiLang$ combinators as describing the inhabitants of the dentity type of finite types. 

By giving a computable presentation for a univalent subuniverse, we are able to describe the path space of it
syntactically, by giving a complete equational axiomatisation of the equivalences between types in the subuniverse.
% By the property of being univalent, this subuniverse gives a model of the univalence axiom. 
The $\term{idtoeqv}$ corresponds to giving a denotation for a program (1-combinator), which is easily done by induction.
The $\term{ua}$ map corresponds to synthesing a program from an equivalence (which, in general, is of course
undecidable~\cite{krogmeierDecidableSynthesisPrograms2020}). In case of reversible boolean circuits, it is decidable, as
we have shown, but still far from trivial, which matches the need to assert the existence of $\term{ua}$ without giving
a constructive argument. Then, the computation rule $\term{ua-\beta}$ expresses the fact that program synthesis is
sound, while $\term{ua-\eta}$ corresponds to the soundess of the equational theory ($\PiLang$ 2-combinators). Thus, we
this suggests a new computational interpretation of the univalence principle, which provides an intution on why certain
constructions are hard (or impossible in general case).

We could present a dependent type theory for the topos $\SetFin$, with an identity type for terms (generated by
$\refl$), and one for types (generated by $\PiLang$ combinators). We can't talk about universes in $\SetFin$ since it
doesn't have one, but we could show externally that it satisfies univalence.

Our work lies at the intersection of programming language theory, category theory, group theory, rewriting theory, and
formalised mathematics. We review related work in the literature for each topic.

\paragraph{Algebraic Theories} In universal algebra, algebraic theories are used to describe algebraic structures, such
as groups or rings. A specific group or ring is a model of the appropriate algebraic theory. Algebraic theories are
usually \emph{presented} in terms of logical syntax, that is, as first-order theories whose signatures allow only
functional symbols, and whose axioms are universally quantified equations. In his seminal
thesis~\cite{lawvereFUNCTORIALSEMANTICSALGEBRAIC1963}, Lawvere defined a presentation-free categorical notion of
universal algebraic structure, called a Lawvere theory.

Programming Languages, such as the $\lambda$-calculus, can be viewed as algebraic structures with variable-binding
operators, which can be formalised using second-order algebraic theories~\cite{fioreSecondOrderAlgebraicTheories2010},
or algebraic theories with closed structure~\cite{hylandClassicalLambdaCalculus2017}, called $\lambda$-theories, making
the $\lambda$-calculus the presentation of the initial $\lambda$-theory $\Lambda$.

Our family of reversible languages have been presented as first-order algebraic
2-theories~\cite{cohenCoherenceRewriting2theories2009,bekeCategorificationTermRewriting2011,yanofskySyntaxCoherence2000},
which are a categorification of algebraic theories. The types $\zerot$ and $\onet$ are nullary function symbols, the
type formers $+$ and $\times$ are binary function symbols, the 1-combinators are invertible reduction rules, and the
2-combinators are equations or coherence diagrams of compositions of reduction rules. Just like models of Lawvere
theories are given by algebras of (finitary) monads on $\SetCat$, models of 2-theories are given by algebras of 2-monads
on $\CatCat$. The particular one we're interested in here is the free symmetric monoidal completion 2-monad.

\paragraph{Free Symmetric Monoidal Category} The forgetful functor from $\SymMonCat$, the 2-category of (small)
symmetric monoidal categories, strong symmetric monoidal functors, and monoidal natural transformations, to the
2-category $\CatCat$, has a left adjoint giving the free symmetric monoidal category $\FSM[\CCat{C}]$ on a category
$\CCat{C}$. This is a 2-monad on $\CatCat$~\cite{blackwellTwodimensionalMonadTheory1989}, whose algebras are (strict)
symmetric monoidal categories. Its construction is known in the literature~\cite{abramskyAbstractScalarsLoops2005}.
Concretely, the objects of $\FSM[\CCat{C}]$ are given by lists of objects of $\CCat{C}$, that is, a pair $(n:\Nat, A:[n]
    \to \CCat{C}_{0})$. An morphism between $(n,A)$ and $(n,B)$ is given by a pair $(\pi,\lambda)$ where $\pi$ is a
permutation of $[n]$, and $\lambda_{i} : A_{i} \to B_{\pi(i)}$ for $1 \leq i \leq n$. Abstractly, this is given by the
Grothendieck construction $\int F$ of the functor $F : \BFin \to \CatCat$ from the groupoid of finite sets and
bijections to $\CatCat$, assigning each natural number $n$ to the $n$-power $C^{n}$ of $C$, and each permutation on
$[n]$ inducing an endofunctor on $C^{n}$ by action. $\BFin$ is the free symmetric monoidal category (groupoid) on one
generator, $\FSM[\unit]$. The free symmetric monoidal category has been used to study
concurrency~\cite{hylandSymmetricMonoidalSketches2004}, petri nets~\cite{baezCategoriesNets2021}, combinatorial
structures~\cite{fioreCartesianClosedBicategory2008}, quantum mechanics~\cite{abramskyAbstractScalarsLoops2005},
bicategorical models of (differential) linear logic~\cite{melliesTemplateGamesDifferential2019}.

Coherence and normalisation problems for monoids in constructive type theory using coherence for monoidal categories was
studied in~\cite{beylinExtractingProofCoherence1996}. In HoTT, coherence for the free monoidal groupoid over a groupoid
and the proof of its universal property has been considered in~\cite{piceghelloCoherenceMonoidalGroupoids2020}.

Free commutative monoids in type theory have been studied in~\cite{gylterudMultisetsTypeTheory2020}, and using HoTT
in~\cite{choudhuryFinitemultisetConstructionHoTT2019}. The free symmetric monoidal groupoid $\FSM[A]$ over a groupoid
$A$ can be given by $\dsum*{X:\UFin}{A^{X}}$, or it can be presented as an algebraic 2-theory using 1-HITs. These HITs
and the proof of their universal property have been considered
in~\cite*{piceghelloCoherenceSymmetricMonoidal2019,choudhuryFinitemultisetConstructionHoTT2019}.

The proof of the universal property of the $\FSM$ is asserted by appealing to Mac Lane's coherence theorem for symmetric
monoidal categories, and using the fact that the finite symmetric group $\Sn$ encodes the permutation group on a finite
set. The existence of the proof is folklore, and we have produced a new proof of it while working in constructive type
theory.

\paragraph{Curry-Howard-Lambek correspondence} In~\citet{curryCurryEssaysCombinatory1980}, Lambek extended the
Curry-Howard correspondence to cartesian-closed categories. In this work, we have established a correspondence between a
fragment of the $\PiLang$ family of reversible programming languages and symmetric monoidal groupoids. The Curry-Howard
part of this correspondence with reversible logic was established in~\cite{sparksSuperstructuralReversibleLogic2014}.

\begin{center}
    \begin{tabular}{c c c}
        \hline
        $\PiLang$     & $\Sn$               & $\UFin$     \\
        \hline
        types         & Natural numbers     & Finite sets \\
        \hline
        1-combinators & Generators of $\Sn$ & 1-paths     \\
        \hline
        2-combinators & Relations of $\Sn$  & 2-paths     \\
        \hline
    \end{tabular}
\end{center}

\begin{center}
    \begin{tabular}{c c c}
        \hline
        Logic                              & Program                       & Algebra                     \\
        \hline
        Propositions                       & Types                         & Objects                     \\
        \hline
        Proofs                             & Terms                         & Morphisms                   \\
        \hline
        $\blank$                           & Equations                     & Homotopies                  \\
        \hline
        Intuitionistic propositional logic & Simply typed Lambda Calculus  & Cartesian Closed Categories \\
        \hline
        Superstructural Reversible logic   & Reversible Language $\PiLang$ & Symmetric Rig Groupoids     \\
        \hline
        Connectives                        & Type constructors             & Bifunctors                  \\
        \hline
        ?                                  & Type normalisation            & ?                           \\
        \hline
        ?                                  & Program normalisation         & ?                           \\
        \hline
        ?                                  & Soundness of 2-combinators    & ?                           \\
    \end{tabular}
\end{center}

\begin{center}
    \begin{tabular}{c c c}
        \hline
        Reversible Logic             & Reversible Programming                  & Algebra                  \\
        \hline
        Free commutative rig         & Free symmetric rig groupoid             & $\UFin$                  \\
        \hline
        Propositions                 & Types                                   & Objects                  \\
        \hline
        Entailment?                  & Reversible programs                     & Isomorphisms             \\
        \hline
        $\blank$                     & 2-combinators                           & Homotopies               \\
        \hline
        Conjunction?                 & $\times$                                & $\otimes$                \\
        \hline
        Disjunction?                 & $+$                                     & $\oplus$                 \\
        \hline
        $A \land B \vdash B \land A$ & $\swapt$                                & $\mathcal{B}_{A,B}$      \\
        \hline
        True proposition             & $\onet$                                 & $F_1$                    \\
        \hline
        Decidability                 & Program Synthesis                       & Reachability in a graph? \\
        \hline
        Soundness/Completeness       & Soundness/Completeness of 1-combinators & ?                        \\
    \end{tabular}
\end{center}

\paragraph{Rewriting} We presented a rewriting system for the Coxeter relations for $\Sn$ to solve its word problem.

There exists an algorithm, due to~\citet{knuthSimpleWordProblems1970}, that, when succeeds, constructs a well-behaved
rewriting system for an arbitrary finite set of (undirected) equations. It did not work for us, producing too many
equations, and proving correctness and termination was intractable.

We chose to encode permutations as adjacent transpositions corresponding to words in $\Sn$, since that closely
corresponds to the syntax of $\PiLang$ combinators. Other representations of permutations would give a different
denotational semantics for $\PiLang$ combinators. Permutations can be encoded as listed vectors or matrices, inductively
generated trees (Motzkin trees), Young diagrams, or String diagrams, but the difficulty of formalising them in type
theory varies depending on the encoding.

Rewriting systems and word problems have a long history of being formalised in proof assistants. In the recent past,
higher order rewriting systems have been formalised in proof assistants like {homotopy.io} and Lean and Coq. The use of
HoTT to study rewriting has been considered in~\cite{krausCoherenceWellFoundednessTaming2020}.

\paragraph{Computational group theory} Coxeter relations are used in computational group theory to study XXX problems.

\paragraph{Univalent Fibrations} Univalent Fibrations were introduced by~\citet*{kapulkinUnivalenceSimplicialSets2018},
to build a model of Voevodsky's \emph{univalence} principle in simplicial sets.
\citet{christensenCharacterizationUnivalentFibrations2015} studied characterisations of univalent fibrations using the
$\BAut$ construction. Univalent typoids~\cite{petrakisUnivalentTypoids2019a} are a different presentation of univalent
subuniverses.

Coherence problems in type theory, coherence via Well-Foundedness.

Formalised proofs of Mac Lane's coherence theorem.

Applications of FSMG and history of the coherence theorems.

Other proofs of coherence theorems, Joyal-Street.

Pi has other extensions (fractional/negative/recursive types).
What are the free X monoidal structures they're describing?

Using our presentation of $S_{n}$, we can construct the Eilenberg-Maclane space (using a HIT) $K(S_{n},1)$. Then, it
should be true that $\UFin \eqv \sqcup_{n:\Nat} K(S_{n},1)$. This is future work.

Other applications of symmetric groups.

Actions of symmetric groups, permutation groupoids.

\paragraph{Extensional vs. Intensional View of Permutations.}
Although the meaning of a permutation - that is, the specific bijective function
that it represents - is in some sense all there is, manipulating them
syntactically still has its advantages. By writing reversible programs, we think
of them in an intensional way. Comparing two programs for equality by evaluating
them on all points in the domain is a very crude - and maybe even inefficient -
way of doing that. ~\cite{Kuehlmann:2006:RBR:2298470.2300327,10.1007/978-3-540-24605-3_4,Yamashita:2010:FEQ:1835957.1835965}.

It is crude, because there is no way of enforcing additional constraints on the
process of transforming one program into another, and no way of inspecting what
transformation occurred. We can imagine a practical situation in which reversible
circuits admit one kind of optimization FPGA?, but do not admit another,
even though they are equivalent in the extensional sense - or maybe one of these
transformations is cheaper than another, or maybe it is important to know which
transformation did occur for the producer(?) to focus their resources of
improving this kind of transformations. By comparing the circuits extensionally,
the proof object = the path from one into the other - does not have any
structure,  it is just a check that the values match.

On the other hand, even though in general, the equality of circuits requires
exponential time jk{triple check}, the proof object can be still very small.
This creates structure that can possibly be exploited in a heuristic way.
Additionally, if the goal is to convince third-party that two circuits are
the same, we can just present the proof instead of showing the equality directly
- for example, by choosing a particularly short one.

Taking all this into account, it is clear that we must seek a syntactic way of
computing the meaning of the circuit, instead of just directly evaluating it to
$\Aut[\Fin[n]]$ - since when we go back and quote the permutation as a circuit
(in a normal form), there was no "trace" left to see what transformation (what
sequence of 2-paths) maps the old one into the new one.

We are additionally experimenting with user annotations that can guide
the search. Each level-2 combinator can be annotated with various
``cost'' annotations indicating whether it reduces the number of
gates, reduces the number of choice points, or other cost
functions. Then one can ask for a proof that takes no more than a
certain number of steps or a proof that does not create more than a
certain number of additional wires etc. We illustrate these ideas by
defining a simple cost function and using it to annotate level-2
combinators.

We define the \emph{length} $L(c)$ of a composite circuit $c$ as
follows: the length of a sequential composition of circuits is the sum
of the lengths of the subcircuits $L(f \odot g) = L(f) + L(g)$; and
the length of choice or parallel composition is the maximum of either
branch $L(f \oplus g) = L(f \otimes g) = \max(L(f),L(g))$. For
primitive gates, the length needs to be postulated to reflect the
``length'' of the computation involved in applying that primitive. As
examples, consider the following two level-2 combinators:

% \begin{code}
% linv◎l'  :  {t₁ t₂ : U} {c : t₁ ⟷ t₂} → (c ◎ ! c) ⇔ id⟷
% idl◎l'   :  {t₁ t₂ : U} {c : t₁ ⟷ t₂} → (id⟷ ◎ c) ⇔ c
% \end{code}
% \AgdaHide{
% \begin{code}
% linv◎l'  = ?
% idl◎l'   = ?
% \end{code}
% }

\noindent Assuming that $\idc$ takes a unit length of computation, the
first can be annotated with $L(c)*2 \isotwo 1$ and the second with $L(c)+1 \isotwo
    L(c)$ indicating that the first combinator reduces the length of the
circuit from twice the length of $c$ to 1 and the second combinator
reduces the length of the circuit by 1. Such annotations can then be
used to constrain or guide the search for transformations between
circuits.

\todo{Why is this better than evaluating the permutation and checking each bit?}
\todo{Why care about an equational theory? Compilers, optimisation.}

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "main"
%%% fill-column: 120
%%% End:
