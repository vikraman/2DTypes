\section{A Reversible Programming Language: Groupoid Semantics}
\label{sec:reversibletwo}
\label{langeqeq}

In the previous section, we examined equivalences between conventional data structures, i.e., structured trees of
values. We now consider a richer but foundational notion of data: programs themselves. Indeed, universal computation
models crucially rely on the fact that \emph{programs are (or can be encoded as) data}, e.g., a Turing machine can be
encoded as a string that another Turing machine (or even the same machine) can manipulate. Similarly, first-class
functions are the \emph{only} values in the $\lambda$-calculus.  In our setting, we ask whether the programs developed
in the previous section can themselves be subject to (higher-level) equivalences?

We will explain the ideas using two small exaamples. Consider the following two programs mapping between the types
$A + B$ and $C+D$:

\begin{center}
\begin{tikzpicture}[scale=0.7,every node/.style={scale=0.8}]
  \draw[>=latex,<->,double,red,thick] (2.25,-1.2) -- (2.25,-2.9) ;
  \draw[fill] (-2,-1.5) circle [radius=0.025];
  \node[below] at (-2.1,-1.5) {$A$};
  \node[below] at (-2.1,-1.9) {$+$};
  \draw[fill] (-2,-2.5) circle [radius=0.025];
  \node[below] at (-2.1,-2.5) {$B$};

  \draw[fill] (6.5,-1.5) circle [radius=0.025];
  \node[below] at (6.7,-1.5) {$C$};
  \node[below] at (6.7,-1.9) {$+$};
  \draw[fill] (6.5,-2.5) circle [radius=0.025];
  \node[below] at (6.7,-2.5) {$D$};

  \draw[<-] (-2,-1.5) to[bend left] (1,0.5) ;
  \draw[<-] (-2,-2.5) to[bend left] (1,-0.5) ;
  \draw[->] (3.5,0.5) to[bend left] (6.5,-1.45) ;
  \draw[->] (3.5,-0.5) to[bend left] (6.5,-2.45) ;

  \draw[<-] (-2,-1.5) to[bend right] (1,-3.5) ;
  \draw[<-] (-2,-2.5) to[bend right] (1,-4.5) ;
  \draw[->] (3.5,-3.5) to[bend right] (6.5,-1.55) ;
  \draw[->] (3.5,-4.5) to[bend right] (6.5,-2.55) ;


  \draw     (2,0.5)  -- (2.5,0.5)  ;
  \draw     (2,-0.5) -- (2.5,-0.5) ;

  \draw     (2.5,0.5)  -- (3.5,-0.5)  ;
  \draw     (2.5,-0.5) -- (3.5,0.5) ;

  \draw     (1,-3.5)  -- (2,-4.5)    ;
  \draw     (1,-4.5) -- (2,-3.5)   ;

  \draw     (2,-3.5)  -- (2.5,-3.5)    ;
  \draw     (2,-4.5) -- (2.5,-4.5)   ;

  \path (1.5,0.5) node (tc1) [func] {$c_1$};
  \path (1.5,-0.5) node (tc2) [func] {$c_2$};
  \path (3,-4.5) node (bc1) [func] {$c_1$};
  \path (3,-3.5) node (bc2) [func] {$c_2$};
\end{tikzpicture}
\end{center}
The top path is the $\Pi$ program $(c_1~\oplus~c_2)~\odot~\swapp$ which acts on the type $A$ by $c_1$, acts on the type
$B$ by $c_2$, and acts on the resulting value by a twist that exchanges the two injections into the sum type. The bottom
path performs the twist first and then acts on the type $A$ by $c_1$ and on the type $B$ by $c_2$ as before. One could
imagine the paths are physical \emph{elastic} wires in $3$ space, where the programs $c_1$ and $c_2$ as arbitrary
deformations on these wires, and the twists do not touch but are in fact well-separated. Then, holding the points $A$,
$B$, $C$, and $D$ fixed, it is possible to imagine sliding $c_1$ and $c_2$ from the top wire rightward past the twist,
and then using the elasticity of the wires, pull the twist back to line up with that of the bottom --- thus making both
parts of the diagram identical.  Each of these moves can be undone (reversed), and doing so would take the bottom part
of the diagram into the top part.  In other words, there exists an equivalence of the program
$(c_1~\oplus~c_2)~\odot~\swapp$ to the program $\swapp \odot (c_2~\oplus~c_1)$. We can also show that this means that,
as permutations, $(c_1~\oplus~c_2)~\odot~\swapp$ and $\swapp \odot (c_2~\oplus~c_1)$ are equal. And, of course, not all
programs between the same types can be deformed into one another. The simplest example of inequivalent deformations are
the two automorphisms of $1+1$, namely $\idc$ and $\swapp$.

As another example, consider consider a circuit that takes an input type consisting of three values \Tree [ {\small a} [
{\small b} {\small c} ] ]~ and swaps the leftmost value with the rightmost value to produce \Tree [ {\small c} [ {\small
  b} {\small a} ] ]~.  We can implement two such circuits using our Agda library for $\Pi$:

\begin{code}%
\>[0]\AgdaFunction{swap{-}fl1}\AgdaSpace{}%
\AgdaFunction{swap{-}fl2}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaBound{a}\AgdaSpace{}%
\AgdaBound{b}\AgdaSpace{}%
\AgdaBound{c}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaDatatype{U}\AgdaSymbol{\}}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaInductiveConstructor{PLUS}\AgdaSpace{}%
\AgdaBound{a}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaInductiveConstructor{PLUS}\AgdaSpace{}%
\AgdaBound{b}\AgdaSpace{}%
\AgdaBound{c}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaDatatype{⟷}\AgdaSpace{}%
\AgdaInductiveConstructor{PLUS}\AgdaSpace{}%
\AgdaBound{c}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaInductiveConstructor{PLUS}\AgdaSpace{}%
\AgdaBound{b}\AgdaSpace{}%
\AgdaBound{a}\AgdaSymbol{)}\<%
\\
\>[0]\AgdaFunction{swap{-}fl1}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaInductiveConstructor{assocl₊}\AgdaSpace{}%
\AgdaInductiveConstructor{◎}\AgdaSpace{}%
\AgdaInductiveConstructor{swap₊}\AgdaSpace{}%
\AgdaInductiveConstructor{◎}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaInductiveConstructor{id⟷}\AgdaSpace{}%
\AgdaInductiveConstructor{⊕}\AgdaSpace{}%
\AgdaInductiveConstructor{swap₊}\AgdaSymbol{)}\<%
\\
%
\\[\AgdaEmptyExtraSkip]%
\>[0]\AgdaFunction{swap{-}fl2}\AgdaSpace{}%
\AgdaSymbol{=}%
\>[52I]\AgdaSymbol{(}\AgdaInductiveConstructor{id⟷}\AgdaSpace{}%
\AgdaInductiveConstructor{⊕}\AgdaSpace{}%
\AgdaInductiveConstructor{swap₊}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaInductiveConstructor{◎}\<%
\\
\>[.]\<[52I]%
\>[11]\AgdaInductiveConstructor{assocl₊}\AgdaSpace{}%
\AgdaInductiveConstructor{◎}\<%
\\
%
\>[11]\AgdaSymbol{(}\AgdaInductiveConstructor{swap₊}\AgdaSpace{}%
\AgdaInductiveConstructor{⊕}\AgdaSpace{}%
\AgdaInductiveConstructor{id⟷}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaInductiveConstructor{◎}\<%
\\
%
\>[11]\AgdaInductiveConstructor{assocr₊}\AgdaSpace{}%
\AgdaInductiveConstructor{◎}\<%
\\
%
\>[11]\AgdaSymbol{(}\AgdaInductiveConstructor{id⟷}\AgdaSpace{}%
\AgdaInductiveConstructor{⊕}\AgdaSpace{}%
\AgdaInductiveConstructor{swap₊}\AgdaSymbol{)}\<%
\end{code}

\noindent The first implementation rewrites the incoming values as follows:
\[
\Tree [ {\small a} [ {\small b} {\small c} ] ] ~\to~
\Tree [ [ {\small a} {\small b} ] {\small c} ] ~\to~
\Tree [ {\small c} [ {\small a} {\small b} ] ] ~\to~
\Tree [ {\small c} [ {\small b} {\small a} ] ] ~.
\]
\noindent
The second implementation rewrites the incoming values as follows:
\[
\Tree [ {\small a} [ {\small b} {\small c} ] ] ~\to~
\Tree [ {\small a} [ {\small c} {\small b} ] ] ~\to~
\Tree [ [ {\small a} {\small c} ] {\small b} ] ~\to~
\Tree [ [ {\small c} {\small a} ] {\small b} ] ~\to~
\Tree [ {\small c} [ {\small a} {\small b} ] ] ~\to~
\Tree [ {\small c} [ {\small b} {\small a} ] ] ~.
\]
\noindent The two circuits are extensionally equal. Using the level-2
isomorphisms we can \emph{explicitly} construct a sequence of
rewriting steps that transforms the second circuit to the first.

Recalling that the $\lambda$-calculus arises as the internal language of Cartesian Closed Categories
(Elliott~\cite{Elliott-2017} gives a particularly readable account of this), we can think of $\Pi$ in similar terms, but
for symmetric Rig Groupoids instead. For example, we can ask what does the equivalence above represent? It is actually a
``linear'' representation of a 2-categorial commutative diagram! In fact, it is a painfully verbose version thereof, as
it includes many \emph{refocusing} steps because our language does not build associativity into its syntax. Categorical
diagrams usually do.  Thus if we rewrite the example in diagrammatic form, eliding all uses of associativity, but
keeping explicit uses of identity transformations, we get that \AgdaFunction{swap{-}fl2⇔swap{-}fl1} represents

\vspace*{3mm}
\begin{tikzcd}[column sep=normal, row sep=normal]
 && (a+c)+b \arrow [r, "\swapp \oplus\idd", ""{name=U, below}] & (c+a)+b \arrow [dr, "\assocrp"] && \\
 & a+(c+b) \arrow [ur, "\assoclp"] & & & c+(a+b) \arrow [dr, "\idd\oplus\swapp"] &  \\
a+(b+c) \arrow [ur, "\idd\oplus\swapp"] \arrow [r, "\assoclp"]
  \arrow [dr, "\assoclp"]
  \arrow [ddr, swap, "\assoclp"]
    & (a+b)+c \arrow [r, "\swapp"] &
    c+(a+b) \arrow [r, swap, "\assoclp", ""{name=D, above}]
    & |[alias=Z]| (c+a)+b \arrow [r, "\assocrp"] &c+(a+b) \arrow [r, "\idd\oplus\swapp"] & c+(b+a) \\
 & (a+b)+c \arrow [dr, "\swapp"] &&&& \\
 & (a+b)+c \arrow [dr, swap, "\swapp"] & c+(a+b) \arrow [rr, swap, "\idd", ""{name=DD, above}]
             \arrow [d, Rightarrow, "\idf\, \mathit{idl}\odot{l}"] &&
    c+(a+b) \arrow [ruu, "\idd\oplus\swapp"] & \\
 && c+(a+b) \arrow [rrruuu, bend right = 40, swap, "\idd\oplus\swapp"] && \\
 \arrow[Rightarrow, from=U, to=D, "\mathit{hexagon}\oplus{r}\, \boxdot\, \idf"]
 \arrow[Rightarrow, from=Z, to=DD, swap, "\idf\boxdot\mathit{linv}\odot{l}\,\boxdot\,\idf"]
\end{tikzcd}


%%%%%%%%%
\subsection{Denotational Semantics}

An alternative point of view for the semantics in Sec.~\ref{reversibleone} is to consider it  as expressed in the
category of finite sets and functions, $\SetFin$, which is the category freely generated by finite coproduct completion
of the terminal category. Objects of $\SetFin$ can be identified with sets of fixed cardinality, that is,
$\Fin[n] \defeq \Set{0,1,\ldots,n-1}$. $\SetFin$ has finite coproducts and products, which lets us interpret the types
of $\PiLang$. Combinators are intepreted as morphisms in $\SetFin$, but we have to restrict to invertible morphisms,
that is, isomorphisms. This gives the \emph{groupoid} of finite sets and bijections,
$\BFin \defeq \mathsf{core}(\SetFin)$. The isomorphisms satisfied by coproducts and products in $\SetFin$ lift to
$\BFin$, but they're no longer categorical coproducts and products. They give two symmetric monoidal tensor products on
$\BFin$, the additive and multiplicative ones, with the multiplicative tensor distributing over the additive tensor.

We choose a canonical set of size $n$, called $\mathsf{Fin}~n$, whose elements are natural numbers less than $n$. To
compute the denotation of a type $A$, we first calculate its size $n = \sizet{A}$. We then construct the canonical set
$\mathsf{Fin}~n$ and provide the (trivial) evidence that this set is identical to $(\mathsf{Fin}~n)$:

\[\begin{array}{rcll}
\sem{A} &=& (\mathsf{Fin}~n, [ n , \mathsf{refl} ]) & \mbox{where}~\sizet{A} = n
\end{array}\]

\noindent The denotation $\sem{c}$ of a combinator $c : A \isot B$ is a path between $\sem{A}$ and $\sem{B}$. If the
size of $A$ is $m$ and the size of $B$ is $n$, the desired path is between $(\mathsf{Fin}~m, [ m , \mathsf{refl} ])$ and
$(\mathsf{Fin}~n, [ n , \mathsf{refl} ])$. This path is directly constructed using $\mathit{ap}$ and the fact that $m=n$
since combinators are always between types of the same size.

\noindent Finally, given two combinators $p , q : A \isot_1 B$ and a 2-combinator $\alpha : p \iso_2 q$, the denotation
$\sem{\alpha}$ of $\alpha$ is a path between $\sem{p}$ and $\sem{q}$.

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "main"
%%% fill-column: 120
%%% End:
