\section{A Reversible Programming Language: Set-Theoretic Semantics}
\label{sec:reversibleone}

The practice of programming languages is replete with \emph{ad hoc} instances of reversible computations: database
transactions, mechanisms for data provenance, checkpoints, stack and exception traces, logs, backups, rollback
recoveries, version control systems, reverse engineering, software transactional memories, continuations, backtracking
search, and multiple-level undo features in commercial applications. In the early nineties,
\citet{Baker:1992:LLL,Baker:1992:NFT} argued for a systematic, first-class, treatment of reversibility. But intensive
research in full-fledged reversible models of computations and reversible programming languages was only sparked by the
discovery of deep connections between physics and
computation~\cite{Landauer:1961,PhysRevA.32.3266,Toffoli:1980,bennett1985fundamental,Frank:1999:REC:930275, Hey:1999:FCE:304763,fredkin1982conservative}, and by the
potential for efficient quantum computation~\cite{springerlink:10.1007/BF02650179}.

The early developments of reversible programming languages started
with a conventional programming language, e.g., an extended
$\lambda$-calculus, and either:
\begin{enumerate}
\item extended the language with a history
mechanism~\cite{vanTonder:2004,Kluge:1999:SEMCD,lorenz,danos2004reversible}, or
\item imposed constraints on the control flow constructs to make them
reversible~\cite{Yokoyama:2007:RPL:1244381.1244404}.
\end{enumerate}
More foundational approaches recognize that reversible programming languages require a fresh approach and should be
designed from first principles without the detour via conventional irreversible
languages~\cite{Yokoyama:2008:PRP,Mu:2004:ILRC,abramsky2005structural,DiPierro:2006:RCL:1166042.1166047,
  rc2011,James:2012:IE:2103656.2103667,Carette2016}.

%%%%%%%%%%%%%%%%%
\subsection{The $\Pi$ Family of Languages}

A natural candidate for a semantic foundation for reversible programming languages is the notion of type
isomorphism. Indeed, the type isomorphisms among finite types are sound and complete for all permutations on finite
types~\cite{Fiore:2004,fiore-remarks} and hence they are \emph{complete} for expressing reversible combinational
circuits~\cite{fredkin1982conservative, James:2012:IE:2103656.2103667,Toffoli:1980} and the extension with recursive
types and trace operators~\cite{Hasegawa:1997:RCS:645893.671607} is a Turing-complete reversible
language~\cite{James:2012:IE:2103656.2103667,rc2011}.

Focusing on finite types, the building blocks of type theory are: the empty type ($\zerot$), the unit type
($\onet$) containing just one value $\Acon{tt}$, the sum type ($+$) containing values of the form $\inlv{v}$ and
$\inrv{v}$, and the product ($\times$) type containing pairs of values $(v_1,v_2)$. For this fragment of types, the
syntax of the language $\Pi$ consists of the following sorts:

{\scalebox{\scalef}{$%
\begin{array}{lrcl}
\textit{Value types} & A,B,C,D &::=& \zerot \alt \onet \alt A+B \alt A\times B \\
\textit{Values}      & v,w,x,y &::=& \Acon{tt} \alt \inlv{v} \alt \inrv{v} \alt (v,w) \\
\textit{Program types} &&& A \iso B \\
\textit{Programs} & c &::=& (\textrm{See Fig.~\ref{pi-terms}})
\end{array}$}}
\begin{figure}[t]
{\scalebox{\scalef}{$%
%%\noindent\begin{minipage}{.7\linewidth}
\begin{array}{rrcll}
\idc :& A & \iso & A &: \idc \\
\\
\identlp :&  \zerot + A & \iso & A &: \identrp \\
\swapp :&  A + B & \iso & B + A &: \swapp \\
\assoclp :&  A + (B + C) & \iso & (A + B) + C &: \assocrp \\ [1.5ex]
\identlt :&  \onet \times A & \iso & A &: \identrt \\
\swapt :&  A \times B & \iso & B \times A &: \swapt \\
\assoclt :&  A \times (B \times C) & \iso & (A \times B) \times C &: \assocrt \\ [1.5ex]
\absorbr :&~ \zerot \times A & \iso & \zerot ~ &: \factorzl \\
\dist :&~ (A + B) \times C & \iso & (A \times C) + (B \times C)~ &: \factor
  \end{array}$}}

{\scalebox{\scalef}{%
\Rule{}
{\jdg{}{}{c_1 : A \iso B} \quad \vdash c_2 : B \iso C}
{\jdg{}{}{c_1 \fatsemi c_2 : A \iso C}}
{}

\Rule{}
{\jdg{}{}{c_1 : A \iso B} \quad \vdash c_2 : C \iso D}
{\jdg{}{}{c_1 \oplus c_2 : A + C \iso B + D}}
{}

\Rule{}
{\jdg{}{}{c_1 : A \iso B} \quad \vdash c_2 : C \iso D}
{\jdg{}{}{c_1 \otimes c_2 : A \times C \iso B \times D}}
{}
}}
\caption{$\Pi$-terms, combinators, and their types.}
\label{pi-terms}
\end{figure}

\noindent Intuitively, one may view each type $A$ as a collection of physical wires that can transmit $\sizet{A}$
distinct values where $\sizet{A}$ is a natural number that indicates the size of a type, computed as:
$\sizet{\zerot} = 0$; $\sizet{\onet} = 1$; $\sizet{A + B} = \sizet{A} + \sizet{B}$; and
$\sizet{A \times B} = \sizet{A} * \sizet{B}$.  Thus the type $\mathbb{2} = \onet + \onet$ corresponds to a wire that can
transmit one of two values, i.e., bits. The type $\mathbb{2} \times (\mathbb{2} \times \mathbb{2})$ (abbreviated
$\mathbb{B}~3$) corresponds to a collection of wires that can transmit three bits. From that perspective, a type
isomorphism between types $A$ and $B$ (such that $\sizet{A}=\sizet{B}=n$) models a \emph{reversible} combinational
circuit that \emph{permutes} the $n$ different values. These type isomorphisms form a \emph{commutative semiring} and
are collected in Fig.~\ref{pi-terms}. Each line in the top part of the figure introduces a pair of dual constants that
witness the type isomorphism in the middle.  These are the \emph{base} (non-reducible) terms of $\Pi$. The isomorphisms
are extended to form a congruence relation by adding the three constructors at the bottom of the figure that witness
equivalence and compatible closure. Although austere, this combinator-based language has the advantage of being amenable
to formal analysis for at least two reasons: (i) it is conceptually simple and small, and (ii) it has direct and evident
connections to type theory and category theory and hence possesses a rich algebraic structure which we exploit in the
remainder of the paper.

%%%%%%%%%
\subsection{Denotational Semantics (Outline)}

\noindent The accompanying code includes an operational semantics for $\Pi$. A denotational semantics can be
specified by mapping each type to a finite set and each combinator to a bijection between finite sets, that is, a
permutation. In this section, we outline a simple semantics expressed in the metalanguage of sets and functions. This
semantics will be formalized and extended to the metalanguage of homotopy type theory in Sec.~\ref{sec:reversibletwo}.

As explained in the previous section, a $\Pi$-type $A$ has $\sizet{A}$-elements and for all combinators $c : A \iso B$
we have that $\sizet{A} = \sizet{B}$. Hence, the denotation $\denot{A}$ of a type $A$ with $n$-elements can be the finite
set $\Fin[n] = \{ 0, 1, \cdots, n-1\}$; the denotation of a value $v : A$ such that $\sizet{A}=n$ will be an index in
the range $[0,n-1]$, and the denotation $\denot{c}$ of a combinator $c : A \iso B$ such that
$\sizet{A} = \sizet{B} = n$ will be a function from $\Fin[n]$ to $\Fin[n]$ that permutes the elements. Thus, all types
with 3 elements will denote $\Fin[3]$ and combinators between them will denote permutations on $\Fin[3]$, e.g.:
\[\begin{array}{rcl}
    \denot{\onet + (\onet + \onet)} &=& \{ 0,1,2 \} \\
    \denot{(\onet + \onet) + \onet} &=& \{ 0,1,2 \} \\
    \\
    \denot{\assoclp : \onet + (\onet + \onet) \iso (\onet + \onet) + \onet} &=& (0~1~2) \\
    \denot{\swapp : \onet + (\onet + \onet) \iso (\onet + \onet) + \onet} &=& (2~0~1)
\end{array}\]
where we have used the one-line notation for permutations with $(a~b~c)$ representing the
permutation that maps 0 to $a$, 1 to $b$, and 2 to $c$. To make the denotation of values precise, we compute a canonical
enumeration of the elements of each type:
\[\begin{array}{rcl}
    \mathit{enum}(\zerot) &=& [~] \\
    \mathit{enum}(\onet) &=& [ ~\Acon{tt}~ ] \\
    \mathit{enum}(A + B) &=& \mathit{map}~\Acon{inj₁}~\mathit{enum}(A) ~\textsf{+\!+}~ \mathit{map}~\Acon{inj₂}~\mathit{enum}(B) \\
    \mathit{enum}(A \times B) &=& \mathit{concat}~(\mathit{map}~(\lambda v.\mathit{map}~(\lambda w. (v,w))~\mathit{enum}(B))~\mathit{enum}(A))
\end{array}\]
\noindent The specification uses a Haskell-like notation for sequences with $\mathit{map}$ as the operation that applies
a function to each element of a sequence, \textsf{+\!+} as the binary append operation, and $\mathit{concat}$ the
operation that appends all the subsequences in a sequence.

Using the definition, we have:
\[\begin{array}{rcl}
    \mathit{enum}(\onet + (\onet + \onet)) &=& [ \inlv{\Acon{tt}},\inrv{(\inlv{\Acon{tt}})}, \inrv{(\inrv{\Acon{tt}})} ] \\
    \mathit{enum}((\onet + \onet) + \onet) &=& [ \inlv{(\inlv{\Acon{tt}})},  \inlv{(\inrv{\Acon{tt}})}, \inrv{\Acon{tt}} ]
  \end{array}\]
Thus, $\assoclp~(\inlv{\Acon{tt}})$ applies the permutation $(0~1~2)$ to the index of $\inlv{\Acon{tt}}$ which is 0 and
produces index 0 in the $(\onet + \onet) + \onet$ type corresponding to value $\inlv{(\inlv{\Acon{tt}})}$. Similarly,
$\swapp~(\inlv{\Acon{tt}})$ applies the permutation $(2~0~1)$ to the index of $\inlv{\Acon{tt}}$ which is 0 and produces
index 2 in the $(\onet + \onet) + \onet)$ type corresponding to value $\inrv{\Acon{tt}}$.

% \[\begin{array}{l}
%     \Tree[ {\small a} [ {\small b} {\small c} ] ] \\
%     2 \quad 1 \quad 0 \\
%     0 \quad 2 \quad 1 \\
%     \Tree[ [ {\small b}  {\small c} ] {\small a} ]
% \end{array}\]

% Such functions are finitely supported, that is, their outputs can be tabulated using the canonical ordering on
% $\Fin[n]$. For bijections, this gives a listed permutation. By observing the action of the combinators on the values of
% the finite set, we can define a denotational semantics which constructs the bijection.
% \note{\(\Fin[n] \to A \eqv \type{Vec_{n}}(A)\)}

%%%%%%%%%
\subsection{Examples}
\label{sec:langRev-examples}
\label{examples}

%% \note{Revisit to pick examples relevant to the rest of the paper; also unify notation}

In order to understand the examples of Sec.~\ref{sec:informal}, we review how to represent collections of booleans and
conditionals in $\Pi$. We use the type $\onet + \onet$ to represent booleans with $\inlv{\Acon{tt}}$ representing
\textsf{false} and $\inrv{\Acon{tt}}$ representing $\textsf{true}$. Boolean negation is straightforward to define using
the primitive combinator $\swapp$. We can represent $n$-bit words using an n-ary product of boolean values.
For example, we can express a 3-bit word reversal operation as follows:

$\Afun{reverse} : \mathbb{B}~3 \iso \mathbb{B}~3$

$\Afun{reverse} = \swapt \fatsemi (\swapt  \otimes  \idc)~ \fatsemi \assocrt$

\noindent The manual trace of $\Afun{reverse}$ below confirms that it indeed reverses the three bits:
\[\begin{array}{rlr}
 & (v_1, (v_2, v_3)) \\
 \swapt & ((v_2, v_3), v_1) \\
 \swapt \otimes  \idc & ((v_3, v_2), v_1) \\
 \assocrt & (v_3, (v_2, v_1)) \\
 \end{array}\]
%subcode source isomorphisms.tex:979

Even though \ensuremath{\Pi } lacks conditional expressions, they are expressible using the distributivity and factoring
laws as shown below:

$\Afun{ifc}_{c_1,c_2} : \mathbb{2} \times A \iso \mathbb{2} \times B$

$\Afun{ifc}_{c_1,c_2} = \dist \fatsemi ((\idc  \otimes\  c_1) \oplus (\idc \otimes\  c_2)) \fatsemi \factor$


% \inkscape{if-c1-c2.pdf}


\noindent The input value of type $\mathbb{2} \times A$ is processed by the distribute operator \ensuremath{\dist},
which converts it into a value of type $(\onet \times A) + (\onet \times A)$. In the \ensuremath{\mathit{left}} branch,
which corresponds to the case when the boolean is \ensuremath{\mathit{false}}, the combinator~\ensuremath{c_1} is
applied to the value of type~\ensuremath{A}. The right branch which corresponds to the boolean being
\ensuremath{\mathit{true}} passes the value of type $A$ through the combinator \ensuremath{c_2}.  The inverse of
\ensuremath{\dist}, namely \ensuremath{\factor} is applied to get the final result. The full expressiveness of $\Pi$ is
demonstrated by the following implementation of $\Afun{cnot}$ and $\Afun{toffoli}$ which are universal for reversible
computation~\cite{Toffoli:1980}. The $\Afun{cnot}$ gates takes two input bits: a control bit and a target bit, and
negates the target bit if the control bit is set. It is essentially a one-branch version of $\Afun{cif}$ above. The
Toffoli gate generalizes the idea to a gate that takes 3 input bits: 2 control bits and one target bit: boolean inputs:
it negates the target bit if both control bits are set.

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "main"
%%% fill-column: 120
%%% End:
