\section{A Reversible Programming Language: Set-Theoretic Semantics}
\label{sec:reversibleone}
\label{sec:reversibletwo}
\label{langeqeq}
\label{sec:informal}

%%%%%%%%%%%%%%%%%
\subsection{The $\Pi$ Family of Languages}

\note{Start with conherence conditions and folklore result; cite ESOP paper as a syntactic presentation; then go into Pi details}

%%%%%%%%%%%%%%%%%
\subsection{The $\Pi$ Family of Languages}

\note{Discuss level 2; even if briefly}

The practice of programming languages is replete with \emph{ad hoc} instances of reversible computations: database
transactions, mechanisms for data provenance, checkpoints, stack and exception traces, logs, backups, rollback
recoveries, version control systems, reverse engineering, software transactional memories, continuations, backtracking
search, and multiple-level undo features in commercial applications. In the early nineties,
\citet{Baker:1992:LLL,Baker:1992:NFT} argued for a systematic, first-class, treatment of reversibility. But intensive
research in full-fledged reversible models of computations and reversible programming languages was only sparked by the
discovery of deep connections between physics and
computation~\cite{Landauer:1961,PhysRevA.32.3266,Toffoli:1980,bennett1985fundamental,Frank:1999:REC:930275, Hey:1999:FCE:304763,fredkin1982conservative}, and by the
potential for efficient quantum computation~\cite{springerlink:10.1007/BF02650179}.

The early developments of reversible programming languages started
with a conventional programming language, e.g., an extended
$\lambda$-calculus, and either:
\begin{enumerate}
  \item extended the language with a history
        mechanism~\cite{vanTonder:2004,Kluge:1999:SEMCD,lorenz,danos2004reversible}, or
  \item imposed constraints on the control flow constructs to make them
        reversible~\cite{Yokoyama:2007:RPL:1244381.1244404}.
\end{enumerate}
More foundational approaches recognize that reversible programming languages require a fresh approach and should be
designed from first principles without the detour via conventional irreversible
languages~\cite{Yokoyama:2008:PRP,Mu:2004:ILRC,abramsky2005structural,DiPierro:2006:RCL:1166042.1166047,
  rc2011,James:2012:IE:2103656.2103667,Carette2016}.

A natural candidate for a semantic foundation for reversible programming languages is the notion of type
isomorphism. Indeed, the type isomorphisms among finite types are sound and complete for all permutations on finite
types~\cite{Fiore:2004,fiore-remarks} and hence they are \emph{complete} for expressing reversible combinational
circuits~\cite{fredkin1982conservative, James:2012:IE:2103656.2103667,Toffoli:1980} and the extension with recursive
types and trace operators~\cite{Hasegawa:1997:RCS:645893.671607} is a Turing-complete reversible
language~\cite{James:2012:IE:2103656.2103667,rc2011}.

Focusing on finite types, the building blocks of type theory are: the empty type ($\zerot$), the unit type
($\onet$) containing just one value $\Acon{tt}$, the sum type ($+$) containing values of the form $\inlv{v}$ and
$\inrv{v}$, and the product ($\times$) type containing pairs of values $(v_1,v_2)$. For this fragment of types, the
syntax of the language $\Pi$ consists of the following sorts:

{\scalebox{\scalef}{$%
    \begin{array}{lrcl}
      \textit{Value types}   & A,B,C,D & ::= & \zerot \alt \onet \alt A+B \alt A\times B        \\
      \textit{Values}        & v,w,x,y & ::= & \Acon{tt} \alt \inlv{v} \alt \inrv{v} \alt (v,w) \\
      \textit{Program types} &         &     & A \iso B                                         \\
      \textit{Programs}      & c       & ::= & (\textrm{See Fig.~\ref{pi-terms}})
    \end{array}$}}
\begin{figure}[t]
  {\scalebox{\scalef}{$%
        %%\noindent\begin{minipage}{.7\linewidth}
        \begin{array}{rrcll}
          \idc :     & A                     & \iso & A                            & : \idc      \\
          \\
          \identlp : & \zerot + A            & \iso & A                            & : \identrp  \\
          \swapp :   & A + B                 & \iso & B + A                        & : \swapp    \\
          \assoclp : & A + (B + C)           & \iso & (A + B) + C                  & : \assocrp  \\ [1.5ex]
          \identlt : & \onet \times A        & \iso & A                            & : \identrt  \\
          \swapt :   & A \times B            & \iso & B \times A                   & : \swapt    \\
          \assoclt : & A \times (B \times C) & \iso & (A \times B) \times C        & : \assocrt  \\ [1.5ex]
          \absorbr : & ~ \zerot \times A     & \iso & \zerot ~                     & : \factorzl \\
          \dist :    & ~ (A + B) \times C    & \iso & (A \times C) + (B \times C)~ & : \factor
        \end{array}$}}

  {\scalebox{\scalef}{%
      \Rule{}
      {\jdg{}{}{c_1 : A \iso B} \quad \vdash c_2 : B \iso C}
      {\jdg{}{}{c_1 \fatsemi c_2 : A \iso C}}
      {}

      \Rule{}
      {\jdg{}{}{c_1 : A \iso B} \quad \vdash c_2 : C \iso D}
      {\jdg{}{}{c_1 \oplus c_2 : A + C \iso B + D}}
      {}

      \Rule{}
      {\jdg{}{}{c_1 : A \iso B} \quad \vdash c_2 : C \iso D}
      {\jdg{}{}{c_1 \otimes c_2 : A \times C \iso B \times D}}
      {}
    }}
  \caption{$\Pi$-terms, combinators, and their types.}
  \label{pi-terms}
\end{figure}

\noindent Intuitively, one may view each type $A$ as a collection of physical wires that can transmit $\sizet{A}$
distinct values where $\sizet{A}$ is a natural number that indicates the size of a type, computed as:
$\sizet{\zerot} = 0$; $\sizet{\onet} = 1$; $\sizet{A + B} = \sizet{A} + \sizet{B}$; and
$\sizet{A \times B} = \sizet{A} * \sizet{B}$.  Thus the type $\mathbb{2} = \onet + \onet$ corresponds to a wire that can
transmit one of two values, i.e., bits. The type $\mathbb{2} \times (\mathbb{2} \times \mathbb{2})$ (abbreviated
$\mathbb{B}~3$) corresponds to a collection of wires that can transmit three bits. From that perspective, a type
isomorphism between types $A$ and $B$ (such that $\sizet{A}=\sizet{B}=n$) models a \emph{reversible} combinational
circuit that \emph{permutes} the $n$ different values. These type isomorphisms form a \emph{commutative semiring} and
are collected in Fig.~\ref{pi-terms}. Each line in the top part of the figure introduces a pair of dual constants that
witness the type isomorphism in the middle.  These are the \emph{base} (non-reducible) terms of $\Pi$. The isomorphisms
are extended to form a congruence relation by adding the three constructors at the bottom of the figure that witness
equivalence and compatible closure. Although austere, this combinator-based language has the advantage of being amenable
to formal analysis for at least two reasons: (i) it is conceptually simple and small, and (ii) it has direct and evident
connections to type theory and category theory and hence possesses a rich algebraic structure which we exploit in the
remainder of the paper.

%%%%%%%%%
\subsection{Informal Semantics and Examples}
\label{sec:langRev-examples}
\label{examples}

%% \note{Revisit to pick examples relevant to the rest of the paper; also unify notation}

In order to understand the examples of Sec.~\ref{sec:informal}, we review how to represent collections of booleans and
conditionals in $\Pi$. We use the type $\onet + \onet$ to represent booleans with $\inlv{\Acon{tt}}$ representing
\textsf{false} and $\inrv{\Acon{tt}}$ representing $\textsf{true}$. Boolean negation is straightforward to define using
the primitive combinator $\swapp$. We can represent $n$-bit words using an n-ary product of boolean values.
For example, we can express a 3-bit word reversal operation as follows:

$\Afun{reverse} : \mathbb{B}~3 \iso \mathbb{B}~3$

$\Afun{reverse} = \swapt \fatsemi (\swapt  \otimes  \idc)~ \fatsemi \assocrt$

\noindent The manual trace of $\Afun{reverse}$ below confirms that it indeed reverses the three bits:
\[\begin{array}{rlr}
                         & (v_1, (v_2, v_3)) \\
    \swapt               & ((v_2, v_3), v_1) \\
    \swapt \otimes  \idc & ((v_3, v_2), v_1) \\
    \assocrt             & (v_3, (v_2, v_1)) \\
  \end{array}\]
%subcode source isomorphisms.tex:979

Even though \ensuremath{\Pi } lacks conditional expressions, they are expressible using the distributivity and factoring
laws as shown below:

$\Afun{ifc}_{c_1,c_2} : \mathbb{2} \times A \iso \mathbb{2} \times B$

$\Afun{ifc}_{c_1,c_2} = \dist \fatsemi ((\idc  \otimes\  c_1) \oplus (\idc \otimes\  c_2)) \fatsemi \factor$


% \inkscape{if-c1-c2.pdf}


\noindent The input value of type $\mathbb{2} \times A$ is processed by the distribute operator \ensuremath{\dist},
which converts it into a value of type $(\onet \times A) + (\onet \times A)$. In the \ensuremath{\mathit{left}} branch,
which corresponds to the case when the boolean is \ensuremath{\mathit{false}}, the combinator~\ensuremath{c_1} is
applied to the value of type~\ensuremath{A}. The right branch which corresponds to the boolean being
\ensuremath{\mathit{true}} passes the value of type $A$ through the combinator \ensuremath{c_2}.  The inverse of
\ensuremath{\dist}, namely \ensuremath{\factor} is applied to get the final result. The full expressiveness of $\Pi$ is
demonstrated by an implementation of $\Afun{cnot}$ and $\Afun{toffoli}$ which are universal for reversible
computation~\cite{Toffoli:1980}. The $\Afun{cnot}$ gates takes two input bits: a control bit and a target bit, and
negates the target bit if the control bit is set. It is essentially a one-branch version of $\Afun{cif}$ above. The
Toffoli gate generalizes the idea to a gate that takes 3 input bits: 2 control bits and one target bit: boolean inputs:
it negates the target bit if both control bits are set.

% \todo{Not the right title.}

% \note{This section should explain the main technical parts of the paper
%   informally, without using any technology. Use an example, such as, a
%   reversible language with $\leq 5$ bits, and examples of permutations and
%   transpositions, and when they're equal.}

We now revisit the examples in the introduction but instead of working with circuits operating on sequences of bits, we
work with circuits operating on algebraic data types.

\paragraph*{Normalization by evaluation.} Consider the following reversible function:
$\Afun{RESET}(b,b_1,\ldots,b_n) = (b \; \underline{\vee} \; (\bigvee_{i=1}^n b_i),b_1,\ldots,b_n)$ where $\vee$ is
logical-or and $\underline{\vee}$ is exclusive-or. The function sets or resets the first bit depending on whether any of
the other bits is true or not. The natural definition for this function is recursive: modulo some re-shuffling of the
bits, the strategy is to examine the bits $b_i$ one-by-one: if we encounter a true value, we negate the first bit and
terminate; otherwise we continue making recursive calls until we reach the last bit at which point we return the
incoming value with no change:

%%\begin{minipage}{.65\textwidth}
%%  \PiRESET{}
%%\end{minipage}
%%\begin{minipage}{.30\textwidth}
%%  \begin{center}
%%  \resizebox{0.5\textwidth}{!}{\input{diagrams/reset.tikz}}
%%  \end{center}
%%\end{minipage}

\resettwo{}

\noindent The syntax will be explained in detail in the next section and the full definitions of the helpers are
provided in the supplementary material. For now, it is sufficient to know that there is some program that implements the
reversible function of interest and that applying \Afun{reset} to 2 produces \verb|reversibleOr2| from the
introduction. Our Agda infrastructure provides tools to normalize all programs to their normal form. For \Afun{reset 2}
we get:

\resetnormtwo{}

In principle, the normalized program can be produced following two strategies: (i) by repeatedly applying the rewrite
rules of our calculus of reversible functions (explained in Sec.~\ref{sec:reversibletwo}), or (ii) in the case above by
using a normalization-by-evaluation (NBE) process that evaluates the program to a permutation on a finite set of 8
elements and reifies that permutation back to a program. The key idea of the NBE process is a systematic way to express
permutations as sequences of adjacent swaps as illustrated in the following small example where the permutation on the
left is compiled to the sequence of four adjacent transpositions on the right:

% \note{Motivation: There are two reversible circuits which describe the following permutation. They can be shown to be
%   equal using the 2-combinators.}

% \[
%   \begin{tikzpicture}
%     \begin{knot}[clip width=5]
%       \filldraw (0,5) circle (2pt) node[above] {0};
%       \filldraw (1,5) circle (2pt) node[above] {1};
%       \filldraw (2,5) circle (2pt) node[above] {2};
%       \filldraw (3,5) circle (2pt) node[above] {3};
%       \filldraw (4,5) circle (2pt) node[above] {4};
%       \filldraw (0,0) circle (2pt) node[below] {1};
%       \filldraw (1,0) circle (2pt) node[below] {4};
%       \filldraw (2,0) circle (2pt) node[below] {0};
%       \filldraw (3,0) circle (2pt) node[below] {3};
%       \filldraw (4,0) circle (2pt) node[below] {2};
%       \strand (0,5) .. controls (0.5,0.5) and (1.5,3.5) .. (2,0);
%       \strand (1,5) .. controls (0.75,0.5) and (0.25,3.5) .. (0,0);
%       \strand (2,5) .. controls (2.5,2.5) and (3.5,1.5) .. (4,0);
%       \strand (3,5) .. controls (4.5,2.5) and (4,1.5) .. (3,0);
%       \strand (4,5) .. controls (3.5,2.5) and (1.5,2.5) .. (1,0);
%       \flipcrossings{4,5};
%     \end{knot}
%   \end{tikzpicture}
% \]

\paragraph*{Program synthesis.} The NBE process embodies a quoting mechanism that synthesizes programs from
permutations. Indeed, instead of writing a program for \Afun{reset 2}, one might simply specify the desired permutation as:

\resetperm{}

\noindent The permutation uses the canonical encoding of sequences of bits as natural numbers (e.g., (\textsf{false},
\textsf{true},\textsf{true}) is encoded as 011 or 3).  The second entry maps index 1 (= 001) to the value 5 (= 101)
which states that since one of the right bits is set in 001 then the leftmost bit in the output is set. Simply
``quoting'' this permutation generates the same normalized program \Afun{reset2Norm} above.

\paragraph*{Program equivalence.} The permutation above reveals another way to think about the desired program: it is a
special addition circuit that keeps 0 and 4 fixed but otherwise adds 4 modulo 8 to its input. From this specification,
one can use a standard synthesis algorithm for reversible circuits~\cite{10.1145/775832.775915} to generate the
following program:

\adder{}

\noindent The \Afun{adder3} program looks nothing like the original \Afun{reset 2} program and yet they both have the
same normal form thus establishing their equivalence. The reader can check that this circuit is the same as
\verb|reversibleOr1| from the introduction.

% Now imagine we want to write the following reversible function:

% 0 -> 0
% 8 -> 8
% n -> n + 8 `mod` 16

% \note{This might be followed by a section which explains the syntax of Pi.}

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "main"
%%% fill-column: 120
%%% End:



%%%%%%%%%
\subsection{Denotational Semantics}

\noindent The accompanying code includes an operational semantics for $\Pi$. A denotational semantics can be
specified by mapping each type to a finite set and each combinator to a bijection between finite sets, that is, a
permutation. In this section, we outline a simple semantics expressed in the metalanguage of sets and functions. This
semantics will be extended to the metalanguage of homotopy type theory in the remainder of the paper.

The denotation of types is straightforward:

\begin{align*}
  \denot{\zerot}     & = \emptyset                  \\
  \denot{\onet}      & = \{ \Acon{tt} \}            \\
  \denot{A + B}      & = \denot{A} \uplus \denot{B} \\
  \denot{A \times B} & = \denot{A} \times \denot{B}
\end{align*}

where $\emptyset$ is the empty set, $\uplus$ is the disjoint union of sets, and $\times$ is the cartesian product of
sets. The denotation of a combinator $c : A \isot B$ is a (bijective) function mapping $\denot{A}$ to $\denot{B}$:

\begin{longtable}{>{$}r<{$} >{$}l<{$} >{$}c<{$} >{$}l<{$}}
  \denot{\identlp}           & (\inlv{v})           & = & v                                   \\
  \denot{\identrp}           & v                    & = & \inlv{v}                            \\
  \denot{\swapp}             & (\inlv{v})           & = & \inrv{v}                            \\
  \denot{\swapp}             & (\inrv{v})           & = & \inlv{v}                            \\
  \denot{\assoclp}           & (\inlv{v})           & = & \inlv{(\inlv{v})}                   \\
  \denot{\assoclp}           & (\inrv{(\inlv{v})})  & = & \inlv{(\inrv{v})}                   \\
  \denot{\assoclp}           & (\inrv{(\inrv{v})})  & = & \inrv{v}                            \\
  \denot{\assocrp}           & (\inlv{(\inlv{v})})  & = & \inlv{v}                            \\
  \denot{\assocrp}           & (\inlv{(\inrv{v})})  & = & \inrv{(\inlv{v})}                   \\
  \denot{\assocrp}           & (\inrv{v})           & = & \inrv{(\inrv{v})}                   \\
  \denot{\identlt}           & (\Acon{tt} , v)      & = & v                                   \\
  \denot{\identrt}           & v                    & = & (\Acon{tt} , v)                     \\
  \denot{\swapt}             & (v_1 , v_2)          & = & (v_2 , v_1)                         \\
  \denot{\assoclt}           & (v_1 , (v_2 , v_3))  & = & ((v_1 , v_2) , v_3)                 \\
  \denot{\assocrt}           & ((v_1 , v_2) , v_3)  & = & (v_1 , (v_2 , v_3))                 \\
  \denot{\dist}              & (\inlv{v_1} , v_3)   & = & \inlv{(v_1 , v_3)}                  \\
  \denot{\dist}              & (\inrv{v_2 , v_3})   & = & \inrv{(v_2 , v_3)}                  \\
  \denot{\factor}            & (\inlv{(v_1 , v_3)}) & = & (\inlv{v_1} , v_3)                  \\
  \denot{\factor}            & (\inrv{(v_2 , v_3)}) & = & (\inrv{v_2} , v_3)                  \\
  \denot{\idc}               & v                    & = & v                                   \\
  \denot{(c_1 \fatsemi c_2)} & v                    & = & (\denot{c_2} \circ \denot{c_1}) v   \\
  \denot{(c_1 \oplus c_2)}   & (\inlv{v})           & = & \inlv{(\denot{c_1}~v)}              \\
  \denot{(c_1 \oplus c_2)}   & (\inrv{v})           & = & \inrv{(\denot{c_2}~v)}              \\
  \denot{(c_1 \otimes c_2)}  & (v_1 , v_2)          & = & (\denot{c_1} v_1 , \denot{c_2} v_2)
\end{longtable}

% \begingroup
% \allowdisplaybreaks
% \begin{align*}
% \end{align*}
% \endgroup

% \begin{center}
% \begin{tikzpicture}[scale=0.7,every node/.style={scale=0.8}]
%   \draw[>=latex,<->,double,red,thick] (2.25,-1.2) -- (2.25,-2.9) ;
%   \draw[fill] (-2,-1.5) circle [radius=0.025];
%   \node[below] at (-2.1,-1.5) {$A$};
%   \node[below] at (-2.1,-1.9) {$+$};
%   \draw[fill] (-2,-2.5) circle [radius=0.025];
%   \node[below] at (-2.1,-2.5) {$B$};

%   \draw[fill] (6.5,-1.5) circle [radius=0.025];
%   \node[below] at (6.7,-1.5) {$C$};
%   \node[below] at (6.7,-1.9) {$+$};
%   \draw[fill] (6.5,-2.5) circle [radius=0.025];
%   \node[below] at (6.7,-2.5) {$D$};

%   \draw[<-] (-2,-1.5) to[bend left] (1,0.5) ;
%   \draw[<-] (-2,-2.5) to[bend left] (1,-0.5) ;
%   \draw[->] (3.5,0.5) to[bend left] (6.5,-1.45) ;
%   \draw[->] (3.5,-0.5) to[bend left] (6.5,-2.45) ;

%   \draw[<-] (-2,-1.5) to[bend right] (1,-3.5) ;
%   \draw[<-] (-2,-2.5) to[bend right] (1,-4.5) ;
%   \draw[->] (3.5,-3.5) to[bend right] (6.5,-1.55) ;
%   \draw[->] (3.5,-4.5) to[bend right] (6.5,-2.55) ;


%   \draw     (2,0.5)  -- (2.5,0.5)  ;
%   \draw     (2,-0.5) -- (2.5,-0.5) ;

%   \draw     (2.5,0.5)  -- (3.5,-0.5)  ;
%   \draw     (2.5,-0.5) -- (3.5,0.5) ;

%   \draw     (1,-3.5)  -- (2,-4.5)    ;
%   \draw     (1,-4.5) -- (2,-3.5)   ;

%   \draw     (2,-3.5)  -- (2.5,-3.5)    ;
%   \draw     (2,-4.5) -- (2.5,-4.5)   ;

%   \path (1.5,0.5) node (tc1) [func] {$c_1$};
%   \path (1.5,-0.5) node (tc2) [func] {$c_2$};
%   \path (3,-4.5) node (bc1) [func] {$c_1$};
%   \path (3,-3.5) node (bc2) [func] {$c_2$};
% \end{tikzpicture}
% \end{center}
% The top path is the $\Pi$ program $(c_1~\oplus~c_2)~\odot~\swapp$ which acts on the type $A$ by $c_1$, acts on the type
% $B$ by $c_2$, and acts on the resulting value by a twist that exchanges the two injections into the sum type. The bottom
% path performs the twist first and then acts on the type $A$ by $c_1$ and on the type $B$ by $c_2$ as before. One could
% imagine the paths are physical \emph{elastic} wires in $3$ space, where the programs $c_1$ and $c_2$ as arbitrary
% deformations on these wires, and the twists do not touch but are in fact well-separated. Then, holding the points $A$,
% $B$, $C$, and $D$ fixed, it is possible to imagine sliding $c_1$ and $c_2$ from the top wire rightward past the twist,
% and then using the elasticity of the wires, pull the twist back to line up with that of the bottom --- thus making both
% parts of the diagram identical.  Each of these moves can be undone (reversed), and doing so would take the bottom part
% of the diagram into the top part.  In other words, there exists an equivalence of the program
% $(c_1~\oplus~c_2)~\odot~\swapp$ to the program $\swapp \odot (c_2~\oplus~c_1)$. We can also show that this means that,
% as permutations, $(c_1~\oplus~c_2)~\odot~\swapp$ and $\swapp \odot (c_2~\oplus~c_1)$ are equal. And, of course, not all
% programs between the same types can be deformed into one another. The simplest example of inequivalent deformations are
% the two automorphisms of $1+1$, namely $\idc$ and $\swapp$.

The denotational semantics can be used to evaluate programs and to check equivalence of programs. For example, it is
straightforward to verify that $\denot{(c_1~\oplus~c_2)~\fatsemi~\swapp} = \denot{\swapp \fatsemi (c_2~\oplus~c_1)}$. A
slightly more involved example are the following two programs:

\rotate{}

\noindent The first program performs the following sequence of transformations:
\[
  \Tree [ {\small a} [ {\small b} {\small c} ] ] ~\to~
  \Tree [ [ {\small a} {\small b} ] {\small c} ] ~\to~
  \Tree [ {\small c} [ {\small a} {\small b} ] ] ~\to~
  \Tree [ {\small c} [ {\small b} {\small a} ] ] ~.
\]
\noindent
while the second evaluates as follows:
\[
  \Tree [ {\small a} [ {\small b} {\small c} ] ] ~\to~
  \Tree [ {\small a} [ {\small c} {\small b} ] ] ~\to~
  \Tree [ [ {\small a} {\small c} ] {\small b} ] ~\to~
  \Tree [ [ {\small c} {\small a} ] {\small b} ] ~\to~
  \Tree [ {\small c} [ {\small a} {\small b} ] ] ~\to~
  \Tree [ {\small c} [ {\small b} {\small a} ] ] ~.
\]

The semantics above can be packaged in the category of finite sets and functions, $\SetFin$, which is the category
freely generated by finite coproduct completion of the terminal category. Objects of $\SetFin$ can be identified with
sets of fixed cardinality, that is, $\Fin[n] \defeq \Set{0,1,\ldots,n-1}$. $\SetFin$ has finite coproducts and products,
which lets us interpret the types of $\PiLang$. Combinators are intepreted as morphisms in $\SetFin$, but we have to
restrict to invertible morphisms, that is, isomorphisms. This gives the \emph{groupoid} of finite sets and bijections,
$\BFin \defeq \mathsf{core}(\SetFin)$. The isomorphisms satisfied by coproducts and products in $\SetFin$ lift to
$\BFin$, but they're no longer categorical coproducts and products. They give two symmetric monoidal tensor products on
$\BFin$, the additive and multiplicative ones, with the multiplicative tensor distributing over the additive tensor.

\note{change thm:
  1. Each function is a bijection. 2. If there is a 2-combinator, the denotations of the 1-combinators are equal
}

\begin{theorem}\label{thm:grp}
  Let $\sim$ be the following equivalence relation on combinators $c_1 \sim c_2$ iff $\denot{c_1} = \denot{c_2}$
  identifying combinators with the same denotation.  The notation $[c]_{\sim}$ refers to a representative combinator
  from a $\sim$-equivalence class. Using this relation, we define the
  category $\mathcal{C}$ as follows:
  \begin{itemize}
    \item $\mathit{Obj}(\mathcal{C})$ is the set of $\Pi$-types, and
    \item $\mathit{Hom}(A,B) = [c : A \isot B]_{\sim}$
  \end{itemize}
  The category $\mathcal{C}$ is a groupoid.
\end{theorem}
\begin{proof}
  The relation $\sim$ identifies $c$, $\idc \circ c$, and $c \circ \idc$, and is associative. Furthermore, the denotation
  of each combinator is a reversible function thus making every morphism into an isomorphism.
\end{proof}

\note{Then say that $\mathcal{C}$ is ``the same'' as $\BFin$ We can say here that the relation $\sim$ also identifies
  $(c_1~\oplus~c_2)~\fatsemi~\swapp$ and $\swapp \fatsemi (c_2~\oplus~c_1)$ and other properties. ?? }

% \[\begin{array}{l}
%     \Tree[ {\small a} [ {\small b} {\small c} ] ] \\
%     2 \quad 1 \quad 0 \\
%     0 \quad 2 \quad 1 \\
%     \Tree[ [ {\small b}  {\small c} ] {\small a} ]
% \end{array}\]

% Such functions are finitely supported, that is, their outputs can be tabulated using the canonical ordering on
% $\Fin[n]$. For bijections, this gives a listed permutation. By observing the action of the combinators on the values of
% the finite set, we can define a denotational semantics which constructs the bijection.
% \note{\(\Fin[n] \to A \eqv <\type{Vec_{n}}(A)\)}

% In the previous section, we examined equivalences between conventional data structures, i.e., structured trees of
% values. We now consider a richer but foundational notion of data: programs themselves. Indeed, universal computation
% models crucially rely on the fact that \emph{programs are (or can be encoded as) data}, e.g., a Turing machine can be
% encoded as a string that another Turing machine (or even the same machine) can manipulate. Similarly, first-class
% functions are the \emph{only} values in the $\lambda$-calculus.  In our setting, we ask whether the programs developed
% in the previous section can themselves be subject to (higher-level) equivalences?

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "main"
%%% fill-column: 120
%%% End:
