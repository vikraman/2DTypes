\section{A Reversible Programming Language: Set-Theoretic Semantics}
\label{sec:reversibleone}
\label{sec:reversibletwo}
\label{langeqeq}

The practice of programming languages is replete with \emph{ad hoc} instances of reversible computations: database
transactions, mechanisms for data provenance, checkpoints, stack and exception traces, logs, backups, rollback
recoveries, version control systems, reverse engineering, software transactional memories, continuations, backtracking
search, and multiple-level undo features in commercial applications. In the early nineties,
\citet{Baker:1992:LLL,Baker:1992:NFT} argued for a systematic, first-class, treatment of reversibility. But intensive
research in full-fledged reversible models of computations and reversible programming languages was only sparked by the
discovery of deep connections between physics and
computation~\cite{Landauer:1961,PhysRevA.32.3266,Toffoli:1980,bennett1985fundamental,Frank:1999:REC:930275, Hey:1999:FCE:304763,fredkin1982conservative}, and by the
potential for efficient quantum computation~\cite{springerlink:10.1007/BF02650179}.

The early developments of reversible programming languages started
with a conventional programming language, e.g., an extended
$\lambda$-calculus, and either:
\begin{enumerate}
\item extended the language with a history
mechanism~\cite{vanTonder:2004,Kluge:1999:SEMCD,lorenz,danos2004reversible}, or
\item imposed constraints on the control flow constructs to make them
reversible~\cite{Yokoyama:2007:RPL:1244381.1244404}.
\end{enumerate}
More foundational approaches recognize that reversible programming languages require a fresh approach and should be
designed from first principles without the detour via conventional irreversible
languages~\cite{Yokoyama:2008:PRP,Mu:2004:ILRC,abramsky2005structural,DiPierro:2006:RCL:1166042.1166047,
  rc2011,James:2012:IE:2103656.2103667,Carette2016}.

%%%%%%%%%%%%%%%%%
\subsection{The $\Pi$ Family of Languages}

A natural candidate for a semantic foundation for reversible programming languages is the notion of type
isomorphism. Indeed, the type isomorphisms among finite types are sound and complete for all permutations on finite
types~\cite{Fiore:2004,fiore-remarks} and hence they are \emph{complete} for expressing reversible combinational
circuits~\cite{fredkin1982conservative, James:2012:IE:2103656.2103667,Toffoli:1980} and the extension with recursive
types and trace operators~\cite{Hasegawa:1997:RCS:645893.671607} is a Turing-complete reversible
language~\cite{James:2012:IE:2103656.2103667,rc2011}.

Focusing on finite types, the building blocks of type theory are: the empty type ($\zerot$), the unit type
($\onet$) containing just one value $\Acon{tt}$, the sum type ($+$) containing values of the form $\inlv{v}$ and
$\inrv{v}$, and the product ($\times$) type containing pairs of values $(v_1,v_2)$. For this fragment of types, the
syntax of the language $\Pi$ consists of the following sorts:

{\scalebox{\scalef}{$%
\begin{array}{lrcl}
\textit{Value types} & A,B,C,D &::=& \zerot \alt \onet \alt A+B \alt A\times B \\
\textit{Values}      & v,w,x,y &::=& \Acon{tt} \alt \inlv{v} \alt \inrv{v} \alt (v,w) \\
\textit{Program types} &&& A \iso B \\
\textit{Programs} & c &::=& (\textrm{See Fig.~\ref{pi-terms}})
\end{array}$}}
\begin{figure}[t]
{\scalebox{\scalef}{$%
%%\noindent\begin{minipage}{.7\linewidth}
\begin{array}{rrcll}
\idc :& A & \iso & A &: \idc \\
\\
\identlp :&  \zerot + A & \iso & A &: \identrp \\
\swapp :&  A + B & \iso & B + A &: \swapp \\
\assoclp :&  A + (B + C) & \iso & (A + B) + C &: \assocrp \\ [1.5ex]
\identlt :&  \onet \times A & \iso & A &: \identrt \\
\swapt :&  A \times B & \iso & B \times A &: \swapt \\
\assoclt :&  A \times (B \times C) & \iso & (A \times B) \times C &: \assocrt \\ [1.5ex]
\absorbr :&~ \zerot \times A & \iso & \zerot ~ &: \factorzl \\
\dist :&~ (A + B) \times C & \iso & (A \times C) + (B \times C)~ &: \factor
  \end{array}$}}

{\scalebox{\scalef}{%
\Rule{}
{\jdg{}{}{c_1 : A \iso B} \quad \vdash c_2 : B \iso C}
{\jdg{}{}{c_1 \fatsemi c_2 : A \iso C}}
{}

\Rule{}
{\jdg{}{}{c_1 : A \iso B} \quad \vdash c_2 : C \iso D}
{\jdg{}{}{c_1 \oplus c_2 : A + C \iso B + D}}
{}

\Rule{}
{\jdg{}{}{c_1 : A \iso B} \quad \vdash c_2 : C \iso D}
{\jdg{}{}{c_1 \otimes c_2 : A \times C \iso B \times D}}
{}
}}
\caption{$\Pi$-terms, combinators, and their types.}
\label{pi-terms}
\end{figure}

\noindent Intuitively, one may view each type $A$ as a collection of physical wires that can transmit $\sizet{A}$
distinct values where $\sizet{A}$ is a natural number that indicates the size of a type, computed as:
$\sizet{\zerot} = 0$; $\sizet{\onet} = 1$; $\sizet{A + B} = \sizet{A} + \sizet{B}$; and
$\sizet{A \times B} = \sizet{A} * \sizet{B}$.  Thus the type $\mathbb{2} = \onet + \onet$ corresponds to a wire that can
transmit one of two values, i.e., bits. The type $\mathbb{2} \times (\mathbb{2} \times \mathbb{2})$ (abbreviated
$\mathbb{B}~3$) corresponds to a collection of wires that can transmit three bits. From that perspective, a type
isomorphism between types $A$ and $B$ (such that $\sizet{A}=\sizet{B}=n$) models a \emph{reversible} combinational
circuit that \emph{permutes} the $n$ different values. These type isomorphisms form a \emph{commutative semiring} and
are collected in Fig.~\ref{pi-terms}. Each line in the top part of the figure introduces a pair of dual constants that
witness the type isomorphism in the middle.  These are the \emph{base} (non-reducible) terms of $\Pi$. The isomorphisms
are extended to form a congruence relation by adding the three constructors at the bottom of the figure that witness
equivalence and compatible closure. Although austere, this combinator-based language has the advantage of being amenable
to formal analysis for at least two reasons: (i) it is conceptually simple and small, and (ii) it has direct and evident
connections to type theory and category theory and hence possesses a rich algebraic structure which we exploit in the
remainder of the paper.

%%%%%%%%%
\subsection{Denotational Semantics (Outline)}

\noindent The accompanying code includes an operational semantics for $\Pi$. A denotational semantics can be
specified by mapping each type to a finite set and each combinator to a bijection between finite sets, that is, a
permutation. In this section, we outline a simple semantics expressed in the metalanguage of sets and functions. This
semantics will be formalized and extended to the metalanguage of homotopy type theory in Sec.~\ref{sec:reversibletwo}.

As explained in the previous section, a $\Pi$-type $A$ has $\sizet{A}$-elements and for all combinators $c : A \iso B$
we have that $\sizet{A} = \sizet{B}$. Hence, the denotation $\denot{A}$ of a type $A$ with $n$-elements can be the finite
set $\Fin[n] = \{ 0, 1, \cdots, n-1\}$; the denotation of a value $v : A$ such that $\sizet{A}=n$ will be an index in
the range $[0,n-1]$, and the denotation $\denot{c}$ of a combinator $c : A \iso B$ such that
$\sizet{A} = \sizet{B} = n$ will be a function from $\Fin[n]$ to $\Fin[n]$ that permutes the elements. Thus, all types
with 3 elements will denote $\Fin[3]$ and combinators between them will denote permutations on $\Fin[3]$, e.g.:
\[\begin{array}{rcl}
    \denot{\onet + (\onet + \onet)} &=& \{ 0,1,2 \} \\
    \denot{(\onet + \onet) + \onet} &=& \{ 0,1,2 \} \\
    \\
    \denot{\assoclp : \onet + (\onet + \onet) \iso (\onet + \onet) + \onet} &=& (0~1~2) \\
    \denot{\swapp : \onet + (\onet + \onet) \iso (\onet + \onet) + \onet} &=& (2~0~1)
\end{array}\]
where we have used the one-line notation for permutations with $(a~b~c)$ representing the
permutation that maps 0 to $a$, 1 to $b$, and 2 to $c$. To make the denotation of values precise, we compute a canonical
enumeration of the elements of each type:
\[\begin{array}{rcl}
    \mathit{enum}(\zerot) &=& [~] \\
    \mathit{enum}(\onet) &=& [ ~\Acon{tt}~ ] \\
    \mathit{enum}(A + B) &=& \mathit{map}~\Acon{inj₁}~\mathit{enum}(A) ~\textsf{+\!+}~ \mathit{map}~\Acon{inj₂}~\mathit{enum}(B) \\
    \mathit{enum}(A \times B) &=& \mathit{concat}~(\mathit{map}~(\lambda v.\mathit{map}~(\lambda w. (v,w))~\mathit{enum}(B))~\mathit{enum}(A))
\end{array}\]
\noindent The specification uses a Haskell-like notation for sequences with $\mathit{map}$ as the operation that applies
a function to each element of a sequence, \textsf{+\!+} as the binary append operation, and $\mathit{concat}$ the
operation that appends all the subsequences in a sequence.

Using the definition, we have:
\[\begin{array}{rcl}
    \mathit{enum}(\onet + (\onet + \onet)) &=& [ \inlv{\Acon{tt}},~\inrv{(\inlv{\Acon{tt}})},~\inrv{(\inrv{\Acon{tt}})} ] \\
    \mathit{enum}((\onet + \onet) + \onet) &=& [ \inlv{(\inlv{\Acon{tt}})},~\inlv{(\inrv{\Acon{tt}})},~\inrv{\Acon{tt}} ]
\end{array}\]
Thus, as shown in the diagrams below, $\assoclp~(\inlv{\Acon{tt}})$ applies the permutation $(0~1~2)$ to the index of
$\inlv{\Acon{tt}}$ which is 0 and produces index 0 in the $(\onet + \onet) + \onet$ type corresponding to value
$\inlv{(\inlv{\Acon{tt}})}$. Similarly, $\swapp~(\inlv{\Acon{tt}})$ applies the permutation $(2~0~1)$ to the index of
$\inlv{\Acon{tt}}$ which is 0 and produces index 2 in the $(\onet + \onet) + \onet)$ type corresponding to value
$\inrv{\Acon{tt}}$.

\begin{center}
  \input{assoc-perm.tikz}
  \qquad
  \input{swap-perm.tikz}
\end{center}


% \[\begin{array}{l}
%     \Tree[ {\small a} [ {\small b} {\small c} ] ] \\
%     2 \quad 1 \quad 0 \\
%     0 \quad 2 \quad 1 \\
%     \Tree[ [ {\small b}  {\small c} ] {\small a} ]
% \end{array}\]

% Such functions are finitely supported, that is, their outputs can be tabulated using the canonical ordering on
% $\Fin[n]$. For bijections, this gives a listed permutation. By observing the action of the combinators on the values of
% the finite set, we can define a denotational semantics which constructs the bijection.
% \note{\(\Fin[n] \to A \eqv <\type{Vec_{n}}(A)\)}


An alternative point of view for the semantics in Sec.~\ref{reversibleone} is to consider it  as expressed in the
category of finite sets and functions, $\SetFin$, which is the category freely generated by finite coproduct completion
of the terminal category. Objects of $\SetFin$ can be identified with sets of fixed cardinality, that is,
$\Fin[n] \defeq \Set{0,1,\ldots,n-1}$. $\SetFin$ has finite coproducts and products, which lets us interpret the types
of $\PiLang$. Combinators are intepreted as morphisms in $\SetFin$, but we have to restrict to invertible morphisms,
that is, isomorphisms. This gives the \emph{groupoid} of finite sets and bijections,
$\BFin \defeq \mathsf{core}(\SetFin)$. The isomorphisms satisfied by coproducts and products in $\SetFin$ lift to
$\BFin$, but they're no longer categorical coproducts and products. They give two symmetric monoidal tensor products on
$\BFin$, the additive and multiplicative ones, with the multiplicative tensor distributing over the additive tensor.

We choose a canonical set of size $n$, called $\mathsf{Fin}~n$, whose elements are natural numbers less than $n$. To
compute the denotation of a type $A$, we first calculate its size $n = \sizet{A}$. We then construct the canonical set
$\mathsf{Fin}~n$ and provide the (trivial) evidence that this set is identical to $(\mathsf{Fin}~n)$:

\[\begin{array}{rcll}
\sem{A} &=& (\mathsf{Fin}~n, [ n , \mathsf{refl} ]) & \mbox{where}~\sizet{A} = n
\end{array}\]

\noindent The denotation $\sem{c}$ of a combinator $c : A \isot B$ is a path between $\sem{A}$ and $\sem{B}$. If the
size of $A$ is $m$ and the size of $B$ is $n$, the desired path is between $(\mathsf{Fin}~m, [ m , \mathsf{refl} ])$ and
$(\mathsf{Fin}~n, [ n , \mathsf{refl} ])$. This path is directly constructed using $\mathit{ap}$ and the fact that $m=n$
since combinators are always between types of the same size.

\noindent Finally, given two combinators $p , q : A \isot_1 B$ and a 2-combinator $\alpha : p \Iso q$, the denotation
$\sem{\alpha}$ of $\alpha$ is a path between $\sem{p}$ and $\sem{q}$.

\note{We use the rig structure of $\UFin$ in~\cref{subsec:rig} to interpret $\PiLang$.}


We need a formal definition of normal form (canonical form)

In the previous section, we examined equivalences between conventional data structures, i.e., structured trees of
values. We now consider a richer but foundational notion of data: programs themselves. Indeed, universal computation
models crucially rely on the fact that \emph{programs are (or can be encoded as) data}, e.g., a Turing machine can be
encoded as a string that another Turing machine (or even the same machine) can manipulate. Similarly, first-class
functions are the \emph{only} values in the $\lambda$-calculus.  In our setting, we ask whether the programs developed
in the previous section can themselves be subject to (higher-level) equivalences?

We will explain the ideas using two small exaamples. Consider the following two programs mapping between the types
$A + B$ and $C+D$:

\begin{center}
\begin{tikzpicture}[scale=0.7,every node/.style={scale=0.8}]
  \draw[>=latex,<->,double,red,thick] (2.25,-1.2) -- (2.25,-2.9) ;
  \draw[fill] (-2,-1.5) circle [radius=0.025];
  \node[below] at (-2.1,-1.5) {$A$};
  \node[below] at (-2.1,-1.9) {$+$};
  \draw[fill] (-2,-2.5) circle [radius=0.025];
  \node[below] at (-2.1,-2.5) {$B$};

  \draw[fill] (6.5,-1.5) circle [radius=0.025];
  \node[below] at (6.7,-1.5) {$C$};
  \node[below] at (6.7,-1.9) {$+$};
  \draw[fill] (6.5,-2.5) circle [radius=0.025];
  \node[below] at (6.7,-2.5) {$D$};

  \draw[<-] (-2,-1.5) to[bend left] (1,0.5) ;
  \draw[<-] (-2,-2.5) to[bend left] (1,-0.5) ;
  \draw[->] (3.5,0.5) to[bend left] (6.5,-1.45) ;
  \draw[->] (3.5,-0.5) to[bend left] (6.5,-2.45) ;

  \draw[<-] (-2,-1.5) to[bend right] (1,-3.5) ;
  \draw[<-] (-2,-2.5) to[bend right] (1,-4.5) ;
  \draw[->] (3.5,-3.5) to[bend right] (6.5,-1.55) ;
  \draw[->] (3.5,-4.5) to[bend right] (6.5,-2.55) ;


  \draw     (2,0.5)  -- (2.5,0.5)  ;
  \draw     (2,-0.5) -- (2.5,-0.5) ;

  \draw     (2.5,0.5)  -- (3.5,-0.5)  ;
  \draw     (2.5,-0.5) -- (3.5,0.5) ;

  \draw     (1,-3.5)  -- (2,-4.5)    ;
  \draw     (1,-4.5) -- (2,-3.5)   ;

  \draw     (2,-3.5)  -- (2.5,-3.5)    ;
  \draw     (2,-4.5) -- (2.5,-4.5)   ;

  \path (1.5,0.5) node (tc1) [func] {$c_1$};
  \path (1.5,-0.5) node (tc2) [func] {$c_2$};
  \path (3,-4.5) node (bc1) [func] {$c_1$};
  \path (3,-3.5) node (bc2) [func] {$c_2$};
\end{tikzpicture}
\end{center}
The top path is the $\Pi$ program $(c_1~\oplus~c_2)~\odot~\swapp$ which acts on the type $A$ by $c_1$, acts on the type
$B$ by $c_2$, and acts on the resulting value by a twist that exchanges the two injections into the sum type. The bottom
path performs the twist first and then acts on the type $A$ by $c_1$ and on the type $B$ by $c_2$ as before. One could
imagine the paths are physical \emph{elastic} wires in $3$ space, where the programs $c_1$ and $c_2$ as arbitrary
deformations on these wires, and the twists do not touch but are in fact well-separated. Then, holding the points $A$,
$B$, $C$, and $D$ fixed, it is possible to imagine sliding $c_1$ and $c_2$ from the top wire rightward past the twist,
and then using the elasticity of the wires, pull the twist back to line up with that of the bottom --- thus making both
parts of the diagram identical.  Each of these moves can be undone (reversed), and doing so would take the bottom part
of the diagram into the top part.  In other words, there exists an equivalence of the program
$(c_1~\oplus~c_2)~\odot~\swapp$ to the program $\swapp \odot (c_2~\oplus~c_1)$. We can also show that this means that,
as permutations, $(c_1~\oplus~c_2)~\odot~\swapp$ and $\swapp \odot (c_2~\oplus~c_1)$ are equal. And, of course, not all
programs between the same types can be deformed into one another. The simplest example of inequivalent deformations are
the two automorphisms of $1+1$, namely $\idc$ and $\swapp$.

As another example, consider consider a circuit that takes an input type consisting of three values \Tree [ {\small a} [
{\small b} {\small c} ] ]~ and swaps the leftmost value with the rightmost value to produce \Tree [ {\small c} [ {\small
  b} {\small a} ] ]~.  We can implement two such circuits using our Agda library for $\Pi$:

\begin{code}%
\>[0]\AgdaFunction{swap{-}fl1}\AgdaSpace{}%
\AgdaFunction{swap{-}fl2}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaBound{a}\AgdaSpace{}%
\AgdaBound{b}\AgdaSpace{}%
\AgdaBound{c}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaDatatype{U}\AgdaSymbol{\}}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaInductiveConstructor{PLUS}\AgdaSpace{}%
\AgdaBound{a}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaInductiveConstructor{PLUS}\AgdaSpace{}%
\AgdaBound{b}\AgdaSpace{}%
\AgdaBound{c}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaDatatype{⟷}\AgdaSpace{}%
\AgdaInductiveConstructor{PLUS}\AgdaSpace{}%
\AgdaBound{c}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaInductiveConstructor{PLUS}\AgdaSpace{}%
\AgdaBound{b}\AgdaSpace{}%
\AgdaBound{a}\AgdaSymbol{)}\<%
\\
\>[0]\AgdaFunction{swap{-}fl1}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaInductiveConstructor{assocl₊}\AgdaSpace{}%
\AgdaInductiveConstructor{◎}\AgdaSpace{}%
\AgdaInductiveConstructor{swap₊}\AgdaSpace{}%
\AgdaInductiveConstructor{◎}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaInductiveConstructor{id⟷}\AgdaSpace{}%
\AgdaInductiveConstructor{⊕}\AgdaSpace{}%
\AgdaInductiveConstructor{swap₊}\AgdaSymbol{)}\<%
\\
%
\\[\AgdaEmptyExtraSkip]%
\>[0]\AgdaFunction{swap{-}fl2}\AgdaSpace{}%
\AgdaSymbol{=}%
\>[52I]\AgdaSymbol{(}\AgdaInductiveConstructor{id⟷}\AgdaSpace{}%
\AgdaInductiveConstructor{⊕}\AgdaSpace{}%
\AgdaInductiveConstructor{swap₊}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaInductiveConstructor{◎}\<%
\\
\>[.]\<[52I]%
\>[11]\AgdaInductiveConstructor{assocl₊}\AgdaSpace{}%
\AgdaInductiveConstructor{◎}\<%
\\
%
\>[11]\AgdaSymbol{(}\AgdaInductiveConstructor{swap₊}\AgdaSpace{}%
\AgdaInductiveConstructor{⊕}\AgdaSpace{}%
\AgdaInductiveConstructor{id⟷}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaInductiveConstructor{◎}\<%
\\
%
\>[11]\AgdaInductiveConstructor{assocr₊}\AgdaSpace{}%
\AgdaInductiveConstructor{◎}\<%
\\
%
\>[11]\AgdaSymbol{(}\AgdaInductiveConstructor{id⟷}\AgdaSpace{}%
\AgdaInductiveConstructor{⊕}\AgdaSpace{}%
\AgdaInductiveConstructor{swap₊}\AgdaSymbol{)}\<%
\end{code}

\noindent The first implementation rewrites the incoming values as follows:
\[
\Tree [ {\small a} [ {\small b} {\small c} ] ] ~\to~
\Tree [ [ {\small a} {\small b} ] {\small c} ] ~\to~
\Tree [ {\small c} [ {\small a} {\small b} ] ] ~\to~
\Tree [ {\small c} [ {\small b} {\small a} ] ] ~.
\]
\noindent
The second implementation rewrites the incoming values as follows:
\[
\Tree [ {\small a} [ {\small b} {\small c} ] ] ~\to~
\Tree [ {\small a} [ {\small c} {\small b} ] ] ~\to~
\Tree [ [ {\small a} {\small c} ] {\small b} ] ~\to~
\Tree [ [ {\small c} {\small a} ] {\small b} ] ~\to~
\Tree [ {\small c} [ {\small a} {\small b} ] ] ~\to~
\Tree [ {\small c} [ {\small b} {\small a} ] ] ~.
\]
\noindent The two circuits are extensionally equal. Using the level-2
isomorphisms we can \emph{explicitly} construct a sequence of
rewriting steps that transforms the second circuit to the first.

Recalling that the $\lambda$-calculus arises as the internal language of Cartesian Closed Categories
(Elliott~\cite{Elliott-2017} gives a particularly readable account of this), we can think of $\Pi$ in similar terms, but
for symmetric Rig Groupoids instead. For example, we can ask what does the equivalence above represent? It is actually a
``linear'' representation of a 2-categorial commutative diagram! In fact, it is a painfully verbose version thereof, as
it includes many \emph{refocusing} steps because our language does not build associativity into its syntax. Categorical
diagrams usually do.  Thus if we rewrite the example in diagrammatic form, eliding all uses of associativity, but
keeping explicit uses of identity transformations, we get that \AgdaFunction{swap{-}fl2⇔swap{-}fl1} represents

\vspace*{3mm}
\begin{tikzcd}[column sep=normal, row sep=normal]
 && (a+c)+b \arrow [r, "\swapp \oplus\idd", ""{name=U, below}] & (c+a)+b \arrow [dr, "\assocrp"] && \\
 & a+(c+b) \arrow [ur, "\assoclp"] & & & c+(a+b) \arrow [dr, "\idd\oplus\swapp"] &  \\
a+(b+c) \arrow [ur, "\idd\oplus\swapp"] \arrow [r, "\assoclp"]
  \arrow [dr, "\assoclp"]
  \arrow [ddr, swap, "\assoclp"]
    & (a+b)+c \arrow [r, "\swapp"] &
    c+(a+b) \arrow [r, swap, "\assoclp", ""{name=D, above}]
    & |[alias=Z]| (c+a)+b \arrow [r, "\assocrp"] &c+(a+b) \arrow [r, "\idd\oplus\swapp"] & c+(b+a) \\
 & (a+b)+c \arrow [dr, "\swapp"] &&&& \\
 & (a+b)+c \arrow [dr, swap, "\swapp"] & c+(a+b) \arrow [rr, swap, "\idd", ""{name=DD, above}]
             \arrow [d, Rightarrow, "\idf\, \mathit{idl}\odot{l}"] &&
    c+(a+b) \arrow [ruu, "\idd\oplus\swapp"] & \\
 && c+(a+b) \arrow [rrruuu, bend right = 40, swap, "\idd\oplus\swapp"] && \\
 \arrow[Rightarrow, from=U, to=D, "\mathit{hexagon}\oplus{r}\, \boxdot\, \idf"]
 \arrow[Rightarrow, from=Z, to=DD, swap, "\idf\boxdot\mathit{linv}\odot{l}\,\boxdot\,\idf"]
\end{tikzcd}

%%%%%%%%%
\subsection{Examples}
\label{sec:langRev-examples}
\label{examples}

%% \note{Revisit to pick examples relevant to the rest of the paper; also unify notation}

In order to understand the examples of Sec.~\ref{sec:informal}, we review how to represent collections of booleans and
conditionals in $\Pi$. We use the type $\onet + \onet$ to represent booleans with $\inlv{\Acon{tt}}$ representing
\textsf{false} and $\inrv{\Acon{tt}}$ representing $\textsf{true}$. Boolean negation is straightforward to define using
the primitive combinator $\swapp$. We can represent $n$-bit words using an n-ary product of boolean values.
For example, we can express a 3-bit word reversal operation as follows:

$\Afun{reverse} : \mathbb{B}~3 \iso \mathbb{B}~3$

$\Afun{reverse} = \swapt \fatsemi (\swapt  \otimes  \idc)~ \fatsemi \assocrt$

\noindent The manual trace of $\Afun{reverse}$ below confirms that it indeed reverses the three bits:
\[\begin{array}{rlr}
 & (v_1, (v_2, v_3)) \\
 \swapt & ((v_2, v_3), v_1) \\
 \swapt \otimes  \idc & ((v_3, v_2), v_1) \\
 \assocrt & (v_3, (v_2, v_1)) \\
 \end{array}\]
%subcode source isomorphisms.tex:979

Even though \ensuremath{\Pi } lacks conditional expressions, they are expressible using the distributivity and factoring
laws as shown below:

$\Afun{ifc}_{c_1,c_2} : \mathbb{2} \times A \iso \mathbb{2} \times B$

$\Afun{ifc}_{c_1,c_2} = \dist \fatsemi ((\idc  \otimes\  c_1) \oplus (\idc \otimes\  c_2)) \fatsemi \factor$


% \inkscape{if-c1-c2.pdf}


\noindent The input value of type $\mathbb{2} \times A$ is processed by the distribute operator \ensuremath{\dist},
which converts it into a value of type $(\onet \times A) + (\onet \times A)$. In the \ensuremath{\mathit{left}} branch,
which corresponds to the case when the boolean is \ensuremath{\mathit{false}}, the combinator~\ensuremath{c_1} is
applied to the value of type~\ensuremath{A}. The right branch which corresponds to the boolean being
\ensuremath{\mathit{true}} passes the value of type $A$ through the combinator \ensuremath{c_2}.  The inverse of
\ensuremath{\dist}, namely \ensuremath{\factor} is applied to get the final result. The full expressiveness of $\Pi$ is
demonstrated by the following implementation of $\Afun{cnot}$ and $\Afun{toffoli}$ which are universal for reversible
computation~\cite{Toffoli:1980}. The $\Afun{cnot}$ gates takes two input bits: a control bit and a target bit, and
negates the target bit if the control bit is set. It is essentially a one-branch version of $\Afun{cif}$ above. The
Toffoli gate generalizes the idea to a gate that takes 3 input bits: 2 control bits and one target bit: boolean inputs:
it negates the target bit if both control bits are set.

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "main"
%%% fill-column: 120
%%% End:
