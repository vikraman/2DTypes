\begin{figure}[t]
  {\scalebox{\scalef}{$%
        %%\noindent\begin{minipage}{.7\linewidth}
        \begin{array}{rrcll}
          \idc :     & A                     & \isoone & A                            & : \idc      \\
          \\
          \identlp : & \zerot + A            & \isoone & A                            & : \identrp  \\
          \swapp :   & A + B                 & \isoone & B + A                        & : \swapp    \\
          \assoclp : & A + (B + C)           & \isoone & (A + B) + C                  & : \assocrp  \\ [1.5ex]
          \identlt : & \onet \times A        & \isoone & A                            & : \identrt  \\
          \swapt :   & A \times B            & \isoone & B \times A                   & : \swapt    \\
          \assoclt : & A \times (B \times C) & \isoone & (A \times B) \times C        & : \assocrt  \\ [1.5ex]
          \absorbr : & ~ \zerot \times A     & \isoone & \zerot ~                     & : \factorzl \\
          \dist :    & ~ (A + B) \times C    & \isoone & (A \times C) + (B \times C)~ & : \factor
        \end{array}$}}

  \medskip

  {\scalebox{\scalef}{%
      \Rule{}
      {\jdg{}{}{c_1 : A \isoone B} \quad \vdash c_2 : B \isoone C}
      {\jdg{}{}{c_1 \fatsemi c_2 : A \isoone C}}
      {}

      \Rule{}
      {\jdg{}{}{c_1 : A \isoone B} \quad \vdash c_2 : C \isoone D}
      {\jdg{}{}{c_1 \oplus c_2 : A + C \isoone B + D}}
      {}

      \Rule{}
      {\jdg{}{}{c_1 : A \isoone B} \quad \vdash c_2 : C \isoone D}
      {\jdg{}{}{c_1 \otimes c_2 : A \times C \isoone B \times D}}
      {}
    }}
  \caption{$\Pi$-terms, combinators, and their types.}
  \label{fig:pi-terms}
\end{figure}

\section{A Reversible Programming Language}
%% ~3 pages
\label{sec:pi}
\label{sec:reversibleone}
\label{sec:reversibletwo}
\label{langeqeq}
\label{sec:informal}

The circuit model of reversible computation discussed in the introduction is a useful abstraction close to the hardware
platform. However, since its main data abstraction is a \emph{sequence of wires}, it only provides an ``assembly-level''
programming abstraction (e.g., \verb|qasm|). As motivated by \citet{LAFONT2003257}, a mathematical model based on
permutations of finite sets provides a richer algebraic structure which we review in this section.

%%%%%%%%%%%%%%%%%
\subsection{The $\Pi$ Family of Languages}
\label{sec:langRev-examples}
\label{examples}

In a reversible boolean circuit, the number of input bits matches the number of output bits. Circuits can be composed
sequentially, vertically, or horizontally, respectively preserving the number of bits, adding up the number of bits or
multiplying them. So, to program with reversible circuits, all we need to do is make sure that each primitive operation
preserves the number of bits, which is just a natural number. Natural numbers are the free commutative semiring (or,
commutative rig) on one generator, with $(0,+)$ for addition, and $(1,\times)$ for multiplication, so the commutative
semirig identities can be used to design a logic for reversible programming. This inspired the syntax for various
first-order reversible logics and reversible programming
languages~\cite*{sparksSuperstructuralReversibleLogic2014,jamesInformationEffects2012}.

Natural number identities have no computational content. To obtain a computational interpretation of the commutative rig
structure, the logic needs to be equipped with values and types, and a notion of operational semantics and contextual
equivalence~\cite{jamesInformationEffects2012}. This is a programming language which embodies the computational content
of isomorphisms of finite types, or permutations. On the semantic side, we need to consider the groupoidification of a
commutative rig, that is, a symmetric rig groupoid. A sound semantics for $\PiLang$ in weak rig groupoids was
established in~\cite{caretteComputingSemiringsWeak2016}, and conjectured to be complete.

% In programming parlance, as shown in~\cref{fig:pi-terms}, each primitive algebraic identity of commutative rigs becomes
% a reversible combinator in the programming language and the algebraic closure operators become composition operators in
% the programming language. Once equipped with a notion of values and types, we get the following syntactic presentation
% of a programming language for permutations~\cite{James:2012:IE:2103656.2103667,Carette2016}:

% A specialised language for programming with permutations on finite sets can be built using ideas going back to Kelly,
% Laplaza, and Mac Lane~\cite{laplaza72,kelly74,KELLY197197} that the commutative semiring (also known as the commutative
% rig) of natural numbers exactly characterizes permutations on finite sets. In programming parlance, as shown in
% Fig.~\ref{fig:pi-terms}, each primitive algebraic identity of commutative rigs becomes a constant in the programming
% language and the algebraic closure operators become composition operators in the programming language. Once equipped
% with a notion of values and types, we get the following syntactic presentation of a programming language for
% permutations~\cite{James:2012:IE:2103656.2103667,Carette2016}:

% The practice of programming languages is replete with \emph{ad hoc} instances of reversible computations: database
% transactions, mechanisms for data provenance, checkpoints, stack and exception traces, logs, backups, rollback
% recoveries, version control systems, reverse engineering, software transactional memories, continuations, backtracking
% search, and multiple-level undo features in commercial applications. In the early nineties,
% \citet{Baker:1992:LLL,Baker:1992:NFT} argued for a systematic, first-class, treatment of reversibility. But intensive
% research in full-fledged reversible models of computations and reversible programming languages was only sparked by the
% discovery of deep connections between physics and
% computation~\cite{Landauer:1961,PhysRevA.32.3266,Toffoli:1980,bennett1985fundamental,Frank:1999:REC:930275, Hey:1999:FCE:304763,fredkin1982conservative}, and by the
% potential for efficient quantum computation~\cite{springerlink:10.1007/BF02650179}.

% The early developments of reversible programming languages started
% with a conventional programming language, e.g., an extended
% $\lambda$-calculus, and either:
% \begin{enumerate}
%   \item extended the language with a history
%         mechanism~\cite{vanTonder:2004,Kluge:1999:SEMCD,lorenz,danos2004reversible}, or
%   \item imposed constraints on the control flow constructs to make them
%         reversible~\cite{Yokoyama:2007:RPL:1244381.1244404}.
% \end{enumerate}
% More foundational approaches recognize that reversible programming languages require a fresh approach and should be
% designed from first principles without the detour via conventional irreversible
% languages~\cite{Yokoyama:2008:PRP,Mu:2004:ILRC,abramsky2005structural,DiPierro:2006:RCL:1166042.1166047,
%   rc2011, James:2012:IE:2103656.2103667, Carette2016}.

\medskip

{\scalebox{\scalef}{$%
      \begin{array}{lrcl}
        \textit{Value types}   & A,B,C,D & ::= & \zerot \alt \onet \alt A+B \alt A\times B        \\
        \textit{Values}        & v,w,x,y & ::= & \Acon{tt} \alt \inlv{v} \alt \inrv{v} \alt (v,w) \\
        \textit{Program types} &         &     & A \isoone B                                      \\
        \textit{Programs}      & c       & ::= & (\textrm{See Fig.~\ref{fig:pi-terms}})
      \end{array}$}}

\medskip\noindent The language of types is built from the empty type ($\zerot$), the unit type
($\onet$) containing just one value~$\Acon{tt}$, the sum type ($+$) containing values of the form $\inlv{v}$ and
$\inrv{v}$, and the product type ($\times$) containing pairs of values $(v_1,v_2)$.
%
% A natural candidate for a semantic foundation for reversible programming languages is the notion of type
% isomorphism. Indeed, the type isomorphisms among finite types are sound and complete for all permutations on finite
% types~\cite{Fiore:2004,fiore-remarks} and hence they are \emph{complete} for expressing reversible combinational
% circuits~\cite{fredkin1982conservative, James:2012:IE:2103656.2103667,Toffoli:1980} and the extension with recursive
% types and trace operators~\cite{Hasegawa:1997:RCS:645893.671607} is a Turing-complete reversible
% language~\cite{James:2012:IE:2103656.2103667,rc2011}.

To see how this language expresses reversible circuits, we present a few examples. First it is possible to directly
mimic the \verb|qasm|-perspective by defining types that describe sequences of booleans. We use the type
$\mathbb{2} = \onet + \onet$ to represent booleans with $\inlv{\Acon{tt}}$ representing \textsf{true} and
$\inrv{\Acon{tt}}$ representing $\textsf{false}$. Boolean negation (the \verb|x|-gate) is straightforward to define using
the primitive combinator $\swapp$. We can represent $n$-bit words using an n-ary product of boolean values, thus the
type $\mathbb{2} \times (\mathbb{2} \times \mathbb{2})$ (abbreviated $\mathbb{B}~3$) corresponds to a collection of
wires that can transmit three bits.
%
% For example, we can express a 3-bit word reversal operation as follows:
% $\Afun{reverse} : \mathbb{B}~3 \iso \mathbb{B}~3$
% $\Afun{reverse} = \swapt \fatsemi (\swapt  \otimes  \idc)~ \fatsemi \assocrt$
% \noindent The manual trace of $\Afun{reverse}$ below confirms that it indeed reverses the three bits:
% \[\begin{array}{rlr}
%                          & (v_1, (v_2, v_3)) \\
%     \swapt               & ((v_2, v_3), v_1) \\
%     \swapt \otimes  \idc & ((v_3, v_2), v_1) \\
%     \assocrt             & (v_3, (v_2, v_1)) \\
%   \end{array}\]
%subcode source isomorphisms.tex:979
%
To express the \verb|cx| and \verb|ccx| gates, we need to encode a notion of conditional expression. Such conditionals
turn out to be expressible using the distributivity and factoring identities of rigs as shown below:

\medskip

\cif{}

\noindent The input value of type $\mathbb{2} \times A$ is processed by the distribute operator \ensuremath{\dist},
which converts it into a value of type $(\onet \times A) + (\onet \times A)$. In the left branch, which corresponds to
the case when the boolean is \textsf{true}, the combinator~\ensuremath{c_1} is applied to the value of
type~\ensuremath{A}. The right branch which corresponds to the boolean being \textsf{false} passes the value of type $A$
through the combinator \ensuremath{c_2}.  The inverse of \ensuremath{\dist}, namely \ensuremath{\factor} is applied to
get the final result. Using this conditional operator, \verb|cx| is defined as $\Afun{cif}~\verb|x|~\idc$ and
\verb|ccx| is defined as $\Afun{cif}~\verb|cx|~\idc$. With these conventions, the first circuit in the introduction
is transcribed as follows:

\medskip

\adder{}

\noindent where we clearly see the sequences of the three operations \verb|ccx|, \verb|cx|, and \verb|cx| but, instead
of using the indices in the sequence of wires to identify the relevant parameters, here we use structural isomorphisms
(elided above) to re-shuffle the types. For the second circuit, instead of transcribing it directly, we express it using
a slightly more abstract notation:

\medskip

\resettwo{}

\noindent Like the original circuit, we examine the bit at index 1 (corresponding to the component $B$ in a tuple
$(A,(B,C))$): if the bit is true, we perform an \verb|x| operation on component $A$, and otherwise we perform a
\verb|cx| operation on $(C,A)$. The two uses of \verb|x| gates in the circuit are now unnecessary as they were only needed
to encode a two-way conditional expression using a sequence of one-way conditional expressions (the only ones available in
the linear circuit model).

All of this is only half the story however as the correspondence between the syntactic commutative rig (the syntax of $\PiLang$)
and permutations on finite sets includes \emph{coherence conditions} that identify different syntactic representations
of the same permutation~\cite{laplaza72,Carette2016}. These coherence conditions are collected in a second level of $\PiLang$
syntax as level-2 combinators whose types are of the form $c_1 \isotwo c_2$ for appropriate $c_1$ and $c_2$ of the same
level-1 type $A \isoone B$. For example, we have:

\medskip

\combtwo{}

\noindent where the first level-2 combinator states the obvious fact that compositions with the identity can be
optimized and the second level-2 combinator states the more interesting observation that swapping the two sides of a sum
type and then applying $c_1$ to the left and $c_2$ to the right is equivalent to applying $c_2$ to the left and $c_1$ to
the right and then swapping. The full set of level-2 combinators is large and is only listed in the accompanying code.

% and that impose various coherence conditions on the level-1 combinators. In the remainder of this section, we show how
% to use a subset of these level-2 combinators to show the equivalence of \Afun{reversibleOr1} and \Afun{reversibleOr2}.

% \medskip

% \orequiv{}

% \note{This section should explain the main technical parts of the paper
%   informally, without using any technology. Use an example, such as, a
%   reversible language with $\leq 5$ bits, and examples of permutations and
%   transpositions, and when they're equal.}

%%%%%%%%%
\subsection{Denotational Semantics}

\noindent The accompanying code includes an operational semantics for $\Pi$. A denotational semantics can be specified
by mapping each type to a finite set and each combinator to a permutation between finite sets. In this section, we
outline a simple denotational semantics expressed in the metalanguage of sets and functions that collapses the level-2
combinators. This semantics will be extended in the next two sections to the HoTT metalanguage to properly model the
level-2 combinators.

The denotation of types is straightforward:

\begin{center}
  {\scalebox{\scalef}{$%
        \begin{array}{rcl}
          \denot{\zerot}     & = & \bot                       \\
          \denot{\onet}      & = & \top                       \\
          \denot{A + B}      & = & \denot{A} \sqcup \denot{B} \\
          \denot{A \times B} & = & \denot{A} \times \denot{B}
        \end{array}$}}
\end{center}

\noindent where $\bot$ is the empty set, $\top$ is a singleton set, $\sqcup$ is the disjoint union of sets, and $\times$
is the cartesian product of sets. The denotation of a combinator $c : A \isoone B$ is a (bijective) function mapping
$\denot{A}$ to $\denot{B}$:

\begin{multicols}{2}
  %%  \begin{longtable}{>{$}r<{$} >{$}l<{$} >{$}c<{$} >{$}l<{$}}
  {\scalebox{\scalef}{$%
        \begin{array}[t]{rlcl}
          \denot{\identlp} & (\inl{v})         & = & v               \\
          \denot{\identrp} & v                 & = & \inl{v}         \\
          \denot{\swapp}   & (\inl{v})         & = & \inr{v}         \\
          \denot{\swapp}   & (\inr{v})         & = & \inl{v}         \\
          \denot{\assoclp} & (\inl{v})         & = & \inl{(\inl{v})} \\
          \denot{\assoclp} & (\inr{(\inl{v})}) & = & \inl{(\inr{v})} \\
          \denot{\assoclp} & (\inr{(\inr{v})}) & = & \inr{v}         \\
          \denot{\assocrp} & (\inl{(\inl{v})}) & = & \inl{v}         \\
          \denot{\assocrp} & (\inl{(\inr{v})}) & = & \inr{(\inl{v})} \\
          \denot{\assocrp} & (\inr{v})         & = & \inr{(\inr{v})}
        \end{array}$}}

  {\scalebox{\scalef}{$%
        \begin{array}[t]{rlcl}
          \denot{\identlt} & (\ttt , v)          & = & v                   \\
          \denot{\identrt} & v                   & = & (\ttt , v)          \\
          \denot{\swapt}   & (v_1 , v_2)         & = & (v_2 , v_1)         \\
          \denot{\assoclt} & (v_1 , (v_2 , v_3)) & = & ((v_1 , v_2) , v_3) \\
          \denot{\assocrt} & ((v_1 , v_2) , v_3) & = & (v_1 , (v_2 , v_3)) \\
          \denot{\dist}    & (\inl{v_1} , v_3)   & = & \inl{(v_1 , v_3)}   \\
          \denot{\dist}    & (\inr{v_2 , v_3})   & = & \inr{(v_2 , v_3)}   \\
          \denot{\factor}  & (\inl{(v_1 , v_3)}) & = & (\inl{v_1} , v_3)   \\
          \denot{\factor}  & (\inr{(v_2 , v_3)}) & = & (\inr{v_2} , v_3)
        \end{array}$}}

  %%\end{longtable}
\end{multicols}

\begin{center}
  {\scalebox{\scalef}{$%
        \begin{array}{rlcl}
          \denot{\idc}               & v           & = & v                                   \\
          \denot{(c_1 \fatsemi c_2)} & v           & = & (\denot{c_2} \circ \denot{c_1}) v   \\
          \denot{(c_1 \oplus c_2)}   & (\inl{v})   & = & \inl{(\denot{c_1}~v)}               \\
          \denot{(c_1 \oplus c_2)}   & (\inr{v})   & = & \inr{(\denot{c_2}~v)}               \\
          \denot{(c_1 \otimes c_2)}  & (v_1 , v_2) & = & (\denot{c_1} v_1 , \denot{c_2} v_2)
        \end{array}
      $}}
\end{center}

% \begingroup
% \allowdisplaybreaks
% \begin{align*}
% \end{align*}
% \endgroup

% \begin{center}
% \begin{tikzpicture}[scale=0.7,every node/.style={scale=0.8}]
%   \draw[>=latex,<->,double,red,thick] (2.25,-1.2) -- (2.25,-2.9) ;
%   \draw[fill] (-2,-1.5) circle [radius=0.025];
%   \node[below] at (-2.1,-1.5) {$A$};
%   \node[below] at (-2.1,-1.9) {$+$};
%   \draw[fill] (-2,-2.5) circle [radius=0.025];
%   \node[below] at (-2.1,-2.5) {$B$};

%   \draw[fill] (6.5,-1.5) circle [radius=0.025];
%   \node[below] at (6.7,-1.5) {$C$};
%   \node[below] at (6.7,-1.9) {$+$};
%   \draw[fill] (6.5,-2.5) circle [radius=0.025];
%   \node[below] at (6.7,-2.5) {$D$};

%   \draw[<-] (-2,-1.5) to[bend left] (1,0.5) ;
%   \draw[<-] (-2,-2.5) to[bend left] (1,-0.5) ;
%   \draw[->] (3.5,0.5) to[bend left] (6.5,-1.45) ;
%   \draw[->] (3.5,-0.5) to[bend left] (6.5,-2.45) ;

%   \draw[<-] (-2,-1.5) to[bend right] (1,-3.5) ;
%   \draw[<-] (-2,-2.5) to[bend right] (1,-4.5) ;
%   \draw[->] (3.5,-3.5) to[bend right] (6.5,-1.55) ;
%   \draw[->] (3.5,-4.5) to[bend right] (6.5,-2.55) ;


%   \draw     (2,0.5)  -- (2.5,0.5)  ;
%   \draw     (2,-0.5) -- (2.5,-0.5) ;

%   \draw     (2.5,0.5)  -- (3.5,-0.5)  ;
%   \draw     (2.5,-0.5) -- (3.5,0.5) ;

%   \draw     (1,-3.5)  -- (2,-4.5)    ;
%   \draw     (1,-4.5) -- (2,-3.5)   ;

%   \draw     (2,-3.5)  -- (2.5,-3.5)    ;
%   \draw     (2,-4.5) -- (2.5,-4.5)   ;

%   \path (1.5,0.5) node (tc1) [func] {$c_1$};
%   \path (1.5,-0.5) node (tc2) [func] {$c_2$};
%   \path (3,-4.5) node (bc1) [func] {$c_1$};
%   \path (3,-3.5) node (bc2) [func] {$c_2$};
% \end{tikzpicture}
% \end{center}
% The top path is the $\Pi$ program $(c_1~\oplus~c_2)~\odot~\swapp$ which acts on the type $A$ by $c_1$, acts on the type
% $B$ by $c_2$, and acts on the resulting value by a twist that exchanges the two injections into the sum type. The bottom
% path performs the twist first and then acts on the type $A$ by $c_1$ and on the type $B$ by $c_2$ as before. One could
% imagine the paths are physical \emph{elastic} wires in $3$ space, where the programs $c_1$ and $c_2$ as arbitrary
% deformations on these wires, and the twists do not touch but are in fact well-separated. Then, holding the points $A$,
% $B$, $C$, and $D$ fixed, it is possible to imagine sliding $c_1$ and $c_2$ from the top wire rightward past the twist,
% and then using the elasticity of the wires, pull the twist back to line up with that of the bottom --- thus making both
% parts of the diagram identical.  Each of these moves can be undone (reversed), and doing so would take the bottom part
% of the diagram into the top part.  In other words, there exists an equivalence of the program
% $(c_1~\oplus~c_2)~\odot~\swapp$ to the program $\swapp \odot (c_2~\oplus~c_1)$. We can also show that this means that,
% as permutations, $(c_1~\oplus~c_2)~\odot~\swapp$ and $\swapp \odot (c_2~\oplus~c_1)$ are equal. And, of course, not all
% programs between the same types can be deformed into one another. The simplest example of inequivalent deformations are
% the two automorphisms of $1+1$, namely $\idc$ and $\swapp$.

% The denotational semantics can be used to evaluate programs and to check equivalence of programs. For example, it is
% straightforward to verify that $\denot{(c_1~\oplus~c_2)~\fatsemi~\swapp} = \denot{\swapp \fatsemi (c_2~\oplus~c_1)}$. A
% slightly more involved example are the following two programs:

% \rotate{}

% \noindent The first program performs the following sequence of transformations:
% \[
%   \Tree [ {\small a} [ {\small b} {\small c} ] ] ~\to~
%   \Tree [ [ {\small a} {\small b} ] {\small c} ] ~\to~
%   \Tree [ {\small c} [ {\small a} {\small b} ] ] ~\to~
%   \Tree [ {\small c} [ {\small b} {\small a} ] ] ~.
% \]
% \noindent
% while the second evaluates as follows:
% \[
%   \Tree [ {\small a} [ {\small b} {\small c} ] ] ~\to~
%   \Tree [ {\small a} [ {\small c} {\small b} ] ] ~\to~
%   \Tree [ [ {\small a} {\small c} ] {\small b} ] ~\to~
%   \Tree [ [ {\small c} {\small a} ] {\small b} ] ~\to~
%   \Tree [ {\small c} [ {\small a} {\small b} ] ] ~\to~
%   \Tree [ {\small c} [ {\small b} {\small a} ] ] ~.
% \]

% The semantics above can be packaged in the category of finite sets and functions, $\SetFin$, which is the category
% freely generated by finite coproduct completion of the terminal category. Objects of $\SetFin$ can be identified with
% sets of fixed cardinality, that is, $\Fin[n] \defeq \Set{0,1,\ldots,n-1}$. $\SetFin$ has finite coproducts and products,
% which lets us interpret the types of $\PiLang$. Combinators are interpreted as morphisms in $\SetFin$, but we have to
% restrict to invertible morphisms, that is, isomorphisms. This gives the \emph{groupoid} of finite sets and bijections,
% $\BFin \defeq \mathsf{core}(\SetFin)$. The isomorphisms satisfied by coproducts and products in $\SetFin$ lift to
% $\BFin$, but they're no longer categorical coproducts and products. They give two symmetric monoidal tensor products on
% $\BFin$, the additive and multiplicative ones, with the multiplicative tensor distributing over the additive tensor.

% \note{change thm:
%   1. Each function is a bijection. 2. If there is a 2-combinator, the denotations of the 1-combinators are equal
% }

\begin{theorem}\label{thm:semone}
  The denotational semantics is sound in the following sense:
  \begin{itemize}
    \item For every level-1 combinator $c : A \isoone B$, we have that $\denot{c}$ is a bijection between $\denot{A}$ and $\denot{B}$.
    \item For every pair of combinators $c_1$ and $c_2$ of the same type $A \isoone B$, if there exists a level-2
          combinator $\alpha$ such that $\alpha : c_1 \isotwo c_2$, then $\denot{c_1} = \denot{c_2}$ using
          extensional equivalence of functions.
  \end{itemize}
\end{theorem}
\begin{proof}
  For every primitive combinator $c$ listed on one side of Fig.~\ref{fig:pi-terms}, let $!c$ be the combinator listed on
  the other side. Thus $! \assoclp$ is $\assocrp$ and $! \swapp$ is $\swapp$ itself. Then we have that $\denot{c}$ and
  $\denot{!c}$ form an equivalence. For the level-2 combinator \Afun{idr◎l}, we check
  $\denot{\AgdaBound{c}~\AgdaOperator{\AgdaInductiveConstructor{◎}}~\AgdaInductiveConstructor{id⟷₁}}
    = \mathit{id} \circ \denot{c} = \denot{c}$. The other cases are only slightly more involved calculations.
\end{proof}


%   Let $\sim$ be the following equivalence relation on combinators $c_1 \sim c_2$ iff $\denot{c_1} = \denot{c_2}$
%   identifying combinators with the same denotation.  The notation $[c]_{\sim}$ refers to a representative combinator
%   from a $\sim$-equivalence class. Using this relation, we define the
%   category $\mathcal{C}$ as follows:
%   \begin{itemize}
%     \item $\mathit{Obj}(\mathcal{C})$ is the set of $\Pi$-types, and
%     \item $\mathit{Hom}(A,B) = [c : A \isot B]_{\sim}$
%   \end{itemize}
%   The category $\mathcal{C}$ is a groupoid.
% \end{theorem}
% \begin{proof}
%   The relation $\sim$ identifies $c$, $\idc \circ c$, and $c \circ \idc$, and is associative. Furthermore, the denotation
%   of each combinator is a reversible function thus making every morphism into an isomorphism.
% \end{proof}

% \note{Then say that $\mathcal{C}$ is ``the same'' as $\BFin$ We can say here that the relation $\sim$ also identifies
%   $(c_1~\oplus~c_2)~\fatsemi~\swapp$ and $\swapp \fatsemi (c_2~\oplus~c_1)$ and other properties. ?? }

% \[\begin{array}{l}
%     \Tree[ {\small a} [ {\small b} {\small c} ] ] \\
%     2 \quad 1 \quad 0 \\
%     0 \quad 2 \quad 1 \\
%     \Tree[ [ {\small b}  {\small c} ] {\small a} ]
% \end{array}\]

% Such functions are finitely supported, that is, their outputs can be tabulated using the canonical ordering on
% $\Fin[n]$. For bijections, this gives a listed permutation. By observing the action of the combinators on the values of
% the finite set, we can define a denotational semantics which constructs the bijection.
% \note{\(\Fin[n] \to A \eqv <\type{Vec_{n}}(A)\)}

% In the previous section, we examined equivalences between conventional data structures, i.e., structured trees of
% values. We now consider a richer but foundational notion of data: programs themselves. Indeed, universal computation
% models crucially rely on the fact that \emph{programs are (or can be encoded as) data}, e.g., a Turing machine can be
% encoded as a string that another Turing machine (or even the same machine) can manipulate. Similarly, first-class
% functions are the \emph{only} values in the $\lambda$-calculus.  In our setting, we ask whether the programs developed
% in the previous section can themselves be subject to (higher-level) equivalences?

Using categorical language, the denotational semantics for $\PiLang$ is using the category of finite sets and functions
$\SetFin$. However, we only use the bijective functions for the semantics, which means, we use the groupoid $\BFin =
  \term{core}(\SetFin)$ of finite sets and bijections. $\SetFin$ has finite coproducts $(\emptyt, \sqcup)$ and finite
products $(\unit, \times)$, which we use to interpret our types. In $\BFin$, the coproducts and products restrict to
additive and multiplicative symmetric monoidal structures, respectively, making $\BFin$ a symmetric rig groupoid.

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "main"
%%% fill-column: 120
%%% End:
