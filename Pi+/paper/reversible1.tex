\section{A Reversible Programming Language: Set-Theoretic Semantics}
\label{sec:reversibleone}
\label{sec:reversibletwo}
\label{langeqeq}

The practice of programming languages is replete with \emph{ad hoc} instances of reversible computations: database
transactions, mechanisms for data provenance, checkpoints, stack and exception traces, logs, backups, rollback
recoveries, version control systems, reverse engineering, software transactional memories, continuations, backtracking
search, and multiple-level undo features in commercial applications. In the early nineties,
\citet{Baker:1992:LLL,Baker:1992:NFT} argued for a systematic, first-class, treatment of reversibility. But intensive
research in full-fledged reversible models of computations and reversible programming languages was only sparked by the
discovery of deep connections between physics and
computation~\cite{Landauer:1961,PhysRevA.32.3266,Toffoli:1980,bennett1985fundamental,Frank:1999:REC:930275, Hey:1999:FCE:304763,fredkin1982conservative}, and by the
potential for efficient quantum computation~\cite{springerlink:10.1007/BF02650179}.

The early developments of reversible programming languages started
with a conventional programming language, e.g., an extended
$\lambda$-calculus, and either:
\begin{enumerate}
\item extended the language with a history
mechanism~\cite{vanTonder:2004,Kluge:1999:SEMCD,lorenz,danos2004reversible}, or
\item imposed constraints on the control flow constructs to make them
reversible~\cite{Yokoyama:2007:RPL:1244381.1244404}.
\end{enumerate}
More foundational approaches recognize that reversible programming languages require a fresh approach and should be
designed from first principles without the detour via conventional irreversible
languages~\cite{Yokoyama:2008:PRP,Mu:2004:ILRC,abramsky2005structural,DiPierro:2006:RCL:1166042.1166047,
  rc2011,James:2012:IE:2103656.2103667,Carette2016}.

%%%%%%%%%%%%%%%%%
\subsection{The $\Pi$ Family of Languages}

A natural candidate for a semantic foundation for reversible programming languages is the notion of type
isomorphism. Indeed, the type isomorphisms among finite types are sound and complete for all permutations on finite
types~\cite{Fiore:2004,fiore-remarks} and hence they are \emph{complete} for expressing reversible combinational
circuits~\cite{fredkin1982conservative, James:2012:IE:2103656.2103667,Toffoli:1980} and the extension with recursive
types and trace operators~\cite{Hasegawa:1997:RCS:645893.671607} is a Turing-complete reversible
language~\cite{James:2012:IE:2103656.2103667,rc2011}.

Focusing on finite types, the building blocks of type theory are: the empty type ($\zerot$), the unit type
($\onet$) containing just one value $\Acon{tt}$, the sum type ($+$) containing values of the form $\inlv{v}$ and
$\inrv{v}$, and the product ($\times$) type containing pairs of values $(v_1,v_2)$. For this fragment of types, the
syntax of the language $\Pi$ consists of the following sorts:

{\scalebox{\scalef}{$%
\begin{array}{lrcl}
\textit{Value types} & A,B,C,D &::=& \zerot \alt \onet \alt A+B \alt A\times B \\
\textit{Values}      & v,w,x,y &::=& \Acon{tt} \alt \inlv{v} \alt \inrv{v} \alt (v,w) \\
\textit{Program types} &&& A \iso B \\
\textit{Programs} & c &::=& (\textrm{See Fig.~\ref{pi-terms}})
\end{array}$}}
\begin{figure}[t]
{\scalebox{\scalef}{$%
%%\noindent\begin{minipage}{.7\linewidth}
\begin{array}{rrcll}
\idc :& A & \iso & A &: \idc \\
\\
\identlp :&  \zerot + A & \iso & A &: \identrp \\
\swapp :&  A + B & \iso & B + A &: \swapp \\
\assoclp :&  A + (B + C) & \iso & (A + B) + C &: \assocrp \\ [1.5ex]
\identlt :&  \onet \times A & \iso & A &: \identrt \\
\swapt :&  A \times B & \iso & B \times A &: \swapt \\
\assoclt :&  A \times (B \times C) & \iso & (A \times B) \times C &: \assocrt \\ [1.5ex]
\absorbr :&~ \zerot \times A & \iso & \zerot ~ &: \factorzl \\
\dist :&~ (A + B) \times C & \iso & (A \times C) + (B \times C)~ &: \factor
  \end{array}$}}

{\scalebox{\scalef}{%
\Rule{}
{\jdg{}{}{c_1 : A \iso B} \quad \vdash c_2 : B \iso C}
{\jdg{}{}{c_1 \fatsemi c_2 : A \iso C}}
{}

\Rule{}
{\jdg{}{}{c_1 : A \iso B} \quad \vdash c_2 : C \iso D}
{\jdg{}{}{c_1 \oplus c_2 : A + C \iso B + D}}
{}

\Rule{}
{\jdg{}{}{c_1 : A \iso B} \quad \vdash c_2 : C \iso D}
{\jdg{}{}{c_1 \otimes c_2 : A \times C \iso B \times D}}
{}
}}
\caption{$\Pi$-terms, combinators, and their types.}
\label{pi-terms}
\end{figure}

\noindent Intuitively, one may view each type $A$ as a collection of physical wires that can transmit $\sizet{A}$
distinct values where $\sizet{A}$ is a natural number that indicates the size of a type, computed as:
$\sizet{\zerot} = 0$; $\sizet{\onet} = 1$; $\sizet{A + B} = \sizet{A} + \sizet{B}$; and
$\sizet{A \times B} = \sizet{A} * \sizet{B}$.  Thus the type $\mathbb{2} = \onet + \onet$ corresponds to a wire that can
transmit one of two values, i.e., bits. The type $\mathbb{2} \times (\mathbb{2} \times \mathbb{2})$ (abbreviated
$\mathbb{B}~3$) corresponds to a collection of wires that can transmit three bits. From that perspective, a type
isomorphism between types $A$ and $B$ (such that $\sizet{A}=\sizet{B}=n$) models a \emph{reversible} combinational
circuit that \emph{permutes} the $n$ different values. These type isomorphisms form a \emph{commutative semiring} and
are collected in Fig.~\ref{pi-terms}. Each line in the top part of the figure introduces a pair of dual constants that
witness the type isomorphism in the middle.  These are the \emph{base} (non-reducible) terms of $\Pi$. The isomorphisms
are extended to form a congruence relation by adding the three constructors at the bottom of the figure that witness
equivalence and compatible closure. Although austere, this combinator-based language has the advantage of being amenable
to formal analysis for at least two reasons: (i) it is conceptually simple and small, and (ii) it has direct and evident
connections to type theory and category theory and hence possesses a rich algebraic structure which we exploit in the
remainder of the paper.

%%%%%%%%%
\subsection{Informal Semantics and Examples}
\label{sec:langRev-examples}
\label{examples}

%% \note{Revisit to pick examples relevant to the rest of the paper; also unify notation}

In order to understand the examples of Sec.~\ref{sec:informal}, we review how to represent collections of booleans and
conditionals in $\Pi$. We use the type $\onet + \onet$ to represent booleans with $\inlv{\Acon{tt}}$ representing
\textsf{false} and $\inrv{\Acon{tt}}$ representing $\textsf{true}$. Boolean negation is straightforward to define using
the primitive combinator $\swapp$. We can represent $n$-bit words using an n-ary product of boolean values.
For example, we can express a 3-bit word reversal operation as follows:

$\Afun{reverse} : \mathbb{B}~3 \iso \mathbb{B}~3$

$\Afun{reverse} = \swapt \fatsemi (\swapt  \otimes  \idc)~ \fatsemi \assocrt$

\noindent The manual trace of $\Afun{reverse}$ below confirms that it indeed reverses the three bits:
\[\begin{array}{rlr}
 & (v_1, (v_2, v_3)) \\
 \swapt & ((v_2, v_3), v_1) \\
 \swapt \otimes  \idc & ((v_3, v_2), v_1) \\
 \assocrt & (v_3, (v_2, v_1)) \\
 \end{array}\]
%subcode source isomorphisms.tex:979

Even though \ensuremath{\Pi } lacks conditional expressions, they are expressible using the distributivity and factoring
laws as shown below:

$\Afun{ifc}_{c_1,c_2} : \mathbb{2} \times A \iso \mathbb{2} \times B$

$\Afun{ifc}_{c_1,c_2} = \dist \fatsemi ((\idc  \otimes\  c_1) \oplus (\idc \otimes\  c_2)) \fatsemi \factor$


% \inkscape{if-c1-c2.pdf}


\noindent The input value of type $\mathbb{2} \times A$ is processed by the distribute operator \ensuremath{\dist},
which converts it into a value of type $(\onet \times A) + (\onet \times A)$. In the \ensuremath{\mathit{left}} branch,
which corresponds to the case when the boolean is \ensuremath{\mathit{false}}, the combinator~\ensuremath{c_1} is
applied to the value of type~\ensuremath{A}. The right branch which corresponds to the boolean being
\ensuremath{\mathit{true}} passes the value of type $A$ through the combinator \ensuremath{c_2}.  The inverse of
\ensuremath{\dist}, namely \ensuremath{\factor} is applied to get the final result. The full expressiveness of $\Pi$ is
demonstrated by an implementation of $\Afun{cnot}$ and $\Afun{toffoli}$ which are universal for reversible
computation~\cite{Toffoli:1980}. The $\Afun{cnot}$ gates takes two input bits: a control bit and a target bit, and
negates the target bit if the control bit is set. It is essentially a one-branch version of $\Afun{cif}$ above. The
Toffoli gate generalizes the idea to a gate that takes 3 input bits: 2 control bits and one target bit: boolean inputs:
it negates the target bit if both control bits are set.

%%%%%%%%%
\subsection{Denotational Semantics}

\noindent The accompanying code includes an operational semantics for $\Pi$. A denotational semantics can be
specified by mapping each type to a finite set and each combinator to a bijection between finite sets, that is, a
permutation. In this section, we outline a simple semantics expressed in the metalanguage of sets and functions. This
semantics will be extended to the metalanguage of homotopy type theory in the remainder of the paper.

The denotation of types is straightforward:
\[\begin{array}{rcl}
\denot{\zerot} &=& \emptyset \\
\denot{\onet} &=& \{ \Acon{tt} \} \\
\denot{A + B} &=& \denot{A} \uplus \denot{B} \\
\denot{A \times B} &=& \denot{A} \times \denot{B}
\end{array}\]
where $\emptyset$ is the empty set, $\uplus$ is the disjoint union of sets, and $\times$ is the cartesian product of
sets. The denotation of a combinator $c : A \isot B$ is a (bijective) function mapping $\denot{A}$ to $\denot{B}$:
\[\begin{array}{rcl}
\denot{\identlp} (\inlv{v}) &=& v \\
\denot{\identrp} v &=& \inlv{v} \\
\denot{\swapp} (\inlv{v}) &=& \inrv{v} \\
\denot{\swapp} (\inrv{v}) &=& \inlv{v} \\
\denot{\assoclp} (\inlv{v})  &=& \inlv{(\inlv{v})} \\
\denot{\assoclp} (\inrv{(\inlv{v})}) &=& \inlv{(\inrv{v})} \\
\denot{\assoclp} (\inrv{(\inrv{v})}) &=& \inrv{v} \\
\denot{\assocrp} (\inlv{(\inlv{v})}) &=& \inlv{v} \\
\denot{\assocrp} (\inlv{(\inrv{v})}) &=& \inrv{(\inlv{v})} \\
\denot{\assocrp} (\inrv{v})  &=& \inrv{(\inrv{v})} \\
\denot{\identlp} (\Acon{tt} , v)  &=& v \\
\denot{\identrp} v &=& (\Acon{tt} , v) \\
\denot{\swapt}  (v_1 , v_2) &=& (v_2 , v_1) \\
\denot{\assoclt} (v_1 , (v_2 , v_3)) &=& ((v_1 , v_2) , v_3) \\
\denot{\assocrt} ((v_1 , v_2) , v_3) &=& (v_1 , (v_2 , v_3)) \\
\denot{\dist} (\inlv{v_1} , v_3)  &=& \inlv{(v_1 , v_3)} \\
\denot{\dist} (\inrv{v_2 , v_3})  &=& \inrv{(v_2 , v_3)} \\
\denot{\factor}  (\inlv{(v_1 , v_3)}) &=& (\inlv{v_1} , v_3) \\
\denot{\factor}  (\inrv{(v_2 , v_3)}) &=& (\inrv{v_2} , v_3) \\
\denot{\idc} v &=& v \\
\denot{(c_1 \fatsemi c_2)} v &=& (\denot{c_2} \circ \denot{c_1}) v \\
\denot{(c_1 \oplus c_2)} (\inlv{v}) &=& \inlv{(\denot{c_1}~v)} \\
\denot{(c_1 \oplus c_2)} (\inrv{v}) &=& \inrv{(\denot{c_2}~v)} \\
\denot{(c_1 \otimes c_2)} (v_1 , v_2) &=& (\denot{c_1} v_1 , \denot{c_2} v_2)
  \end{array}\]

% \begin{center}
% \begin{tikzpicture}[scale=0.7,every node/.style={scale=0.8}]
%   \draw[>=latex,<->,double,red,thick] (2.25,-1.2) -- (2.25,-2.9) ;
%   \draw[fill] (-2,-1.5) circle [radius=0.025];
%   \node[below] at (-2.1,-1.5) {$A$};
%   \node[below] at (-2.1,-1.9) {$+$};
%   \draw[fill] (-2,-2.5) circle [radius=0.025];
%   \node[below] at (-2.1,-2.5) {$B$};

%   \draw[fill] (6.5,-1.5) circle [radius=0.025];
%   \node[below] at (6.7,-1.5) {$C$};
%   \node[below] at (6.7,-1.9) {$+$};
%   \draw[fill] (6.5,-2.5) circle [radius=0.025];
%   \node[below] at (6.7,-2.5) {$D$};

%   \draw[<-] (-2,-1.5) to[bend left] (1,0.5) ;
%   \draw[<-] (-2,-2.5) to[bend left] (1,-0.5) ;
%   \draw[->] (3.5,0.5) to[bend left] (6.5,-1.45) ;
%   \draw[->] (3.5,-0.5) to[bend left] (6.5,-2.45) ;

%   \draw[<-] (-2,-1.5) to[bend right] (1,-3.5) ;
%   \draw[<-] (-2,-2.5) to[bend right] (1,-4.5) ;
%   \draw[->] (3.5,-3.5) to[bend right] (6.5,-1.55) ;
%   \draw[->] (3.5,-4.5) to[bend right] (6.5,-2.55) ;


%   \draw     (2,0.5)  -- (2.5,0.5)  ;
%   \draw     (2,-0.5) -- (2.5,-0.5) ;

%   \draw     (2.5,0.5)  -- (3.5,-0.5)  ;
%   \draw     (2.5,-0.5) -- (3.5,0.5) ;

%   \draw     (1,-3.5)  -- (2,-4.5)    ;
%   \draw     (1,-4.5) -- (2,-3.5)   ;

%   \draw     (2,-3.5)  -- (2.5,-3.5)    ;
%   \draw     (2,-4.5) -- (2.5,-4.5)   ;

%   \path (1.5,0.5) node (tc1) [func] {$c_1$};
%   \path (1.5,-0.5) node (tc2) [func] {$c_2$};
%   \path (3,-4.5) node (bc1) [func] {$c_1$};
%   \path (3,-3.5) node (bc2) [func] {$c_2$};
% \end{tikzpicture}
% \end{center}
% The top path is the $\Pi$ program $(c_1~\oplus~c_2)~\odot~\swapp$ which acts on the type $A$ by $c_1$, acts on the type
% $B$ by $c_2$, and acts on the resulting value by a twist that exchanges the two injections into the sum type. The bottom
% path performs the twist first and then acts on the type $A$ by $c_1$ and on the type $B$ by $c_2$ as before. One could
% imagine the paths are physical \emph{elastic} wires in $3$ space, where the programs $c_1$ and $c_2$ as arbitrary
% deformations on these wires, and the twists do not touch but are in fact well-separated. Then, holding the points $A$,
% $B$, $C$, and $D$ fixed, it is possible to imagine sliding $c_1$ and $c_2$ from the top wire rightward past the twist,
% and then using the elasticity of the wires, pull the twist back to line up with that of the bottom --- thus making both
% parts of the diagram identical.  Each of these moves can be undone (reversed), and doing so would take the bottom part
% of the diagram into the top part.  In other words, there exists an equivalence of the program
% $(c_1~\oplus~c_2)~\odot~\swapp$ to the program $\swapp \odot (c_2~\oplus~c_1)$. We can also show that this means that,
% as permutations, $(c_1~\oplus~c_2)~\odot~\swapp$ and $\swapp \odot (c_2~\oplus~c_1)$ are equal. And, of course, not all
% programs between the same types can be deformed into one another. The simplest example of inequivalent deformations are
% the two automorphisms of $1+1$, namely $\idc$ and $\swapp$.

The denotational semantics can be used to evaluate programs and to check equivalence of programs. For example, it is
straightforward to verify that $\denot{(c_1~\oplus~c_2)~\fatsemi~\swapp} = \denot{\swapp \fatsemi (c_2~\oplus~c_1)}$. A
slightly more involved example are the following two programs:

\rotate{}

\noindent The first program performs the following sequence of transformations:
\[
\Tree [ {\small a} [ {\small b} {\small c} ] ] ~\to~
\Tree [ [ {\small a} {\small b} ] {\small c} ] ~\to~
\Tree [ {\small c} [ {\small a} {\small b} ] ] ~\to~
\Tree [ {\small c} [ {\small b} {\small a} ] ] ~.
\]
\noindent
while the second evaluates as follows:
\[
\Tree [ {\small a} [ {\small b} {\small c} ] ] ~\to~
\Tree [ {\small a} [ {\small c} {\small b} ] ] ~\to~
\Tree [ [ {\small a} {\small c} ] {\small b} ] ~\to~
\Tree [ [ {\small c} {\small a} ] {\small b} ] ~\to~
\Tree [ {\small c} [ {\small a} {\small b} ] ] ~\to~
\Tree [ {\small c} [ {\small b} {\small a} ] ] ~.
\]

The semantics above can be packaged in the category of finite sets and functions, $\SetFin$, which is the category
freely generated by finite coproduct completion of the terminal category. Objects of $\SetFin$ can be identified with
sets of fixed cardinality, that is, $\Fin[n] \defeq \Set{0,1,\ldots,n-1}$. $\SetFin$ has finite coproducts and products,
which lets us interpret the types of $\PiLang$. Combinators are intepreted as morphisms in $\SetFin$, but we have to
restrict to invertible morphisms, that is, isomorphisms. This gives the \emph{groupoid} of finite sets and bijections,
$\BFin \defeq \mathsf{core}(\SetFin)$. The isomorphisms satisfied by coproducts and products in $\SetFin$ lift to
$\BFin$, but they're no longer categorical coproducts and products. They give two symmetric monoidal tensor products on
$\BFin$, the additive and multiplicative ones, with the multiplicative tensor distributing over the additive tensor.

\begin{theorem}\label{thm:grp}
  Let $\sim$ be the following equivalence relation on combinators $c_1 \sim c_2$ iff $\denot{c_1} = \denot{c_2}$
  identifying combinators with the same denotation.  The notation $[c]_{\sim}$ refers to a representative combinator
  from a $\sim$-equivalence class. Using this relation, we define the
  category $\mathcal{C}$ as follows:
  \begin{itemize}
    \item $\mathit{Obj}(\mathcal{C})$ is the set of $\Pi$-types, and
    \item $\mathit{Hom}(A,B) = [c : A \isot B]_{\sim}$
    \end{itemize}
  The category $\mathcal{C}$ is a groupoid.
\end{theorem}
\begin{proof}
The relation $\sim$ identifies $c$, $\idc \circ c$, and $c \circ \idc$, and is associative. Furthermore, the denotation
of each combinator is a reversible function thus making every morphism into an isomorphism.
\end{proof}

\note{Then say that $\mathcal{C}$ is ``the same'' as $\BFin$ We can say here that the relation $\sim$ also identifies
 $(c_1~\oplus~c_2)~\fatsemi~\swapp$ and $\swapp \fatsemi (c_2~\oplus~c_1)$ and other properties. ?? }

% \[\begin{array}{l}
%     \Tree[ {\small a} [ {\small b} {\small c} ] ] \\
%     2 \quad 1 \quad 0 \\
%     0 \quad 2 \quad 1 \\
%     \Tree[ [ {\small b}  {\small c} ] {\small a} ]
% \end{array}\]

% Such functions are finitely supported, that is, their outputs can be tabulated using the canonical ordering on
% $\Fin[n]$. For bijections, this gives a listed permutation. By observing the action of the combinators on the values of
% the finite set, we can define a denotational semantics which constructs the bijection.
% \note{\(\Fin[n] \to A \eqv <\type{Vec_{n}}(A)\)}

% In the previous section, we examined equivalences between conventional data structures, i.e., structured trees of
% values. We now consider a richer but foundational notion of data: programs themselves. Indeed, universal computation
% models crucially rely on the fact that \emph{programs are (or can be encoded as) data}, e.g., a Turing machine can be
% encoded as a string that another Turing machine (or even the same machine) can manipulate. Similarly, first-class
% functions are the \emph{only} values in the $\lambda$-calculus.  In our setting, we ask whether the programs developed
% in the previous section can themselves be subject to (higher-level) equivalences?

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "main"
%%% fill-column: 120
%%% End:
