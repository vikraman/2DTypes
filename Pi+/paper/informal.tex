\section{Informal Examples}

% \todo{Not the right title.}

% \note{This section should explain the main technical parts of the paper
%   informally, without using any technology. Use an example, such as, a
%   reversible language with $\leq 5$ bits, and examples of permutations and
%   transpositions, and when they're equal.}

% Shor's quantum factoring algorithm requires, at its core, a classical reversible function for modular exponentiation. As
% explained in standard accounts of the algorithm (e.g., the Qiskit implementation), such efficient modular exponentiation
% circuits are not straightforward and are the bottleneck in Shorâ€™s algorithm. Typical derivations of the circuit start
% from elementary gates, build a circuit for modular addition, which is used to build a circuit for modular
% multiplication, and then finally a circuit for modular exponentiation taking care at each step to avoid the exponential
% blowup~\cite{shorefficient}. Ultimately however the circuit has a simple specification as a \emph{permutation}. For
% example, consider the function $f(r) = 11^{r} \mod 15$. Using the Toffoli construction~\cite{Toffoli:1980}, we can embed
% this function $f$ into a reversible function $g$, shown below, such that $g(r,0) = (r,f(r))$:
% \[\begin{array}{rcll}
% g(r,h) &=& (r,h+1) & \mbox{when~$r$~even~and~$h$~even} \\
% g(r,h) &=& (r,h-1) & \mbox{when~$r$~even~and~$h$~odd} \\
% g(r,h) &=& (r,11-h) & \mbox{when~$r$~odd~and~$4 > h \geq 0$~or~$12 > h \geq 8$} \\
% g(r,h) &=& (r,19-h) & \mbox{when~$r$~odd~and~$8 > h \geq 4$~or~$16 > h \geq 12$}
% \end{array}\]
% Wouldn't it be simpler to write this permutation and automatically derive a circuit from it?

% \note{Can we do this for the supplementary material??}

\paragraph*{Normalization by evaluation.} Consider the following reversible function:
$\Afun{RESET}(b,b_1,\ldots,b_n) = (b \; \underline{\vee} \; (\bigvee_{i=1}^n b_i),b_1,\ldots,b_n)$ where $\vee$ is
logical-or and $\underline{\vee}$ is exclusive-or. The function sets or resets the first bit depending on whether any of
the other bits is true or not. The natural definition for this function is recursive: modulo some re-shuffling of the
bits, the strategy is to examine the bits $b_i$ one-by-one: if we encounter a true value, we negate the first bit and
terminate; otherwise we continue making recursive calls until we reach the last bit at which point we return the
incoming value with no change:

%%\begin{minipage}{.65\textwidth}
%%  \PiRESET{}
%%\end{minipage}
%%\begin{minipage}{.30\textwidth}
%%  \begin{center}
%%  \resizebox{0.5\textwidth}{!}{\input{diagrams/reset.tikz}}
%%  \end{center}
%%\end{minipage}

\resettwo{}

\noindent The syntax will be explained in detail in the next section and the full definitions of the helpers are provided in the
supplementary material. For now, it is sufficient to know that there is some program that implements the reversible
function of interest. Our Agda infrastructure provides tools to normalize all programs to their normal form. For
\Afun{reset 2} we get:

\resetnormtwo{}

In principle, the normalized program can be produced following two strategies: (i) by repeatedly applying the rewrite
rules of our calculus of reversible functions (explained in Sec.~\ref{sec:reversibletwo}), or (ii) in the case above by
using a normalization-by-evaluation (NBE) process that evaluates the program to a permutation on a finite set of 8
elements and reifies that permutation back to a program. The key idea of the NBE process is a systematic way to express
permutations as sequences of adjacent swaps as illustrated in the following small example where the permutation on the
left is compiled to the sequence of four adjacent transpositions on the right:

% \note{Motivation: There are two reversible circuits which describe the following permutation. They can be shown to be
%   equal using the 2-combinators.}

% \[
%   \begin{tikzpicture}
%     \begin{knot}[clip width=5]
%       \filldraw (0,5) circle (2pt) node[above] {0};
%       \filldraw (1,5) circle (2pt) node[above] {1};
%       \filldraw (2,5) circle (2pt) node[above] {2};
%       \filldraw (3,5) circle (2pt) node[above] {3};
%       \filldraw (4,5) circle (2pt) node[above] {4};
%       \filldraw (0,0) circle (2pt) node[below] {1};
%       \filldraw (1,0) circle (2pt) node[below] {4};
%       \filldraw (2,0) circle (2pt) node[below] {0};
%       \filldraw (3,0) circle (2pt) node[below] {3};
%       \filldraw (4,0) circle (2pt) node[below] {2};
%       \strand (0,5) .. controls (0.5,0.5) and (1.5,3.5) .. (2,0);
%       \strand (1,5) .. controls (0.75,0.5) and (0.25,3.5) .. (0,0);
%       \strand (2,5) .. controls (2.5,2.5) and (3.5,1.5) .. (4,0);
%       \strand (3,5) .. controls (4.5,2.5) and (4,1.5) .. (3,0);
%       \strand (4,5) .. controls (3.5,2.5) and (1.5,2.5) .. (1,0);
%       \flipcrossings{4,5};
%     \end{knot}
%   \end{tikzpicture}
% \]

% Example: We reduce $\mathsf{swap} : 2 + 2 \leftrightarrow 2 + 2$ to a sequence of adjacent swaps. This is an example of
% a translation from $\PiPlusLang$ to $\PiHatLang$.

\begin{align*}
  \begin{tikzpicture}[scale=0.4,every node/.style={scale=0.4}]
    \begin{knot}[clip width=3]
      \filldraw (0,4) circle (2pt) node[above] {0};
      \filldraw (1,4) circle (2pt) node[above] {1};
      \filldraw (2,4) circle (2pt) node[above] {2};
      \filldraw (3,4) circle (2pt) node[above] {3};
      \filldraw (0,0) circle (2pt) node[below] {2};
      \filldraw (1,0) circle (2pt) node[below] {3};
      \filldraw (2,0) circle (2pt) node[below] {0};
      \filldraw (3,0) circle (2pt) node[below] {1};
      \strand (0,4) .. controls (0.5,1.5) and (1.5,2.5) .. (2,0);
      \strand (1,4) .. controls (1.5,1.5) and (2.5,2.5) .. (3,0);
      \strand (2,4) .. controls (1.5,1.5) and (1.5,2.5) .. (0,0);
      \strand (3,4) .. controls (2.5,1.5) and (2.5,2.5) .. (1,0);
    \end{knot}
  \end{tikzpicture}
\quad=\quad
  \begin{tikzpicture}[scale=0.4,every node/.style={scale=0.4}]
    \begin{knot}[clip width=3]
      \filldraw (0,4) circle (2pt) node[above] {0};
      \filldraw (1,4) circle (2pt) node[above] {1};
      \filldraw (2,4) circle (2pt) node[above] {2};
      \filldraw (3,4) circle (2pt) node[above] {3};
      \filldraw (0,0) circle (2pt) node[below] {0};
      \filldraw (1,0) circle (2pt) node[below] {2};
      \filldraw (2,0) circle (2pt) node[below] {1};
      \filldraw (3,0) circle (2pt) node[below] {3};
      \strand (0,4) to (0,0);
      \strand (1,4) .. controls (0.5,2) and (2.5,2) .. (2,0);
      \strand (2,4) .. controls (2.5,2) and (0.5,2) .. (1,0);
      \strand (3,4) to (3,0);
    \end{knot}
  \end{tikzpicture}
  &&
    \begin{tikzpicture}[scale=0.4,every node/.style={scale=0.4}]
      \begin{knot}[clip width=3]
        \filldraw (0,4) circle (2pt) node[above] {0};
        \filldraw (1,4) circle (2pt) node[above] {2};
        \filldraw (2,4) circle (2pt) node[above] {1};
        \filldraw (3,4) circle (2pt) node[above] {3};
        \filldraw (0,0) circle (2pt) node[below] {2};
        \filldraw (1,0) circle (2pt) node[below] {0};
        \filldraw (2,0) circle (2pt) node[below] {1};
        \filldraw (3,0) circle (2pt) node[below] {3};
        \strand (0,4) .. controls (-0.5,2) and (1.5,2) .. (1,0);
        \strand (1,4) .. controls (1.5,2) and (-0.5,2) .. (0,0);
        \strand (2,4) to (2,0);
        \strand (3,4) to (3,0);
      \end{knot}
    \end{tikzpicture}
  &&
  \begin{tikzpicture}[scale=0.4,every node/.style={scale=0.4}]
    \begin{knot}[clip width=3]
      \filldraw (0,4) circle (2pt) node[above] {2};
      \filldraw (1,4) circle (2pt) node[above] {0};
      \filldraw (2,4) circle (2pt) node[above] {1};
      \filldraw (3,4) circle (2pt) node[above] {3};
      \filldraw (0,0) circle (2pt) node[below] {2};
      \filldraw (1,0) circle (2pt) node[below] {0};
      \filldraw (2,0) circle (2pt) node[below] {3};
      \filldraw (3,0) circle (2pt) node[below] {1};
      \strand (0,4) to (0,0);
      \strand (1,4) to (1,0);
      \strand (2,4) .. controls (1.5,2) and (3.5,2) .. (3,0);
      \strand (3,4) .. controls (3.5,2) and (1.5,2) .. (2,0);
    \end{knot}
  \end{tikzpicture}
  &&
    \begin{tikzpicture}[scale=0.4,every node/.style={scale=0.4}]
      \begin{knot}[clip width=3]
        \filldraw (0,4) circle (2pt) node[above] {2};
        \filldraw (1,4) circle (2pt) node[above] {0};
        \filldraw (2,4) circle (2pt) node[above] {3};
        \filldraw (3,4) circle (2pt) node[above] {1};
        \filldraw (0,0) circle (2pt) node[below] {2};
        \filldraw (1,0) circle (2pt) node[below] {3};
        \filldraw (2,0) circle (2pt) node[below] {0};
        \filldraw (3,0) circle (2pt) node[below] {1};
        \strand (0,4) to (0,0);
        \strand (1,4) .. controls (0.5,2) and (2.5,2) .. (2,0);
        \strand (2,4) .. controls (2.5,2) and (0.5,2) .. (1,0);
        \strand (3,4) to (3,0);
      \end{knot}
    \end{tikzpicture}
\end{align*}

\paragraph*{Program synthesis.} The NBE process embodies a quoting mechanism that synthesizes programs from
permutations. Indeed, instead of writing a program for \Afun{reset 2}, one might simply specify the desired permutation as:

\resetperm{}

\noindent The permutation uses the canonical encoding of sequences of bits as natural numbers (e.g., (\textsf{false},
\textsf{true},\textsf{true}) is encoded as 011 or 3).  Simply ``quoting'' this permutation generates the same normalized
program \Afun{reset2Norm} above.

\paragraph*{Program equivalence.} The permutation above reveals another way to think about the desired program: it is a
special addition circuit that keeps 0 and 4 fixed but otherwise adds 4 modulo 8 to its input. From this specification,
one can use a standard synthesis algorithm for reversible circuits~\cite{10.1145/775832.775915} to generate the
following program:

\adder{}

\noindent The \Afun{adder3} program looks nothing like the original \Afun{reset 2} program and yet they both have the
same normal form thus establishing their equivalence.

% Now imagine we want to write the following reversible function:

% 0 -> 0
% 8 -> 8
% n -> n + 8 `mod` 16

% \note{This might be followed by a section which explains the syntax of Pi.}

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "main"
%%% fill-column: 120
%%% End:
