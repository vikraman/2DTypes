\section{The Underlying Ideas}

\todo{Not the right title.}

\note{This section should explain the main technical parts of the paper
  informally, without using any technology. Use an example, such as, a
  reversible language with $\leq 5$ bits, and examples of permutations and
  transpositions, and when they're equal.}

% Shor's quantum factoring algorithm requires, at its core, a classical reversible function for modular exponentiation. As
% explained in standard accounts of the algorithm (e.g., the Qiskit implementation), such efficient modular exponentiation
% circuits are not straightforward and are the bottleneck in Shor’s algorithm. Typical derivations of the circuit start
% from elementary gates, build a circuit for modular addition, which is used to build a circuit for modular
% multiplication, and then finally a circuit for modular exponentiation taking care at each step to avoid the exponential
% blowup~\cite{shorefficient}. Ultimately however the circuit has a simple specification as a \emph{permutation}. For
% example, consider the function $f(r) = 11^{r} \mod 15$. Using the Toffoli construction~\cite{Toffoli:1980}, we can embed
% this function $f$ into a reversible function $g$, shown below, such that $g(r,0) = (r,f(r))$:
% \[\begin{array}{rcll}
% g(r,h) &=& (r,h+1) & \mbox{when~$r$~even~and~$h$~even} \\
% g(r,h) &=& (r,h-1) & \mbox{when~$r$~even~and~$h$~odd} \\
% g(r,h) &=& (r,11-h) & \mbox{when~$r$~odd~and~$4 > h \geq 0$~or~$12 > h \geq 8$} \\
% g(r,h) &=& (r,19-h) & \mbox{when~$r$~odd~and~$8 > h \geq 4$~or~$16 > h \geq 12$}
% \end{array}\]
% Wouldn't it be simpler to write this permutation and automatically derive a circuit from it?

% \note{Can we do this for the supplementary material??}

\paragraph*{Normalization by evaluation of reversible circuits.} Consider the following reversible function:
$\Afun{RESET}(b,b_1,\ldots,b_n) = (b \; \underline{\vee} \; (\bigvee_{i=1}^n b_i),b_1,\ldots,b_n)$ where $\vee$ is
logical-or and $\underline{\vee}$ is exclusive-or. The function sets or resets the first bit depending on whether any of
the other bits is true or not. The natural definition for this function is recursive: modulo some re-shuffling of the
bits, the strategy is to examine the bits $b_i$ one-by-one: if we encounter a true value, we negate the first bit and
terminate; otherwise we continue making recursive calls until we reach the last bit at which point we return the
incoming value with no change. A modular implementation using 4 helpers is provided in the supplementary
material. Unrolling the definition of $\Afun{reset}~2$ and inlining all the helpers produces the following program:

%%\begin{minipage}{.65\textwidth}
%%  \PiRESET{}
%%\end{minipage}
%%\begin{minipage}{.30\textwidth}
%%  \begin{center}
%%  \resizebox{0.5\textwidth}{!}{\input{diagrams/reset.tikz}}
%%  \end{center}
%%\end{minipage}

  \resettwo{}

The syntax will be explained in detail in the next section. For now, it is sufficient to know that there is some program
that implements the reversible function of interest. Our Agda infrastructure provides tools to normalize all programs to
their normal form. For \Afun{reset2} we get:

  \resetnormtwo{}





Now imagine we want to write the following reversible function:

0 -> 0
8 -> 8
n -> n + 8 `mod` 16

% (assocl⋆ ◎ (swap⋆ ⊗ id⟷₁) ◎ assocr⋆) ◎
% (dist ◎
%  ((id⟷₁ ⊗ (swap₊ ⊗ id⟷₁)) ⊕
%   (id⟷₁ ⊗
%    (swap⋆ ◎ (dist ◎ ((id⟷₁ ⊗ swap₊) ⊕ id⟷₁) ◎ factor) ◎ swap⋆)))
%  ◎ factor)
% ◎ assocl⋆ ◎ (swap⋆ ⊗ id⟷₁) ◎ assocr⋆

% reset+ 2:

% (id⟷₁ ⊕ id⟷₁ ⊕ id⟷₁ ⊕ id⟷₁ ⊕ assocl₊ ◎ (swap₊ ⊕ id⟷₁) ◎ assocr₊) ◎
% (id⟷₁ ⊕ id⟷₁ ⊕ id⟷₁ ⊕ id⟷₁ ⊕ id⟷₁ ⊕ assocl₊ ◎ (swap₊ ⊕ id⟷₁) ◎ assocr₊) ◎
% (id⟷₁ ⊕ id⟷₁ ⊕ id⟷₁ ⊕ id⟷₁ ⊕ assocl₊ ◎ (swap₊ ⊕ id⟷₁) ◎ assocr₊) ◎
% id⟷₁

% reset 3 =

% (assocl⋆ ◎ (swap⋆ ⊗ id⟷₁) ◎ assocr⋆) ◎
% (dist ◎
%  ((id⟷₁ ⊗ (swap₊ ⊗ id⟷₁)) ⊕
%   (id⟷₁ ⊗
%    ((assocl⋆ ◎ (swap⋆ ⊗ id⟷₁) ◎ assocr⋆) ◎
%     (dist ◎
%      ((id⟷₁ ⊗ (swap₊ ⊗ id⟷₁)) ⊕
%       (id⟷₁ ⊗
%        (swap⋆ ◎ (dist ◎ ((id⟷₁ ⊗ swap₊) ⊕ id⟷₁) ◎ factor) ◎ swap⋆)))
%      ◎ factor)
%     ◎ assocl⋆ ◎ (swap⋆ ⊗ id⟷₁) ◎ assocr⋆)))
%  ◎ factor)
% ◎ assocl⋆ ◎ (swap⋆ ⊗ id⟷₁) ◎ assocr⋆

% reset+ 3

% (id⟷₁ ⊕ id⟷₁ ⊕ id⟷₁ ⊕ id⟷₁ ⊕ id⟷₁ ⊕ id⟷₁ ⊕ id⟷₁ ⊕ id⟷₁ ⊕ id⟷₁ ⊕ id⟷₁ ⊕ id⟷₁ ⊕ id⟷₁ ⊕ assocl₊ ◎ (swap₊ ⊕ id⟷₁) ◎ assocr₊) ◎
% (id⟷₁ ⊕ id⟷₁ ⊕ id⟷₁ ⊕ id⟷₁ ⊕ id⟷₁ ⊕ id⟷₁ ⊕ id⟷₁ ⊕ id⟷₁ ⊕ id⟷₁ ⊕ id⟷₁ ⊕ id⟷₁ ⊕ id⟷₁ ⊕ id⟷₁ ⊕ assocl₊ ◎ (swap₊ ⊕ id⟷₁) ◎ assocr₊) ◎
% (id⟷₁ ⊕ id⟷₁ ⊕ id⟷₁ ⊕ id⟷₁ ⊕ id⟷₁ ⊕ id⟷₁ ⊕ id⟷₁ ⊕ id⟷₁ ⊕ id⟷₁ ⊕ id⟷₁ ⊕ id⟷₁ ⊕ id⟷₁ ⊕ assocl₊ ◎ (swap₊ ⊕ id⟷₁) ◎ assocr₊)◎
% id⟷₁


\note{Motivation: There are two reversible circuits which describe the following permutation. They can be shown to be
  equal using the 2-combinators.}

\[
  \begin{tikzpicture}
    \begin{knot}[clip width=5]
      \filldraw (0,5) circle (2pt) node[above] {0};
      \filldraw (1,5) circle (2pt) node[above] {1};
      \filldraw (2,5) circle (2pt) node[above] {2};
      \filldraw (3,5) circle (2pt) node[above] {3};
      \filldraw (4,5) circle (2pt) node[above] {4};
      \filldraw (0,0) circle (2pt) node[below] {1};
      \filldraw (1,0) circle (2pt) node[below] {4};
      \filldraw (2,0) circle (2pt) node[below] {0};
      \filldraw (3,0) circle (2pt) node[below] {3};
      \filldraw (4,0) circle (2pt) node[below] {2};
      \strand (0,5) .. controls (0.5,0.5) and (1.5,3.5) .. (2,0);
      \strand (1,5) .. controls (0.75,0.5) and (0.25,3.5) .. (0,0);
      \strand (2,5) .. controls (2.5,2.5) and (3.5,1.5) .. (4,0);
      \strand (3,5) .. controls (4.5,2.5) and (4,1.5) .. (3,0);
      \strand (4,5) .. controls (3.5,2.5) and (1.5,2.5) .. (1,0);
      \flipcrossings{4,5};
    \end{knot}
  \end{tikzpicture}
\]

\note{Example: We reduce $\mathsf{swap} : 2 + 2 \leftrightarrow 2 + 2$ to a sequence of adjacent swaps. This is an
  example of a translation from $\PiPlusLang$ to $\PiHatLang$.}

\[
  \begin{tikzpicture}
    \begin{knot}[clip width=4]
      \filldraw (0,4) circle (2pt) node[above] {0};
      \filldraw (1,4) circle (2pt) node[above] {1};
      \filldraw (2,4) circle (2pt) node[above] {2};
      \filldraw (3,4) circle (2pt) node[above] {3};
      \filldraw (0,0) circle (2pt) node[below] {2};
      \filldraw (1,0) circle (2pt) node[below] {3};
      \filldraw (2,0) circle (2pt) node[below] {0};
      \filldraw (3,0) circle (2pt) node[below] {1};
      \strand (0,4) .. controls (0.5,1.5) and (1.5,2.5) .. (2,0);
      \strand (1,4) .. controls (1.5,1.5) and (2.5,2.5) .. (3,0);
      \strand (2,4) .. controls (1.5,1.5) and (1.5,2.5) .. (0,0);
      \strand (3,4) .. controls (2.5,1.5) and (2.5,2.5) .. (1,0);
    \end{knot}
  \end{tikzpicture}
\]

\begin{align*}
  \begin{tikzpicture}
    \begin{knot}[clip width=4]
      \filldraw (0,4) circle (2pt) node[above] {0};
      \filldraw (1,4) circle (2pt) node[above] {1};
      \filldraw (2,4) circle (2pt) node[above] {2};
      \filldraw (3,4) circle (2pt) node[above] {3};
      \filldraw (0,0) circle (2pt) node[below] {0};
      \filldraw (1,0) circle (2pt) node[below] {2};
      \filldraw (2,0) circle (2pt) node[below] {1};
      \filldraw (3,0) circle (2pt) node[below] {3};
      \strand (0,4) to (0,0);
      \strand (1,4) .. controls (0.5,2) and (2.5,2) .. (2,0);
      \strand (2,4) .. controls (2.5,2) and (0.5,2) .. (1,0);
      \strand (3,4) to (3,0);
    \end{knot}
  \end{tikzpicture}
  &&
    \begin{tikzpicture}
      \begin{knot}[clip width=4]
        \filldraw (0,4) circle (2pt) node[above] {0};
        \filldraw (1,4) circle (2pt) node[above] {2};
        \filldraw (2,4) circle (2pt) node[above] {1};
        \filldraw (3,4) circle (2pt) node[above] {3};
        \filldraw (0,0) circle (2pt) node[below] {2};
        \filldraw (1,0) circle (2pt) node[below] {0};
        \filldraw (2,0) circle (2pt) node[below] {1};
        \filldraw (3,0) circle (2pt) node[below] {3};
        \strand (0,4) .. controls (-0.5,2) and (1.5,2) .. (1,0);
        \strand (1,4) .. controls (1.5,2) and (-0.5,2) .. (0,0);
        \strand (2,4) to (2,0);
        \strand (3,4) to (3,0);
      \end{knot}
    \end{tikzpicture}
  \\
  \begin{tikzpicture}
    \begin{knot}[clip width=4]
      \filldraw (0,4) circle (2pt) node[above] {2};
      \filldraw (1,4) circle (2pt) node[above] {0};
      \filldraw (2,4) circle (2pt) node[above] {1};
      \filldraw (3,4) circle (2pt) node[above] {3};
      \filldraw (0,0) circle (2pt) node[below] {2};
      \filldraw (1,0) circle (2pt) node[below] {0};
      \filldraw (2,0) circle (2pt) node[below] {3};
      \filldraw (3,0) circle (2pt) node[below] {1};
      \strand (0,4) to (0,0);
      \strand (1,4) to (1,0);
      \strand (2,4) .. controls (1.5,2) and (3.5,2) .. (3,0);
      \strand (3,4) .. controls (3.5,2) and (1.5,2) .. (2,0);
    \end{knot}
  \end{tikzpicture}
  &&
    \begin{tikzpicture}
      \begin{knot}[clip width=4]
        \filldraw (0,4) circle (2pt) node[above] {2};
        \filldraw (1,4) circle (2pt) node[above] {0};
        \filldraw (2,4) circle (2pt) node[above] {3};
        \filldraw (3,4) circle (2pt) node[above] {1};
        \filldraw (0,0) circle (2pt) node[below] {2};
        \filldraw (1,0) circle (2pt) node[below] {3};
        \filldraw (2,0) circle (2pt) node[below] {0};
        \filldraw (3,0) circle (2pt) node[below] {1};
        \strand (0,4) to (0,0);
        \strand (1,4) .. controls (0.5,2) and (2.5,2) .. (2,0);
        \strand (2,4) .. controls (2.5,2) and (0.5,2) .. (1,0);
        \strand (3,4) to (3,0);
      \end{knot}
    \end{tikzpicture}
\end{align*}

\note{This might be followed by a section which explains the syntax of Pi.}

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "main"
%%% fill-column: 120
%%% End:
