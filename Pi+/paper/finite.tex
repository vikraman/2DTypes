\section{The groupoid of finite types}~\label{sec:finite}

In this section, we describe \review{the algebraic structure} of the groupoid of
finite types, and give \review{a computable presentation} for it.

\vc{The groupoid of finite types is the free symmetric monoidal groupoid on one
  generator. This can be presented as an algebraic 2-theory, which is our syntax
  for $\PiHatLang$. Vertical categorification of natural numbers as a free
  commutative monoid. See groupoidification.}

\todo{Check Brent Yorgey's thesis?}

To do so, we will characterise the automorphisms on finite sets of cardinality
$n$, and show them to be equivalent to the symmetric group $\Sn$, via the
Coxeter presentation. We will do that in two steps,
in~\cref*{subsec:permutations,subsec:lehmer,subsec:symmetric}.

%% Coxeter presentation of $\Sn$ $\eqv$ $\Lehmer[n]$ $\eqv$ $\Aut[\Fin[n]]$

\subsection{Permutations}~\label{subsec:permutations}

In the previous~\cref{sec:univalent}, we established that paths in $\UFin$ are
equivalent to families of automorphisms of $\Fin{n}$ for every $n:\Nat$, that
is, bijections on finite sets of size $n$. This is the extensional view of
permutations. In the following sections, we will characterise these
permutations, going through two intermediate steps.

\vc{This is obvious, maybe add something more here.}

\subsection{Lehmer codes}~\label{subsec:lehmer}

From grade school combinatorics, we know that there are $\fac{n}$ permutations
on a finite set with $n$ elements. The factorial function is defined by
recursion on natural numbers. However, now, for every $n$, we want to produce a
type, which is a finite set, with cardinality $\fac{n}$. And, to characterise
$\Aut[\Fin[n]]$, we further need to construct a bijection between this type and
$\Aut[\Fin[n]]$.

First, let's define this type with $\fac{n}$ elements, we name this type family
$\Lehmer : \Nat \to \UU$, which is defined by recursion on $\Nat$ as follows.
This is the obvious definition of factorials by recursion, but categorified from
natural numbers to sets.

\begin{definition}
  \begin{align*}
    \Lehmer[0]       & \defeq \unit                           \\
    \Lehmer[\suc[n]] & \defeq \Fin[\suc[n]] \times \Lehmer[n]
  \end{align*}
\end{definition}

\todo{Subexcedant sequences and factorial definitions are equivalent, explain
  this!}

The name Lehmer comes from Lehmer
codes~\cite{lehmerTeachingCombinatorialTricks1960} which are known in
Combinatorial Analysis~\cite{bellmanCombinatorialAnalysis1960}. There are many
ways to represent permutations, e.g. inversions, or cycles, or matrices. Lehmer
codes are a particularly convenient way to represent permutations on a
computer,~\review{they are compact and have exactly the right cardinality.
  $\Lehmer[n]$ is a $n+1$-element tuple, where the position $k \leq n$ has an
  element of $\Fin[k]$. The 0-th position is trivial, so we ignore it, and in
  both the example below and the Agda proof, consider only the remaining
  $n$-element tuple.}

\vc{This is just the classical algorithm to explain the example, not the actual
  type-theoretic proof.}

Suppose we have a permutation $p$ on an $n$-element set
$\{\el{0}, \el{1}, \el{2}, \el{3}, \el{4}\}$, we encode it as follows.
$\Lehmer[n]$ is a $n$-element tuple. At position $k$, we put the number of
inversions of the element $\el{k}$ in $p$, i.e. the number of elements smaller
than $\el{k}$ occurring after $\el{k}$.

As an example, consider the following tabulated presentation of the permutation:

\todo{fix this figure}

\[
  p =
  \begin{array}{ccccccccccccccc}
    | & 0      & | & 1      & | & 2      & | & 3      & | & 4      & | \\
    \hline                                                             \\
    | & \el{2} & | & \el{0} & | & \el{1} & | & \el{4} & | & \el{3} & | \\
    \hline                                                             \\
  \end{array}
\]

%  0 1 2 3 4
% -----------
% |2|0|1|4|3|
% -----------

The element $\el{0}$ has 0 inversions, because there are no elements smaller
than $\el{0}$ occurring after it. In fact, there can be no elements smaller than
$\el{0}$ at all, so the type at the first position of the Lehmer code tuple is
$\unit$.

The element $\el{1}$ has 0 inversions as well, since elements occurring after it
in the permutation are $\el{4}$ and $\el{2}$. There is only one different case,
if $\el{1}$ appeared before $\el{0}$, it would have 1 inversion. This is why the
type of the second component of the Lehmer code is $\Fin[2]$.

The element $\el{2}$ has 2 inversions, because both $\el{0}$ and $\el{1}$ occur
after it in the permutation. The element $\el{3}$ occurs as the last one, so it
has 0 inversions. The element $\el{4}$ has 1 inversion, with the element
$\el{3}$.

Thus, the Lehmer code for the permutation $p$ is the 5-tuple
$l = (0, 0, 2, 0, 1)$.

To reconstruct the tabulated presentation of the permutation from the Lehmer
code, we perform an algorithm similar to \emph{insertion sort}. Starting from
the left-most position of the tuple $l$, we'll read the value $v$, insert the
new element at the end of the newly created list, and shift it backward $v$
places.

\begin{center}
  \begin{tabular}{c|p{0.75\linewidth}}
    (0, 0, 2, 0, 1)               & We start from an empty list $[]$                                                                 \\
    (\highlight{{0}}, 0, 2, 0, 1) & We read 0 as the left-most value from $l$. Thus, we append the element $\el{0}$ to our
                                    list, getting $[\el{0}]$. The element is shifted $0$ places, so it remains in the
                                    same place.                                                                                                                      \\
    (0, \highlight{{0}}, 2, 0, 1) & Then, similarly, we read another 0 for the element $\el{1}$, append it to the
                                    list getting $[\el{0}, \el{1}]$, and don't shift it either.                                                                      \\
    (0, 0, \highlight{{2}}, 0, 1) & We read 2 for the next the element $\el{2}$ - we append $\el{2}$ to our list, getting
                                    $[\el{0}, \el{1}, \el{2}]$, and shift it 2 places right, which results in a list $[\el{0}, \el{2}, \el{1}]$
                                    \todo{Typeset it nicely, with arrows showing the shifting}.                                                                      \\
    (0, 0, 2, \highlight{{0}}, 1) & Then we read 0 - appending $\el{3}$ and not shifting, getting $[\el{0}, \el{2}, \el{1}, \el{3}]$ \\
    (0, 0, 2, 0, \highlight{{1}}) & Finally, reading 1 for element $\el{4}$ - appending $\el{4}$ to the list and shifting it
                                    one place right results in the final list $[\el{0}, \el{2}, \el{1}, \el{4}, \el{3}]$                                             \\
  \end{tabular}
\end{center}
\todo{figure}

Using this Lehmer encoding algorithm, we can now construct the equivalence between these types.

We define a type family $\FinExcept{n} : \Fin[n] \to \UU$ which picks out all elements in $\Fin[n]$ except the one
provided. Note that $\FinExcept{n}[i]$ for $i : \Fin[n]$ is a subtype of $\Fin[n]$ and is hence an $\hSet$.

\begin{definition}
  \( \FinExcept{n}[i] \defeq \dsum{j : \Fin[n]}{i \neq j} \).
\end{definition}

\begin{proposition}
  For any $k : \Fin[n]$, $\unit \sqcup \FinExcept{n}[k] \eqv \Fin[n]$.
\end{proposition}

\begin{proposition}
  For any $k : \Fin[\suc[n]]$, $\FinExcept{\suc[n]}[k] \eqv \Fin[n]$.
\end{proposition}

\begin{proposition}
  For any $n : \Nat$,
  \( \Aut[\Fin[\suc[n]]] \eqv \dsum{k : \Fin[\suc[n]]}{\FinExcept{\suc[n]}[\fzero] \eqv \FinExcept{\suc[n]}{k}} \).
\end{proposition}

\begin{proposition}
  For all $n:\Nat$, \( \Lehmer[n] \eqv \Aut[\Fin[n]] \).
\end{proposition}

\begin{proof}
  For $n = 0$, note that $\Lehmer[0]$ is contractible, and so is $\Aut[\Fin[0]]$. For $n = \suc[m]$, we have the
  following chain of equivalences.
  \[\arraycolsep=0.5em\def\arraystretch{1.5}
    \begin{array}{rl}
      & \Aut[\Fin[\suc[m]]] \\
      \eqv & \dsum{k : \Fin[\suc[m]]}{\FinExcept{\suc[m]}[\fzero] \eqv \FinExcept{\suc[m]}[k]} \\
      \eqv & \dsum{k : \Fin[\suc[m]]}{\FinExcept{\suc[m]}[\fzero] \eqv \Fin[m]} \\
      \eqv & \dsum{k : \Fin[\suc[m]]}{\Fin[m] \eqv \Fin[m]} \\
      \eqv & \Fin[\suc[m]] \times \Aut[\Fin[m]] \\
      \eqv & \Fin[\suc[m]] \times \Lehmer[m] \\
    \end{array}
  \]
\end{proof}

\subsection{Symmetric groups}~\label{subsec:symmetric}

There is an obvious group structure on $\Aut[\Fin[n]]$ given by identity,
composition, and inverse. This is the symmetric group $S_n$ on $n$ symbols. In
the rest of the section we will construct a convenient presentation of this
group.

\vc{this is just a rough draft for now}

\todo{Reference T-algebra presentations as coequalisers (Mac Lane 6.7)}

First, we formally define a presentation of a group.

\todo{Free 1-group, needs to be truncated}

\begin{definition}
  Let $A$ be a type, and $\List[A]$ the free monoid on $A$. The free group $F(A)$ on $A$ is the set-quotient of
  $\List[A + A]$ by the congruence closure of the relation $(\inl(a) \cons \inr(a) \cons \nil) \sim \nil$.
\end{definition}

\begin{proposition}
  Let $\eta_{A} : A \to F(A)$ be given by $a \mapsto \inl(a) \cons \nil$. Given any group $G$ with a map $f : A \to G$,
  there is a canonical lifting of $f$ to a group homomorphism $\extend{f} : F(A) \to G$, such that
  $\extend{f} \comp \eta_{A} \htpy f$, that is, the type of group homomorphisms $h : \Grp(F(A),G)$ satisfying
  $h \comp \eta_{A} \htpy f$ is contractible. Equivalently, composition by $\eta_{A}$ is an equivalence
  $\Grp(F(A),G) \eqv (A \to G)$.
\end{proposition}

\todo{diagram}
\todo{Plus/Minus}

\begin{definition}
  Let $A$ be a type and $R : A \to A \to \UU$ a binary relation on $A$. The group $G$ presented by
  $\langle A ; R \rangle$ is given by the set-quotient of the free group $F(A)$ by the normal closure $N_{R}$ of $R$, or
  equivalently, as the coequaliser
  \[\begin{tikzcd}
      FR && FA && G
      \arrow[shift right=2, from=1-1, to=1-3]
      \arrow[shift left=2, from=1-1, to=1-3]
      \arrow[two heads, from=1-3, to=1-5]
    \end{tikzcd}\]
\end{definition}

\todo{Universal property}
\todo{Examples: empty relation, van Kampen of $\pi_{1}$}

\subsubsection{Coxeter Relations}

We define a binary relation on $\List[\Fin[n]]$.

\begin{definition}[$\cox$]
  \begin{align*}
    \cancel
    & : \forall n \to (n \cons n \cons \nil) \cox \nil \\
    \swap
    & : \forall k, n \to (\suc[k] < n) \to (n \cons k \cons \nil) \cox (k \cons n \cons \nil) \\
    \braid
    & : \forall n \to (\suc[n] \cons n \cons \suc[n] \cons \nil) \cox (n \cons \suc[n] \cons n \cons \nil) \\
  \end{align*}
\end{definition}

We define $\cox*$ as the congruence closure of $\cox$.
\vc{This could be simplified a bit depending on our formalisation. $\cox$ is directed, use a different symbol?}

\begin{definition}[$\cox*$]
  \begin{align*}
    \reflr{\cox}
    & : \forall w \to w \cox* w \\
    \symr{\cox}
    & : \forall w_{1}, w_{2} \to w_{1} \cox* w_{2} \to w_{2} \cox* w_{1} \\
    \transr{\cox}
    & : \forall w_{1}, w_{2}, w_{3} \to  w_{1} \cox* w_{2} \to w_{2} \cox* w_{3} \to w_{1} \cox* w_{3} \\
    \congrf{\cox}{\append}
    & : \forall w_{1}, w_{2}, w_{3}, w_{4} \to  w_{1} \cox* w_{2} \to w_{3} \cox* w_{4} \to w_{1} \append w_{3} \cox* w_{2} \append w_{4} \\
    \relr{\cox}
    & : \forall w_{1}, w_{2} \to w_{1} \cox w_{2} \to w_{1} \cox* w_{2} \\
  \end{align*}
\end{definition}

\todo{Long form of Coxeter relations and their equivalence.}

We state and prove two desirable properties of this relation on $\List[\Fin[n]]$ from the point of view of an abstract
rewriting system. We follow the terminology of~\cite{krausCoherenceWellFoundednessTaming2020}. \vc{Not completely
  formalised. Is this with Coxeter or LongCoxeter?}

\begin{proposition}
  \leavevmode
  \begin{enumerate}
    \item $\cox$ is (locally) confluent. For every span $w_{1} \cox w \cox w_{2}$, there is a matching extended cospan
          $w_{1} \cox* v \cox* w_{2}$.
    \item $\cox*$ is strongly normalising. For every $w$, there exists a unique $v$ such that $w \cox* v$.
          \review{Equivalently, the type $\dsum{v:\List[\Fin[n]]}{w \cox* v}$ is contractible, and $w \cox* v$ is a
          proposition for every $w$ and $v$.}
  \end{enumerate}
\end{proposition}

The type $\Sn$ is defined as the set-quotient of $\List[\Fin[n]]$ by $\cox*$.

\begin{definition}[$\Sn$]
  \(\Sn \defeq \quot{\List(\Fin[n])}{\cox*}\)
\end{definition}

We will now prove the group structure of $\Sn$.

\begin{proposition}
  There is a group structure on $\Sn$, where the identity element is $\nil$, multiplication is given by list append, and
  inverse is given by list reversal.
\end{proposition}

\begin{proposition}
  $\Sn$ is equivalent to the generated group given by the normal closure of $\cox*$ extended to
  $\List(\Fin[n] + \Fin[n])$ along the codiagonal map $[\term{id},\term{id}] : A + A \to A$.
\end{proposition}

We will now show how to generate a Lehmer code from a word in $\Sn$ and back.

\todo{immersion}

\begin{theorem}
  For all $n : \Nat$,
  \[
    \Sn \eqv \Lehmer[n]
  \]
\end{theorem}

\subsection{Symmetric Monoidal structure}

We describe the symmetric monoidal structure of the groupoid $\UFin$.

First, we observe a few equivalences.

\begin{proposition}
  For any $n, m : \Nat$,
  \begin{align*}
    \Fin[0]                & \eqv \bot \\
    \Fin[n] \sqcup \Fin[m] & \eqv \Fin[n + m] \\
  \end{align*}
  and for any types $X, Y, Z$,
  \begin{align*}
    \bot \sqcup X          & \eqv X \\
    X \sqcup \bot          & \eqv X \\
    (X \sqcup Y) \sqcup Z  & \eqv X \sqcup (Y \sqcup Z) \\
    X \sqcup Y             & \eqv Y \sqcup Y \\
  \end{align*}
\end{proposition}

We lift these equivalences to $\UFin$ giving it the (additive) symmetric monoidal structure $(I, \oplus)$, with natural
isomorphisms $\lambda_{X}$, $\rho_{X}$, $\alpha_{X,Y,Z}$, and the symmetry isomorphism $\mathcal{B}_{X,Y}$. Note that
types in $\UFin$ are $\hSet$s since they're merely equivalent to $\Fin[n]$ for some $n : \Nat$.

\begin{definition}
  \begin{align*}
    I           & \defeq F_{0}    \\
    X \oplus Y & \defeq X \sqcup Y \\
    \lambda_{X} & : I \oplus X \eqv X \\
    \rho_{X} & : X \oplus I \eqv X \\
    \alpha_{X,Y,Z} & : (X \oplus Y) \oplus Z \eqv X \oplus (Y \oplus Z) \\
    \mathcal{B}_{X,Y} & : X \oplus Y \eqv Y \oplus X
  \end{align*}
\end{definition}

These isomorphisms satisfy the Mac Lane coherence conditions for symmetric monoidal categories, that is, the triangle,
pentagon, and hexagon identities, and the syllepsis of the braiding, upto 2-paths in $\UFin$.

\begin{proposition}
  % https://q.uiver.app/?q=WzAsNCxbMCwwLCIoWCBcXG9wbHVzIEkpIFxcb3BsdXMgWSJdLFsyLDAsIlggXFxvcGx1cyAoSSBcXG9wbHVzIFkpIl0sWzEsMSwiWCBcXG9wbHVzIFkiXSxbMCwxXSxbMCwxLCJcXGFscGhhX3tYLEksWX0iXSxbMCwyLCJcXHJob197WH0gXFxvcGx1cyAxX3tZfSIsMl0sWzEsMiwiMV97WH0gXFxvcGx1cyBcXGxhbWJkYV97WX0iXSxbNSw2LCJcXGlkIiwwLHsic2hvcnRlbiI6eyJzb3VyY2UiOjIwLCJ0YXJnZXQiOjIwfSwic3R5bGUiOnsiYm9keSI6eyJuYW1lIjoibm9uZSJ9LCJoZWFkIjp7Im5hbWUiOiJub25lIn19fV1d
  \[\begin{tikzcd}
      {(X \oplus I) \oplus Y} && {X \oplus (I \oplus Y)} \\
      {} & {X \oplus Y}
      \arrow["{\alpha_{X,I,Y}}", from=1-1, to=1-3]
      \arrow[""{name=0, anchor=center, inner sep=0}, "{\rho_{X} \oplus 1_{Y}}"', from=1-1, to=2-2]
      \arrow[""{name=1, anchor=center, inner sep=0}, "{1_{X} \oplus \lambda_{Y}}", from=1-3, to=2-2]
      \arrow["\id", Rightarrow, draw=none, from=0, to=1]
    \end{tikzcd}\]
  % https://q.uiver.app/?q=WzAsNSxbMCwxLCIoKFcgXFxvcGx1cyBYKSBcXG9wbHVzIFkpIFxcb3BsdXMgWiJdLFsxLDAsIihXIFxcb3BsdXMgWCkgXFxvcGx1cyAoWSBcXG9wbHVzIFopIl0sWzIsMSwiVyBcXG9wbHVzIChYIFxcb3BsdXMgKFkgXFxvcGx1cyBaKSkiXSxbMiwzLCJXIFxcb3BsdXMgKChYIFxcb3BsdXMgWSkgXFxvcGx1cyBaKSJdLFswLDMsIihXIFxcb3BsdXMgKFggXFxvcGx1cyBZKSkgXFxvcGx1cyBaIl0sWzAsMSwiXFxhbHBoYV97VyBcXG9wbHVzIFgsIFksIFp9Il0sWzEsMiwiXFxhbHBoYV97VyxYLFkgXFxvcGx1cyBafSJdLFszLDIsIjFfe1d9IFxcb3BsdXMgXFxhbHBoYV97WCxZLFp9IiwyXSxbMCw0LCJcXGFscGhhX3tXLFgsWX0gXFxvcGx1cyAxX3tafSIsMl0sWzQsMywiXFxhbHBoYV97VyxYIFxcb3BsdXMgWSxafSIsMl0sWzAsMiwiXFxpZCIsMSx7Im9mZnNldCI6NSwic3R5bGUiOnsiYm9keSI6eyJuYW1lIjoibm9uZSJ9LCJoZWFkIjp7Im5hbWUiOiJub25lIn19fV1d
  \[\begin{tikzcd}
      & {(W \oplus X) \oplus (Y \oplus Z)} \\
      {((W \oplus X) \oplus Y) \oplus Z} && {W \oplus (X \oplus (Y \oplus Z))} \\
      \\
      {(W \oplus (X \oplus Y)) \oplus Z} && {W \oplus ((X \oplus Y) \oplus Z)}
      \arrow["{\alpha_{W \oplus X, Y, Z}}", from=2-1, to=1-2]
      \arrow["{\alpha_{W,X,Y \oplus Z}}", from=1-2, to=2-3]
      \arrow["{1_{W} \oplus \alpha_{X,Y,Z}}"', from=4-3, to=2-3]
      \arrow["{\alpha_{W,X,Y} \oplus 1_{Z}}"', from=2-1, to=4-1]
      \arrow["{\alpha_{W,X \oplus Y,Z}}"', from=4-1, to=4-3]
      \arrow["\id"{description}, shift right=5, draw=none, from=2-1, to=2-3]
    \end{tikzcd}\]
  % https://q.uiver.app/?q=WzAsNixbMSwwLCJYIFxcb3BsdXMgKFkgXFxvcGx1cyBaKSJdLFswLDEsIihYIFxcb3BsdXMgWSkgXFxvcGx1cyBaIl0sWzAsMiwiKFkgXFxvcGx1cyBYKSBcXG9wbHVzIFoiXSxbMSwzLCJZIFxcb3BsdXMgKFggXFxvcGx1cyBaKSJdLFsyLDIsIlkgXFxvcGx1cyAoWiBcXG9wbHVzIFgpIl0sWzIsMSwiKFkgXFxvcGx1cyBaKSBcXG9wbHVzIFgiXSxbMSwwLCJcXGFscGhhX3tYLFksWn0iXSxbMSwyLCJcXG1hdGhjYWx7Qn1fe1gsWX0gXFxvcGx1cyAxX3tafSIsMl0sWzIsMywiXFxhbHBoYV97WSxYLFp9IiwyXSxbMyw0LCIxX3tZfSBcXG9wbHVzIFxcbWF0aGNhbHtCfV97WCxafSIsMl0sWzUsNCwiXFxhbHBoYV97WSxaLFh9Il0sWzAsNSwiXFxtYXRoY2Fse0J9X3tYLFkgXFxvcGx1cyBafSJdLFs3LDEwLCJcXGlkIiwwLHsic2hvcnRlbiI6eyJzb3VyY2UiOjIwLCJ0YXJnZXQiOjIwfSwic3R5bGUiOnsiYm9keSI6eyJuYW1lIjoibm9uZSJ9LCJoZWFkIjp7Im5hbWUiOiJub25lIn19fV1d
  \[\begin{tikzcd}
      & {X \oplus (Y \oplus Z)} \\
      {(X \oplus Y) \oplus Z} && {(Y \oplus Z) \oplus X} \\
      {(Y \oplus X) \oplus Z} && {Y \oplus (Z \oplus X)} \\
      & {Y \oplus (X \oplus Z)}
      \arrow["{\alpha_{X,Y,Z}}", from=2-1, to=1-2]
      \arrow[""{name=0, anchor=center, inner sep=0}, "{\mathcal{B}_{X,Y} \oplus 1_{Z}}"', from=2-1, to=3-1]
      \arrow["{\alpha_{Y,X,Z}}"', from=3-1, to=4-2]
      \arrow["{1_{Y} \oplus \mathcal{B}_{X,Z}}"', from=4-2, to=3-3]
      \arrow[""{name=1, anchor=center, inner sep=0}, "{\alpha_{Y,Z,X}}", from=2-3, to=3-3]
      \arrow["{\mathcal{B}_{X,Y \oplus Z}}", from=1-2, to=2-3]
      \arrow["\id", Rightarrow, draw=none, from=0, to=1]
    \end{tikzcd}\]
  % https://q.uiver.app/?q=WzAsMyxbMCwwLCJYIFxcb3BsdXMgWSJdLFsyLDAsIlggXFxvcGx1cyBZIl0sWzEsMSwiWSBcXG9wbHVzIFgiXSxbMCwxLCIxX3tYIFxcb3BsdXMgWX0iLDAseyJsZXZlbCI6Miwic3R5bGUiOnsiaGVhZCI6eyJuYW1lIjoibm9uZSJ9fX1dLFswLDIsIlxcbWF0aGNhbHtCfV97WCxZfSIsMl0sWzIsMSwiXFxtYXRoY2Fse0J9X3tZLFh9IiwyXSxbNCw1LCJcXGlkIiwwLHsic2hvcnRlbiI6eyJzb3VyY2UiOjIwLCJ0YXJnZXQiOjIwfSwic3R5bGUiOnsiYm9keSI6eyJuYW1lIjoibm9uZSJ9LCJoZWFkIjp7Im5hbWUiOiJub25lIn19fV1d
  \[\begin{tikzcd}
      {X \oplus Y} && {X \oplus Y} \\
      & {Y \oplus X}
      \arrow["{1_{X \oplus Y}}", Rightarrow, no head, from=1-1, to=1-3]
      \arrow[""{name=0, anchor=center, inner sep=0}, "{\mathcal{B}_{X,Y}}"', from=1-1, to=2-2]
      \arrow[""{name=1, anchor=center, inner sep=0}, "{\mathcal{B}_{Y,X}}"', from=2-2, to=1-3]
      \arrow["\id", Rightarrow, draw=none, from=0, to=1]
    \end{tikzcd}\]
\end{proposition}

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "main"
%%% fill-column: 120
%%% End:
