\section{The groupoid of finite types}~\label{sec:finite}

In this section, we describe \review{the algebraic structure} of the groupoid of
finite types, and give \review{a computable presentation} for it.

\vc{The groupoid of finite types is the free symmetric monoidal groupoid on one
  generator. This can be presented as an algebraic 2-theory, which is our syntax
  for $\PiHatLang$. Vertical categorification of natural numbers as a free
  commutative monoid. See groupoidification.}

\todo{Check Brent Yorgey's thesis?}

To do so, we will characterise the automorphisms on finite sets of cardinality
$n$, and show them to be equivalent to the symmetric group $\Sn$, via the
Coxeter presentation. We will do that in two steps,
in~\cref*{subsec:permutations,subsec:lehmer,subsec:symmetric}.

%% Coxeter presentation of $\Sn$ $\eqv$ $\Lehmer[n]$ $\eqv$ $\Aut[\Fin[n]]$

\subsection{Permutations}~\label{subsec:permutations}

In the previous~\cref{sec:univalent}, we established that paths in $\UFin$ are
equivalent to families of automorphisms of $\Fin{n}$ for every $n:\Nat$, that
is, bijections on finite sets of size $n$. This is the extensional view of
permutations. In the following sections, we will characterise these
permutations, going through two intermediate steps.

\vc{This is obvious, maybe add something more here.}

\subsection{Lehmer codes}~\label{subsec:lehmer}

From grade school combinatorics, we know that there are $\fac{n}$ permutations
on a finite set with $n$ elements. The factorial function is defined by
recursion on natural numbers. However, now, for every $n$, we want to produce a
type, which is a finite set, with cardinality $\fac{n}$. And, to characterise
$\Aut[\Fin[n]]$, we further need to construct a bijection between this type and
$\Aut[\Fin[n]]$.

First, let's define this type with $\fac{n}$ elements, we name this type family
$\Lehmer : \Nat \to \UU$, which is defined by recursion on $\Nat$ as follows.
This is the obvious definition of factorials by recursion, but categorified from
natural numbers to sets.

\begin{definition}
  \begin{align*}
    \Lehmer[0]       & \defeq \unit                           \\
    \Lehmer[\suc[n]] & \defeq \Fin[\suc[n]] \times \Lehmer[n]
  \end{align*}
\end{definition}

\todo{Subexcedant sequences and factorial definitions are equivalent, explain
  this!}

The name Lehmer comes from Lehmer
codes~\cite{lehmerTeachingCombinatorialTricks1960a} which are known in
Combinatorial Analysis~\cite{bellmanCombinatorialAnalysis1960}. There are many
ways to represent permutations, e.g. inversions, or cycles, or matrices. Lehmer
codes are a particularly convenient way to represent permutations on a
computer,~\review{they are compact and have exactly the right cardinality.
  $\Lehmer[n]$ is a $n+1$-element tuple, where the position $k \leq n$ has an
  element of $\Fin[k]$. The 0-th position is trivial, so we ignore it, and in
  both the example below and the Agda proof, consider only the remaining
  $n$-element tuple.}

\vc{This is just the classical algorithm to explain the example, not the actual
  type-theoretic proof.}

Suppose we have a permutation $p$ on an $n$-element set
$\{\el{0}, \el{1}, \el{2}, \el{3}, \el{4}\}$, we encode it as follows.
$\Lehmer[n]$ is a $n$-element tuple. At position $k$, we put the number of
inversions of the element $\el{k}$ in $p$, i.e. the number of elements smaller
than $\el{k}$ occurring after $\el{k}$.

As an example, consider the following tabulated presentation of the permutation:

\todo{fix this figure}

\[
  p =
  \begin{array}{ccccccccccccccc}
    | & 0      & | & 1      & | & 2      & | & 3      & | & 4      & | \\
    \hline                                                             \\
    | & \el{2} & | & \el{0} & | & \el{1} & | & \el{4} & | & \el{3} & | \\
    \hline                                                             \\
  \end{array}
\]

%  0 1 2 3 4
% -----------
% |2|0|1|4|3|
% -----------

The element $\el{0}$ has 0 inversions, because there are no elements smaller
than $\el{0}$ occurring after it. In fact, there can be no elements smaller than
$\el{0}$ at all, so the type at the first position of the Lehmer code tuple is
$\unit$.

The element $\el{1}$ has 0 inversions as well, since elements occurring after it
in the permutation are $\el{4}$ and $\el{2}$. There is only one different case,
if $\el{1}$ appeared before $\el{0}$, it would have 1 inversion. This is why the
type of the second component of the Lehmer code is $\Fin[2]$.

The element $\el{2}$ has 2 inversions, because both $\el{0}$ and $\el{1}$ occur
after it in the permutation. The element $\el{3}$ occurs as the last one, so it
has 0 inversions. The element $\el{4}$ has 1 inversion, with the element
$\el{3}$.

Thus, the Lehmer code for the permutation $p$ is the 5-tuple
$l = (0, 0, 2, 0, 1)$.

To reconstruct the tabulated presentation of the permutation from the Lehmer
code, we perform an algorithm similar to \emph{insertion sort}. Starting from
the left-most position of the tuple $l$, we'll read the value $v$, insert the
new element at the end of the newly created list, and shift it backward $v$
places.

\begin{center}
  \begin{tabular}{c|p{0.75\linewidth}}
    (0, 0, 2, 0, 1)               & We start from an empty list $[]$                                                                 \\
    (\highlight{{0}}, 0, 2, 0, 1) & We read 0 as the left-most value from $l$. Thus, we append the element $\el{0}$ to our
                                    list, getting $[\el{0}]$. The element is shifted $0$ places, so it remains in the
                                    same place.                                                                                                                      \\
    (0, \highlight{{0}}, 2, 0, 1) & Then, similarly, we read another 0 for the element $\el{1}$, append it to the
                                    list getting $[\el{0}, \el{1}]$, and don't shift it either.                                                                      \\
    (0, 0, \highlight{{2}}, 0, 1) & We read 2 for the next the element $\el{2}$ - we append $\el{2}$ to our list, getting
                                    $[\el{0}, \el{1}, \el{2}]$, and shift it 2 places right, which results in a list $[\el{0}, \el{2}, \el{1}]$
                                    \todo{Typeset it nicely, with arrows showing the shifting}.                                                                      \\
    (0, 0, 2, \highlight{{0}}, 1) & Then we read 0 - appending $\el{3}$ and not shifting, getting $[\el{0}, \el{2}, \el{1}, \el{3}]$ \\
    (0, 0, 2, 0, \highlight{{1}}) & Finally, reading 1 for element $\el{4}$ - appending $\el{4}$ to the list and shifting it
                                    one place right results in the final list $[\el{0}, \el{2}, \el{1}, \el{4}, \el{3}]$                                             \\
  \end{tabular}
\end{center}
\todo{figure}

Using this Lehmer encoding algorithm, we can now construct the equivalence
between these types.

\begin{proposition}
  For all $n:\Nat$,
  \[
    \Lehmer[n] \eqv \Aut[\Fin[n]]
  \]
\end{proposition}

\begin{proof}
  We have to turn this algorithm into a constructive proof in type theory where
  we only use functions and recursion. \todo{Describe the agda code.}
\end{proof}

\subsection{Symmetric groups}~\label{subsec:symmetric}

There is an obvious group structure on $\Aut[\Fin[n]]$ given by identity,
composition, and inverse. This is the symmetric group $S_n$ on $n$ symbols. In
the rest of the section we will construct a convenient presentation of this
group.

\todo{Reference T-algebra presentations as coequalisers (Mac Lane 6.7)}

First, we formally define a presentation of a group.

\begin{definition}
  A presentation of a group $G$ is a type $FR$ such that \ldots is a coequaliser.
\end{definition}

\vc{this is just a rough draft for now}

\begin{definition}
  Here we'll define a type family $FT n$ to be a free group generated by a type $T n$ with the following constructors
  \begin{align*}
     & cancel : i : \Fin[\suc[n]] \to T                                         \\
     & swap : (i : \Fin[\suc[n]]) \to (j : \Fin[\suc[n]]) \to (i + 1 < j) \to T \\
     & braid : (i : \Fin[n]) \to T                                              \\
  \end{align*}
\end{definition}

\begin{definition}[Adjacent transposition]
  \begin{align*}
    transpose : (n : \Nat) \to (k : \Fin[\suc[n]]) \to \Aut[\Fin[\suc[n]]]
  \end{align*}
  by double induction on $n$ and $k$, where
  \begin{align*}
    transpose (n) (0)             & = \lambda
    0 \to 1;
    1 \to 0;
    m \to m
    \\
    transpose (\suc[n]) (\suc[k]) & = \lambda
    0 \to 0;
    S m \to S ((transpose (n)(k)) m)
  \end{align*}
\end{definition}

\begin{proposition}
  $FR$ is a presentation of the symmetrc group, with $f$ and $g$ as follows:
  \begin{align*}
    f (inr (cancel (i))) & = inr (i :: i :: [])                     \\
    f (inl (cancel (i))) & = inl (i :: i :: [])                     \\
    f (inr (swap (i,j))) & = i :: j :: i :: j :: []                 \\
    f (braid (i))        & = i :: S i :: i :: S i :: i :: S i :: []
  \end{align*}
  and
  \begin{align*}
    g (inl (\_)) & = inl ([]) \\
    g (inr (\_)) & = inr ([])
  \end{align*}
\end{proposition}

We now introduce a presentation of the symmetric group.


\begin{theorem}
  For all $n : \Nat$,
  \[
    Sn(n) \eqv \Lehmer[n]
  \]
\end{theorem}

\subsection{Symmetric Monoidal structure}

$\UFin$ is a symmetric monoidal groupoid with unit and tensor given by

\begin{definition}
  \begin{align*}
    I           & \defeq F_{0}    \\
    X \otimes Y & \defeq X \sqcup Y
  \end{align*}
\end{definition}

with unitors, associator, and braiding satisfying Mac Lane's triangle, pentagon, and hexagon coherence laws, and
symmetry. It is the free symmetric monoidal groupoid on one generator.

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "main"
%%% fill-column: 120
%%% End:
