\section{The groupoid of finite types}~\label{sec:finite}

In this section, we describe \review{the algebraic structure} of the groupoid of
finite types, and give \review{a computable presentation} for it.

\vc{The groupoid of finite types is the free symmetric monoidal groupoid on one
  generator. This can be presented as an algebraic 2-theory, which is our syntax
  for $\PiHatLang$. Vertical categorification of natural numbers as a free
  commutative monoid. See groupoidification.}

\todo{Check Brent Yorgey's thesis?}

To do so, we will characterise the automorphisms on finite sets of cardinality
$n$, and show them to be equivalent to the symmetric group $\Sn$, via the
Coxeter presentation. We will do that in two steps,
in~\cref*{subsec:permutations,subsec:lehmer,subsec:symmetric}.

\todo{Big example: Start from a listed permutation, show Lehmer code, then adjacent swaps.}
\todo{Justification for why we need group theory.}

%% Coxeter presentation of $\Sn$ $\eqv$ $\Lehmer[n]$ $\eqv$ $\Aut[\Fin[n]]$

\subsection{Groups}

From universal algebra, a group is simply a set with a 0-ary constant, the neutral element, a binary operation for group
multiplication, and a unary inverse operation. A simple example is $\mathbb{Z}/n\mathbb{Z}$, where the neutral element
is 0, the inverse of $k$ is $-k$, and the group multiplication is given by addition modulo $n$. The neutral element has
to satisfy unit and inverse laws, and the multiplication has to be associative.

In type theory, a group $G$ can be defined as an $\hSet$ $S$ with the following pieces of data:

\begin{enumerate}
  \item a unit or neutral element $e : S$
  \item a multiplication function $m : S \times S \to S$ written as $(g_{1}, g_{2}) \mapsto g_{1} \mult g_{2}$, that satisfies
  \begin{enumerate}
    \item the unit laws, for all $g : S$, that \( g \mult e \id g \) and \( e \mult g \id g \)
    \item the associativity law, for all $g_{1}, g_{2}, g_{3} : S$, that \( g_{1} \mult (g_{2} \mult g_{3}) \id (g_{1} \mult g_{2}) \mult g_{3} \)
  \end{enumerate}
  \item an inversion function $i : S \to S$ written as $g \mapsto \inv{g}$, that satisfies
  \begin{enumerate}
    \item the inverse laws, for all $g : S$, that \( g \mult \inv{g} \id e \) and \( \inv{g} \mult g \id e \)
  \end{enumerate}
\end{enumerate}

However, more conveniently, in HoTT, we can instead use groupoids to talk about groups. A group can be identified with a
1-object groupoid, using a technique called delooping. The delooping of a group $G$ is a groupoid $\B{G}$ given by a
unique object $\pt$ with self-loops that are 1-paths $\pt \id_{\B{G}} \pt$ corresponding to the elements of $G$. Note
that the group operations are automatically given by operations on the identity type, with $\refl_{\pt}$ for the neutral
element, path composition for the group multiplication, and path inverse for the group inverse. These satisfy the group
laws as well, up to the identity type, using the groupoid coherence laws. Moreover, for 1-groups which are supposed to
be sets, these 2-paths should be propositions, so we have to restrict $\B{G}$ to be a 1-groupoid. Hence, a group is
simply given by a pointed, connected 1-type~\cite*{buchholtzHigherGroupsHomotopy2018,symmetryBook2021}.

For example, given a pointed type $(A:\UU, a:A)$, the automorphism group structure at $a$ is given by $a \id_{A} a$. Of
course, for 1-groups we will require that $a \id_{A} a$ is an $\hSet$, which is enforced by having $A$ be a groupoid. In
our running example for the permutation group on finite sets, we have that $\Fin[n]$ is an $\hSet$, and hence,
$\UFin[n] \defeq \BAut[\Fin[n]]$ is a pointed, connected 1-type, whose loopspace $\loopspace[\BAut[\Fin[n]],F_{n}]$ is
equivalent to $\Aut[\Fin[n]] \defeq (\Fin[n] \eqv \Fin[n]) \eqv (\Fin[n] \id_{\UU} \Fin[n])$, which has the
corresponding automorphism group structure.

Alternatively, groups can also be presented using generators and relations, or a quotient of the free group \ldots

2. In the usual setting, there are are many relations that are true for the elements of the group. For example, in the
(Z mod 3), we have a relation 1 + 1 + 1 = 0.

3. A group that has no other relations than the ones directly implied by
the definition of a group is called free.

4. A group is said to be generated by a set of its elemenst (e1, ..., en)
if every element in the group can be constructed from these elements
composing operations of + and inverse. For example, Z is a free group,
generated by one-element set (1).
4a. Thus, a free group g can be thought as sequences of letters from the
generating set, divided by the congruence closure of the group relation.
Definition: Free group.

5. One useful way of defining groups is by their presentations.
Presentation of a group builds a group by specifying what is the set of
generators - thus making a free group - a collection of equations that have
to be satisfied in the resulting group. For example, we could take the
generators to be the set (1) (giving out Z), and then add an equation (1 +
1 + 1 = 0) - thus, getting (Z mod 3).

5a. The generatos can be thought of as primitive operations in a language,
and the group structure gives us the way of composing these operations and
inverting them.

6. Building a group like that is possible because of the universal property
of the free group.
Theorem: Universal property of a free group.
Definition: formal definition of a free group.

7. Why do it like that? Because it is a very syntactic approach to doing
the theory. The way described previously operates directly in the semantics
of the group operation - equality of elements (such as the result of adding
two elements) has to be computed externally.
Here, the equality can be computed using a rewriting system specified by
the group axioms and the additional equations provided. However, because
equations are not directed, it is not always possible to construct a
well-behaving rewriting system. In general, the word problem (i.e. deciding
if two words are equal) is proven to be undecidable.

\subsection{Permutation Groups}

8. The group that we are interested in is the group of permutations on a
fininte set. We can define it formally in two different ways:
8a. Taking the type Aut (Fin n) and showing that it satisfies the group
axiom.
8b. Writing up a presentation - choosing generating set and equations that
have to be satisfied.

9. By proving these two to be equivalent, we are bridging the gap between
syntactic and semantic side in the whole proof - by assinging the meaning
(a bijection) to a word (a program).
9a. However, proving them equivalent will require, in particular, solving
the word problem (in this specific instance).

10. However, in the point 8b, there is an element of choice. One group can
be presented in many different ways. For example, we could generate the
permutations by using generators that:
 - swap i-th element with j-th element
 - swap i-th element with the first element
 - shift elements in a cyclic way: operation with label "i" leaves elements
with numbers > i in place, and element j <= i goes to (j + 1) mod i.

11. One way of thinking about these presentations is to compare them to
sorting algorithms with different primitive operations. If using a set of
operations, one can sort any list, then these operations generate the
permutations group. One weird example: pancake sorting.

\subsection{Coxeter Presentation}

12. Here, we are choosing a presentation based on the adjacent
transpositions generators - i.e. primitive operations of the form "swap
i-th and i+1 elements". In the language of sorting, this corresponds to
what the insertion sort or bubble sort are doing.
In the explanations below, we will use diagrams to draw the permutations.

12a. There two very obvious laws that such operation has to preserve:
 - Swapping the same two elements two times in a row does not change
anything (cancel)
TODO diagram.
 - When swapping two pairs of elements on a positions far away, it does not
matter in which order one does it (swap). (We can slide the wires).
TODO diagram.
But there is also one more law that these operations have to satisfy, in
the situation when we are swapping adjacent pairs of elements. It is best
seen on a diagram (braid)
TODO diagram.

This construction is called a Coxeter presentation. Writing it formally, we
get the following definition
Definition: Coxeter presentation.

13. There are two main considerations to this choice:
13a. How well the presentation matches the syntactic side of Pi? This is,
how closely does the operational semantics built from these particular
primitive operations match the natural operational semantics of Pi?
13b. How convenient is it to turn the presentation it into rewriting system
and solve the word problem for it?

Thus, the argument:
14. TODO I don't know what to write here, we have to think.

15a. The equations that define Coxeter presentation have a nice property:
as it is written, the LHS is smaller (lexicographically) than the RHS.
Thus, if we could direct them from right to left, it would have a
termination property out of the box.
15b. However, it is not at all obvious that the system would be confluent.
There are many possible critical pairs, such as
TODO diagram 1212 (braid, braid)
or
TODO diagram 3233 (braid, cancel)
As it turns out, there are instances of critical pairs that do not resolve.
A simplest example is the following:
TODO diagram 3213

16. The equations have to be changed. We thus propose a new presentation.
We keep the (cancel) and (swap) equations, but replace (braid) with a more
general:
TODO diagram:

Definition: Long Coxeter presentation.

17. In return for increased complexity of the equations, it satisfies the
diamond property (if we direct the equation). Thus, together with the
(preserved) termination, it creates a confluent rewriting system.
Proof: All the critical pairs resolve, in the appendix.
Definition: A normal form is a list that cannot be reduced any further.

18. We define the equivalence classes on List (Fin n) to be precisely these
elements that have the same normal form.

19. However, the Long Coxeter relations are unwieldly and have no
connectino to the broader scope of computational group theory - while the
usual Coxeter presentation is to-go choice in this area (cite all these
papers in Coq, this guy from Sweden(?) etc.).
Thus, we prove:
Proposition: Long Coxeter is equivalent to normal Coxeter.

19a. (Note: here we try to convince the reader about reusability badge) So,
the Long Coxeter can be regarded as a trick to get the proof to pass - but
the external user-facing interface is still that of the usual Coxeter
presentation.

20. Now, to prove the equivalence of 9, on one side we have Aut(Fin n), and
on the other, equivalence classes of List (Fin n) wrt to the usual Coxeter
group, we would define two functions from and back. The easiest way to
define a function out of the group presentation is to define them on the
equivalence classes' representatives. But to do that, we have to know how
do these representatives look like exactly.

\subsection{Lehmer Codes}

21. Enter: Lehmer codes.
TODO diagram with List (Fin n) being divided into equivalence classes, and
Lehmer codes being an image of immersion, being the normal form
(representative) in each class.

\subsection{Permutations}~\label{subsec:permutations}

In the previous~\cref{sec:univalent}, we established that paths in $\UFin$ are
equivalent to families of automorphisms of $\Fin{n}$ for every $n:\Nat$, that
is, bijections on finite sets of size $n$. This is the extensional view of
permutations. In the following sections, we will characterise these
permutations, going through two intermediate steps.

\vc{This is obvious, maybe add something more here.}

\subsection{Lehmer codes}~\label{subsec:lehmer}

From grade school combinatorics, we know that there are $\fac{n}$ permutations
on a finite set with $n$ elements. The factorial function is defined by
recursion on natural numbers. However, now, for every $n$, we want to produce a
type, which is a finite set, with cardinality $\fac{n}$. And, to characterise
$\Aut[\Fin[n]]$, we further need to construct a bijection between this type and
$\Aut[\Fin[n]]$.

First, let's define this type with $\fac{n}$ elements, we name this type family
$\Lehmer : \Nat \to \UU$, which is defined by recursion on $\Nat$ as follows.
This is the obvious definition of factorials by recursion, but categorified from
natural numbers to sets.

\begin{definition}
  \begin{align*}
    \Lehmer[0]       & \defeq \unit                           \\
    \Lehmer[\suc[n]] & \defeq \Fin[\suc[n]] \times \Lehmer[n]
  \end{align*}
\end{definition}

\todo{Subexcedant sequences and factorial definitions are equivalent, explain
  this!}

The name Lehmer comes from Lehmer
codes~\cite{lehmerTeachingCombinatorialTricks1960} which are known in
Combinatorial Analysis~\cite{bellmanCombinatorialAnalysis1960}. There are many
ways to represent permutations, e.g. inversions, or cycles, or matrices. Lehmer
codes are a particularly convenient way to represent permutations on a
computer,~\review{they are compact and have exactly the right cardinality.
  $\Lehmer[n]$ is a $n+1$-element tuple, where the position $k \leq n$ has an
  element of $\Fin[k]$. The 0-th position is trivial, so we ignore it, and in
  both the example below and the Agda proof, consider only the remaining
  $n$-element tuple.}

\vc{This is just the classical algorithm to explain the example, not the actual
  type-theoretic proof.}

Suppose we have a permutation $p$ on an $n$-element set
$\{\el{0}, \el{1}, \el{2}, \el{3}, \el{4}\}$, we encode it as follows.
$\Lehmer[n]$ is a $n$-element tuple. At position $k$, we put the number of
inversions of the element $\el{k}$ in $p$, i.e. the number of elements smaller
than $\el{k}$ occurring after $\el{k}$.

As an example, consider the following tabulated presentation of the permutation:

\todo{fix this figure}

\[
  p =
  \begin{array}{ccccccccccccccc}
    | & 0      & | & 1      & | & 2      & | & 3      & | & 4      & | \\
    \hline                                                             \\
    | & \el{2} & | & \el{0} & | & \el{1} & | & \el{4} & | & \el{3} & | \\
    \hline                                                             \\
  \end{array}
\]

%  0 1 2 3 4
% -----------
% |2|0|1|4|3|
% -----------

The element $\el{0}$ has 0 inversions, because there are no elements smaller
than $\el{0}$ occurring after it. In fact, there can be no elements smaller than
$\el{0}$ at all, so the type at the first position of the Lehmer code tuple is
$\unit$.

The element $\el{1}$ has 0 inversions as well, since elements occurring after it
in the permutation are $\el{4}$ and $\el{2}$. There is only one different case,
if $\el{1}$ appeared before $\el{0}$, it would have 1 inversion. This is why the
type of the second component of the Lehmer code is $\Fin[2]$.

The element $\el{2}$ has 2 inversions, because both $\el{0}$ and $\el{1}$ occur
after it in the permutation. The element $\el{3}$ occurs as the last one, so it
has 0 inversions. The element $\el{4}$ has 1 inversion, with the element
$\el{3}$.

Thus, the Lehmer code for the permutation $p$ is the 5-tuple
$l = (0, 0, 2, 0, 1)$.

To reconstruct the tabulated presentation of the permutation from the Lehmer
code, we perform an algorithm similar to \emph{insertion sort}. Starting from
the left-most position of the tuple $l$, we'll read the value $v$, insert the
new element at the end of the newly created list, and shift it backward $v$
places.

\begin{center}
  \begin{tabular}{c|p{0.75\linewidth}}
    (0, 0, 2, 0, 1)               & We start from an empty list $[]$                                                                 \\
    (\highlight{{0}}, 0, 2, 0, 1) & We read 0 as the left-most value from $l$. Thus, we append the element $\el{0}$ to our
                                    list, getting $[\el{0}]$. The element is shifted $0$ places, so it remains in the
                                    same place.                                                                                                                      \\
    (0, \highlight{{0}}, 2, 0, 1) & Then, similarly, we read another 0 for the element $\el{1}$, append it to the
                                    list getting $[\el{0}, \el{1}]$, and don't shift it either.                                                                      \\
    (0, 0, \highlight{{2}}, 0, 1) & We read 2 for the next the element $\el{2}$ - we append $\el{2}$ to our list, getting
                                    $[\el{0}, \el{1}, \el{2}]$, and shift it 2 places right, which results in a list $[\el{0}, \el{2}, \el{1}]$
                                    \todo{Typeset it nicely, with arrows showing the shifting}.                                                                      \\
    (0, 0, 2, \highlight{{0}}, 1) & Then we read 0 - appending $\el{3}$ and not shifting, getting $[\el{0}, \el{2}, \el{1}, \el{3}]$ \\
    (0, 0, 2, 0, \highlight{{1}}) & Finally, reading 1 for element $\el{4}$ - appending $\el{4}$ to the list and shifting it
                                    one place right results in the final list $[\el{0}, \el{2}, \el{1}, \el{4}, \el{3}]$                                             \\
  \end{tabular}
\end{center}
\todo{figure}

Using this Lehmer encoding algorithm, we can now construct the equivalence between these types.

We define a type family $\FinExcept{n} : \Fin[n] \to \UU$ which picks out all elements in $\Fin[n]$ except the one
provided. Note that $\FinExcept{n}[i]$ for $i : \Fin[n]$ is a subtype of $\Fin[n]$ and is hence an $\hSet$.

\begin{definition}
  \( \FinExcept{n}[i] \defeq \dsum{j : \Fin[n]}{i \neq j} \).
\end{definition}

\begin{proposition}
  For any $k : \Fin[n]$, $\unit \sqcup \FinExcept{n}[k] \eqv \Fin[n]$.
\end{proposition}

\begin{proposition}
  For any $k : \Fin[\suc[n]]$, $\FinExcept{\suc[n]}[k] \eqv \Fin[n]$.
\end{proposition}

\begin{proposition}
  For any $n : \Nat$,
  \( \Aut[\Fin[\suc[n]]] \eqv \dsum{k : \Fin[\suc[n]]}{\FinExcept{\suc[n]}[\fzero] \eqv \FinExcept{\suc[n]}{k}} \).
\end{proposition}

\begin{proposition}
  For all $n:\Nat$, \( \Lehmer[n] \eqv \Aut[\Fin[n]] \).
\end{proposition}

\begin{proof}
  For $n = 0$, note that $\Lehmer[0]$ is contractible, and so is $\Aut[\Fin[0]]$. For $n = \suc[m]$, we have the
  following chain of equivalences.
  \[\arraycolsep=0.5em\def\arraystretch{1.5}
    \begin{array}{rl}
      & \Aut[\Fin[\suc[m]]] \\
      \eqv & \dsum{k : \Fin[\suc[m]]}{\FinExcept{\suc[m]}[\fzero] \eqv \FinExcept{\suc[m]}[k]} \\
      \eqv & \dsum{k : \Fin[\suc[m]]}{\FinExcept{\suc[m]}[\fzero] \eqv \Fin[m]} \\
      \eqv & \dsum{k : \Fin[\suc[m]]}{\Fin[m] \eqv \Fin[m]} \\
      \eqv & \Fin[\suc[m]] \times \Aut[\Fin[m]] \\
      \eqv & \Fin[\suc[m]] \times \Lehmer[m] \\
    \end{array}
  \]
\end{proof}

\subsection{Symmetric groups}~\label{subsec:symmetric}

There is an obvious group structure on $\Aut[\Fin[n]]$ given by identity,
composition, and inverse. This is the symmetric group $S_n$ on $n$ symbols. In
the rest of the section we will construct a convenient presentation of this
group.

\vc{this is just a rough draft for now}

\todo{Reference T-algebra presentations as coequalisers (Mac Lane 6.7)}

First, we formally define a presentation of a group.

\todo{Free 1-group, needs to be truncated}

\begin{definition}
  Let $A$ be a type, and $\List[A]$ the free monoid on $A$. The free group $F(A)$ on $A$ is the set-quotient of
  $\List[A + A]$ by the congruence closure of the relation $(\inl(a) \cons \inr(a) \cons \nil) \sim \nil$.
\end{definition}

\begin{proposition}
  Let $\eta_{A} : A \to F(A)$ be given by $a \mapsto \inl(a) \cons \nil$. Given any group $G$ with a map $f : A \to G$,
  there is a canonical lifting of $f$ to a group homomorphism $\extend{f} : F(A) \to G$, such that
  $\extend{f} \comp \eta_{A} \htpy f$, that is, the type of group homomorphisms $h : \Grp(F(A),G)$ satisfying
  $h \comp \eta_{A} \htpy f$ is contractible. Equivalently, composition by $\eta_{A}$ is an equivalence
  $\Grp(F(A),G) \eqv (A \to G)$.
\end{proposition}

\todo{diagram}
\todo{Plus/Minus}

\begin{definition}
  Let $A$ be a type and $R : A \to A \to \UU$ a binary relation on $A$. The group $G$ presented by
  $\langle A ; R \rangle$ is given by the set-quotient of the free group $F(A)$ by the normal closure $N_{R}$ of $R$, or
  equivalently, as the coequaliser
  \[\begin{tikzcd}
      FR && FA && G
      \arrow[shift right=2, from=1-1, to=1-3]
      \arrow[shift left=2, from=1-1, to=1-3]
      \arrow[two heads, from=1-3, to=1-5]
    \end{tikzcd}\]
\end{definition}

\todo{Universal property}
\todo{Examples: empty relation, van Kampen of $\pi_{1}$}

\subsubsection{Coxeter Relations}

We define a binary relation on $\List[\Fin[n]]$.

\begin{definition}[$\cox$]
  \begin{align*}
    \cancel
    & : \forall n \to (n \cons n \cons \nil) \cox \nil \\
    \swap
    & : \forall k, n \to (\suc[k] < n) \to (n \cons k \cons \nil) \cox (k \cons n \cons \nil) \\
    \braid
    & : \forall n \to (\suc[n] \cons n \cons \suc[n] \cons \nil) \cox (n \cons \suc[n] \cons n \cons \nil) \\
  \end{align*}
\end{definition}

We define $\cox*$ as the congruence closure of $\cox$.
\vc{This could be simplified a bit depending on our formalisation. $\cox$ is directed, use a different symbol?}

\begin{definition}[$\cox*$]
  \begin{align*}
    \reflr{\cox}
    & : \forall w \to w \cox* w \\
    \symr{\cox}
    & : \forall w_{1}, w_{2} \to w_{1} \cox* w_{2} \to w_{2} \cox* w_{1} \\
    \transr{\cox}
    & : \forall w_{1}, w_{2}, w_{3} \to  w_{1} \cox* w_{2} \to w_{2} \cox* w_{3} \to w_{1} \cox* w_{3} \\
    \congrf{\cox}{\append}
    & : \forall w_{1}, w_{2}, w_{3}, w_{4} \to  w_{1} \cox* w_{2} \to w_{3} \cox* w_{4} \to w_{1} \append w_{3} \cox* w_{2} \append w_{4} \\
    \relr{\cox}
    & : \forall w_{1}, w_{2} \to w_{1} \cox w_{2} \to w_{1} \cox* w_{2} \\
  \end{align*}
\end{definition}

\todo{Long form of Coxeter relations and their equivalence.}

We state and prove two desirable properties of this relation on $\List[\Fin[n]]$ from the point of view of an abstract
rewriting system. We follow the terminology of~\cite{krausCoherenceWellFoundednessTaming2020}. \vc{Not completely
  formalised. Is this with Coxeter or LongCoxeter?}

\begin{proposition}
  \leavevmode
  \begin{enumerate}
    \item $\cox$ is (locally) confluent. For every span $w_{1} \cox w \cox w_{2}$, there is a matching extended cospan
          $w_{1} \cox* v \cox* w_{2}$.
    \item $\cox*$ is strongly normalising. For every $w$, there exists a unique $v$ such that $w \cox* v$.
          \review{Equivalently, the type $\dsum{v:\List[\Fin[n]]}{w \cox* v}$ is contractible, and $w \cox* v$ is a
          proposition for every $w$ and $v$.}
  \end{enumerate}
\end{proposition}

The type $\Sn$ is defined as the set-quotient of $\List[\Fin[n]]$ by $\cox*$.

\begin{definition}[$\Sn$]
  \(\Sn \defeq \quot{\List(\Fin[n])}{\cox*}\)
\end{definition}

We will now prove the group structure of $\Sn$.

\begin{proposition}
  There is a group structure on $\Sn$, where the identity element is $\nil$, multiplication is given by list append, and
  inverse is given by list reversal.
\end{proposition}

\begin{proposition}
  $\Sn$ is equivalent to the generated group given by the normal closure of $\cox*$ extended to
  $\List(\Fin[n] + \Fin[n])$ along the codiagonal map $[\term{id},\term{id}] : A + A \to A$.
\end{proposition}

We will now show how to generate a Lehmer code from a word in $\Sn$ and back.

\begin{definition}
  \[
    \encode{\List} : \List[\Fin[n]] \to \Lehmer[n]
  \]
\end{definition}

\begin{proposition}
  \leavevmode
  \begin{enumerate}
    \item \( l_{1} \cox* l_{2} \to \encode{\List}(l_{1}) \id \encode{\List}(l_{1}) \)
  \end{enumerate}
\end{proposition}

\begin{definition}
  \begin{align*}
    \encodeSn & : \Sn[n] \to \Lehmer[n] \\
    \decodeSn & : \Lehmer[n] \to \Sn[n]
  \end{align*}
\end{definition}

\begin{proposition}
  For all $n : \Nat$, $(\encodeSn, \decodeSn)$ is an equivalence.
\end{proposition}

\begin{corollary}
  For all $n : \Nat$,
  \(
    \Sn \eqv \Lehmer[n] \eqv \Aut[\Fin[n]]
  \).
\end{corollary}

\subsection{Symmetric Monoidal structure}

We describe the symmetric monoidal structure of the groupoid $\UFin$.

First, we observe a few equivalences.

\begin{proposition}
  For any $n, m : \Nat$,
  \begin{align*}
    \Fin[0]                & \eqv \bot \\
    \Fin[n] \sqcup \Fin[m] & \eqv \Fin[n + m] \\
  \end{align*}
  and for any types $X, Y, Z$,
  \begin{align*}
    \bot \sqcup X          & \eqv X \\
    X \sqcup \bot          & \eqv X \\
    (X \sqcup Y) \sqcup Z  & \eqv X \sqcup (Y \sqcup Z) \\
    X \sqcup Y             & \eqv Y \sqcup Y \\
  \end{align*}
\end{proposition}

We lift these equivalences to $\UFin$ giving it the (additive) symmetric monoidal structure $(I, \oplus)$, with natural
isomorphisms $\lambda_{X}$, $\rho_{X}$, $\alpha_{X,Y,Z}$, and the symmetry isomorphism $\mathcal{B}_{X,Y}$. Note that
types in $\UFin$ are $\hSet$s since they're merely equivalent to $\Fin[n]$ for some $n : \Nat$.

\begin{definition}
  \begin{align*}
    I           & \defeq F_{0}    \\
    X \oplus Y & \defeq X \sqcup Y \\
    \lambda_{X} & : I \oplus X \eqv X \\
    \rho_{X} & : X \oplus I \eqv X \\
    \alpha_{X,Y,Z} & : (X \oplus Y) \oplus Z \eqv X \oplus (Y \oplus Z) \\
    \mathcal{B}_{X,Y} & : X \oplus Y \eqv Y \oplus X
  \end{align*}
\end{definition}

These isomorphisms satisfy the Mac Lane coherence conditions for symmetric monoidal categories, that is, the triangle,
pentagon, and hexagon identities, and the syllepsis of the braiding, upto 2-paths in $\UFin$.

\begin{proposition}
  % https://q.uiver.app/?q=WzAsNCxbMCwwLCIoWCBcXG9wbHVzIEkpIFxcb3BsdXMgWSJdLFsyLDAsIlggXFxvcGx1cyAoSSBcXG9wbHVzIFkpIl0sWzEsMSwiWCBcXG9wbHVzIFkiXSxbMCwxXSxbMCwxLCJcXGFscGhhX3tYLEksWX0iXSxbMCwyLCJcXHJob197WH0gXFxvcGx1cyAxX3tZfSIsMl0sWzEsMiwiMV97WH0gXFxvcGx1cyBcXGxhbWJkYV97WX0iXSxbNSw2LCJcXGlkIiwwLHsic2hvcnRlbiI6eyJzb3VyY2UiOjIwLCJ0YXJnZXQiOjIwfSwic3R5bGUiOnsiYm9keSI6eyJuYW1lIjoibm9uZSJ9LCJoZWFkIjp7Im5hbWUiOiJub25lIn19fV1d
  \[\begin{tikzcd}
      {(X \oplus I) \oplus Y} && {X \oplus (I \oplus Y)} \\
      {} & {X \oplus Y}
      \arrow["{\alpha_{X,I,Y}}", from=1-1, to=1-3]
      \arrow[""{name=0, anchor=center, inner sep=0}, "{\rho_{X} \oplus 1_{Y}}"', from=1-1, to=2-2]
      \arrow[""{name=1, anchor=center, inner sep=0}, "{1_{X} \oplus \lambda_{Y}}", from=1-3, to=2-2]
      \arrow["\id", Rightarrow, draw=none, from=0, to=1]
    \end{tikzcd}\]
  % https://q.uiver.app/?q=WzAsNSxbMCwxLCIoKFcgXFxvcGx1cyBYKSBcXG9wbHVzIFkpIFxcb3BsdXMgWiJdLFsxLDAsIihXIFxcb3BsdXMgWCkgXFxvcGx1cyAoWSBcXG9wbHVzIFopIl0sWzIsMSwiVyBcXG9wbHVzIChYIFxcb3BsdXMgKFkgXFxvcGx1cyBaKSkiXSxbMiwzLCJXIFxcb3BsdXMgKChYIFxcb3BsdXMgWSkgXFxvcGx1cyBaKSJdLFswLDMsIihXIFxcb3BsdXMgKFggXFxvcGx1cyBZKSkgXFxvcGx1cyBaIl0sWzAsMSwiXFxhbHBoYV97VyBcXG9wbHVzIFgsIFksIFp9Il0sWzEsMiwiXFxhbHBoYV97VyxYLFkgXFxvcGx1cyBafSJdLFszLDIsIjFfe1d9IFxcb3BsdXMgXFxhbHBoYV97WCxZLFp9IiwyXSxbMCw0LCJcXGFscGhhX3tXLFgsWX0gXFxvcGx1cyAxX3tafSIsMl0sWzQsMywiXFxhbHBoYV97VyxYIFxcb3BsdXMgWSxafSIsMl0sWzAsMiwiXFxpZCIsMSx7Im9mZnNldCI6NSwic3R5bGUiOnsiYm9keSI6eyJuYW1lIjoibm9uZSJ9LCJoZWFkIjp7Im5hbWUiOiJub25lIn19fV1d
  \[\begin{tikzcd}
      & {(W \oplus X) \oplus (Y \oplus Z)} \\
      {((W \oplus X) \oplus Y) \oplus Z} && {W \oplus (X \oplus (Y \oplus Z))} \\
      \\
      {(W \oplus (X \oplus Y)) \oplus Z} && {W \oplus ((X \oplus Y) \oplus Z)}
      \arrow["{\alpha_{W \oplus X, Y, Z}}", from=2-1, to=1-2]
      \arrow["{\alpha_{W,X,Y \oplus Z}}", from=1-2, to=2-3]
      \arrow["{1_{W} \oplus \alpha_{X,Y,Z}}"', from=4-3, to=2-3]
      \arrow["{\alpha_{W,X,Y} \oplus 1_{Z}}"', from=2-1, to=4-1]
      \arrow["{\alpha_{W,X \oplus Y,Z}}"', from=4-1, to=4-3]
      \arrow["\id"{description}, shift right=5, draw=none, from=2-1, to=2-3]
    \end{tikzcd}\]
  % https://q.uiver.app/?q=WzAsNixbMSwwLCJYIFxcb3BsdXMgKFkgXFxvcGx1cyBaKSJdLFswLDEsIihYIFxcb3BsdXMgWSkgXFxvcGx1cyBaIl0sWzAsMiwiKFkgXFxvcGx1cyBYKSBcXG9wbHVzIFoiXSxbMSwzLCJZIFxcb3BsdXMgKFggXFxvcGx1cyBaKSJdLFsyLDIsIlkgXFxvcGx1cyAoWiBcXG9wbHVzIFgpIl0sWzIsMSwiKFkgXFxvcGx1cyBaKSBcXG9wbHVzIFgiXSxbMSwwLCJcXGFscGhhX3tYLFksWn0iXSxbMSwyLCJcXG1hdGhjYWx7Qn1fe1gsWX0gXFxvcGx1cyAxX3tafSIsMl0sWzIsMywiXFxhbHBoYV97WSxYLFp9IiwyXSxbMyw0LCIxX3tZfSBcXG9wbHVzIFxcbWF0aGNhbHtCfV97WCxafSIsMl0sWzUsNCwiXFxhbHBoYV97WSxaLFh9Il0sWzAsNSwiXFxtYXRoY2Fse0J9X3tYLFkgXFxvcGx1cyBafSJdLFs3LDEwLCJcXGlkIiwwLHsic2hvcnRlbiI6eyJzb3VyY2UiOjIwLCJ0YXJnZXQiOjIwfSwic3R5bGUiOnsiYm9keSI6eyJuYW1lIjoibm9uZSJ9LCJoZWFkIjp7Im5hbWUiOiJub25lIn19fV1d
  \[\begin{tikzcd}
      & {X \oplus (Y \oplus Z)} \\
      {(X \oplus Y) \oplus Z} && {(Y \oplus Z) \oplus X} \\
      {(Y \oplus X) \oplus Z} && {Y \oplus (Z \oplus X)} \\
      & {Y \oplus (X \oplus Z)}
      \arrow["{\alpha_{X,Y,Z}}", from=2-1, to=1-2]
      \arrow[""{name=0, anchor=center, inner sep=0}, "{\mathcal{B}_{X,Y} \oplus 1_{Z}}"', from=2-1, to=3-1]
      \arrow["{\alpha_{Y,X,Z}}"', from=3-1, to=4-2]
      \arrow["{1_{Y} \oplus \mathcal{B}_{X,Z}}"', from=4-2, to=3-3]
      \arrow[""{name=1, anchor=center, inner sep=0}, "{\alpha_{Y,Z,X}}", from=2-3, to=3-3]
      \arrow["{\mathcal{B}_{X,Y \oplus Z}}", from=1-2, to=2-3]
      \arrow["\id", Rightarrow, draw=none, from=0, to=1]
    \end{tikzcd}\]
  % https://q.uiver.app/?q=WzAsMyxbMCwwLCJYIFxcb3BsdXMgWSJdLFsyLDAsIlggXFxvcGx1cyBZIl0sWzEsMSwiWSBcXG9wbHVzIFgiXSxbMCwxLCIxX3tYIFxcb3BsdXMgWX0iLDAseyJsZXZlbCI6Miwic3R5bGUiOnsiaGVhZCI6eyJuYW1lIjoibm9uZSJ9fX1dLFswLDIsIlxcbWF0aGNhbHtCfV97WCxZfSIsMl0sWzIsMSwiXFxtYXRoY2Fse0J9X3tZLFh9IiwyXSxbNCw1LCJcXGlkIiwwLHsic2hvcnRlbiI6eyJzb3VyY2UiOjIwLCJ0YXJnZXQiOjIwfSwic3R5bGUiOnsiYm9keSI6eyJuYW1lIjoibm9uZSJ9LCJoZWFkIjp7Im5hbWUiOiJub25lIn19fV1d
  \[\begin{tikzcd}
      {X \oplus Y} && {X \oplus Y} \\
      & {Y \oplus X}
      \arrow["{1_{X \oplus Y}}", Rightarrow, no head, from=1-1, to=1-3]
      \arrow[""{name=0, anchor=center, inner sep=0}, "{\mathcal{B}_{X,Y}}"', from=1-1, to=2-2]
      \arrow[""{name=1, anchor=center, inner sep=0}, "{\mathcal{B}_{Y,X}}"', from=2-2, to=1-3]
      \arrow["\id", Rightarrow, draw=none, from=0, to=1]
    \end{tikzcd}\]
\end{proposition}

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "main"
%%% fill-column: 120
%%% End:
