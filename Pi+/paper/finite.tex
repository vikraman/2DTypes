\section{The Group of Permutations}
\label{sec:finite}

% Recap of the previous section
In~\Cref{sec:ufin}, we established that paths in $\UFin$ are equivalent to families of loops on $\Fin[n]$ for every
$n:\Nat$, that is, automorphisms of finite sets of size $n$, with the loopspace encoding the automorphism group. This is
also known to be the finite symmetric group $\Sn[n]$. In the following sections, we will describe this group
syntactically.

% What now?
In order to study syntactic descriptions of permutations, we will hit the problem of deciding whether two descriptions
refer to the same permutation -- in group theory, this is the \emph{word problem} for $\Sn$. Putting it in this form
allows us to connect it to the broader scope of computational group theory and combinatorics -- we can borrow ideas such
as Coxeter relations and Lehmer codes.

% The summary of what we'll do
Thus, the goal of this section is to reconcile two different approaches to defining the symmetric group -- as an
automorphism group, and as a group syntactically presented using \emph{generators} and \emph{relations}. The generators
of the group are similar to the primitive combinators in a (reversible) programming language -- the group structure
gives the composition and inverse operations, and the relations describe how these primitive combinators interact with
each other.

% High-level explanation of technical devices
First, we will define the required notions of free groups and group presentations, and state some of their most
important properties. Then, we introduce our chosen \emph{Coxeter presentation} for $\Sn$. To solve the word problem for
$\Sn$, we will use a rewriting system, with a suitable, well behaved collection of reduction rules corresponding to the
Coxeter presentation. Finally, we describe the normal forms in this rewriting system, using Lehmer codes, and prove the
correspondence between them and the type $\Aut[\Fin[n]]$ of automorphisms on a finite set. The generators and relations
we use here will be used to quote back to 1 and 2-combinators in $\PiLang$ (see~\Cref{sec:equivalence}).

\subsection{Presenting the permutation group}

One way of thinking about presentations of $\Sn$ is via sorting algorithms, which use different primitive operations. A
sorting algorithm has to calculate a permutation of a list or a finite set, which satisfies the invariant of being a
sorted sequence, which means, the primitive operations of a sorting algorithm are able to generate all the permutations
on a given list. So, a chosen set of reversible operations in a sorting algorithm can be a good candidate for the
generators of a permutation group. For example, we could generate the permutation group on $\Fin[n]$ by using generators
(primitive operations) that:

\begin{itemize}
  \item swap the $i$-th element with the $(i+1)$-th element, that is, adjacent swaps, or
  \item swap the $i$-th element with the $j$-th element, for arbitrary $i$-s and $j$-s, or
  \item swap the $i$-th element with an element at a fixed position, or
  \item reverses a prefix $\Fin[k]$ of $\Fin[n]$ for $k \leq n$, or
  \item cyclically shift any subset of $\Fin[n]$.
\end{itemize}

Bubble sort uses the primitive operation of adjacent swaps, insertion sort and selection sort use the primitive
operation of swapping the $i$-th element with the $j$-th element, cycle sort uses cyclical shifts of subsequences,
pancake sort uses reversals of the prefixes of the list, et cetera. The choice of generators for our presentation is
important for the following reasons.

\begin{itemize}
  \item It affects the difficulty of solving the word problem in $\Sn$ and formalising the proof of its correctness.
  \item The choice of generators dictates which words become normal forms in this presentation of $\Sn$. These normal
        forms dictate the shape of the synthesised and normalised boolean circuits, which is the application we have in
        mind.
  \item Finally, the generators have to closely match the $\PiLang$ combinators so that we can quote back a permutation
        to a $\PiLang$ program, for the proof of completeness.
\end{itemize}

We use a presentation based on adjacent transpositions for generators, called a~\emph{Coxeter presentation}, which we
also use to solve the word problem for $\Sn$. Connecting it back to the language $\PiLang$, we will show that it is
possible to encode all $\PiLang$ combinators using adjacent transpositions (in~\Cref{sec:equivalence}). The rest of this
section develops these intuitions formally. Group presentations are built by adding equations to a \emph{free group},
which we define first.

\begin{toappendix}
  \subsection{Groups}

  From universal algebra, a group is simply a set with a 0-ary constant $e$ (the neutral element), a binary operation
  $\blank\mult\blank$ for group multiplication, and a unary inverse operation $\inv{\blank}$. The neutral element has to
  satisfy unit and inverse laws, and the multiplication has to be associative (see~\Cref{def:group}).

  A very simple example of a group is $\mathbb{Z}$, where the neutral element is 0, the inverse of $k$ is $-k$, and the
  group multiplication is given by integer addition.

  \begin{definition}~\label{def:group}
    In type theory, a group $G$ can be defined as a set $S$ with the following pieces of data:

    \begin{enumerate}
      \item a unit or neutral element $e : S$
      \item a multiplication function $m : S \times S \to S$ written as $(g_{1}, g_{2}) \mapsto g_{1} \mult g_{2}$, that satisfies
            \begin{enumerate}
              \item the unit laws, for all $g : S$, that \( g \mult e \id g \) and \( e \mult g \id g \)
              \item the associativity law, for all $g_{1}, g_{2}, g_{3} : S$, that \( g_{1} \mult (g_{2} \mult g_{3}) \id (g_{1} \mult g_{2}) \mult g_{3} \)
            \end{enumerate}
      \item an inversion function $i : S \to S$ written as $g \mapsto \inv{g}$, that satisfies
            \begin{enumerate}
              \item the inverse laws, for all $g : S$, that \( g \mult \inv{g} \id e \) and \( \inv{g} \mult g \id e \)
            \end{enumerate}
    \end{enumerate}
  \end{definition}
\end{toappendix}

\subsection{Free groups}

Usually, there are are many equations, besides the group axioms, that hold for the elements of a group. For example, in
the group $\Aut[\Bool]$, or $\mathbb{Z}_2$, we have an equation $1 + 1 = 0$, which is not a consequence of the group
axioms, but is specific to this particular group. A free group has the property that no other equations hold except the
ones directly implied by the group axioms. For example, the additive group of integers $\mathbb{Z}$ is the free group on
the singleton set.

\begin{toappendix}
  \begin{definition}
    \label{def:free-group}
    Given a set $A$, the free group $F(A)$ on it is given by a higher inductive type with the following point and path
    constructors. Notice the similarity with the definition of a group structure (\Cref{def:group}), but note that each
    operation here is a generator for $F(A)$.
    \begin{itemize}
      \item An inclusion function $\eta_{A} : A \to F(A)$
      \item A multiplication function $m : F(A) \times F(A) \to F(A)$
      \item An element $e : F(A)$
      \item An inverse function $i : F(A) \to F(A)$
    \end{itemize}
    \smallskip
    \begin{itemize}
      \item For every $x, y, z : F(A)$, a path $\term{assoc} : m(x, m(y, z)) \id m(m(x, y), z)$
      \item For every $x : F(A)$, paths $\term{unitr} : m(x, e) \id x$ and $\term{unitl} : m(e, x) \id x$
      \item For every $x : F(A)$, paths $\term{invr} : m(x, i(x)) \id e$ and $\term{invl} : m(i(x), x) \id e$
      \item A 0-truncation, for every $x, y : F(A)$ and $p, q : x \id y$, a 2-path $\term{trunc} : p \id q$
    \end{itemize}
  \end{definition}
\end{toappendix}

A group homomorphism between groups $G$ and $H$, which we write as $G \to^G H$, is a function between the underlying
sets that preserves the group structure. Giving a group homomorphism out of the free group is equivalent to giving a
function out of the generating set. This is the universal property of free groups, stemming from the free-forgetful
adjunction between the category of groups and sets.

% Informally, it states that if we know how a map $f$ acts on the
% generating set $A$, we know exactly how it acts on every element of the group $F(A)$.

\begin{proposition}[Universal Property of $F(A)$]
  \label{prop:free-groups}
  Given a group $G$ and a map $f : A \to G$, there is a unique group
  homomorphism $\extend{f} : F(A) \to^G G$ such that $\extend{f} \comp \eta_A
    \htpy f$. Equivalently, composition with $\eta_A$ gives an equivalence $F(A)
    \to^G G \eqv A \to G$. Alternatively, the type of group homomorphisms $h :
    F(A) \to^G G$ satisfying $h \comp \eta_A \htpy f$ is contractible.
  \begin{toappendix}
    % https://q.uiver.app/?q=WzAsMyxbMCwyLCJBIl0sWzAsMCwiRihBKSJdLFsyLDAsIkciXSxbMCwxLCJcXGV0YV9BIl0sWzAsMiwiZiIsMl0sWzEsMiwiXFxleHRlbmR7Zn0iLDAseyJzdHlsZSI6eyJib2R5Ijp7Im5hbWUiOiJkYXNoZWQifX19XSxbMyw0LCJcXGlkIiwwLHsic2hvcnRlbiI6eyJzb3VyY2UiOjIwLCJ0YXJnZXQiOjIwfSwic3R5bGUiOnsiYm9keSI6eyJuYW1lIjoibm9uZSJ9LCJoZWFkIjp7Im5hbWUiOiJub25lIn19fV1d
    \[\begin{tikzcd}
        {F(A)} && G \\
        \\
        A
        \arrow[""{name=0, anchor=center, inner sep=0}, "{\eta_A}", from=3-1, to=1-1]
        \arrow[""{name=1, anchor=center, inner sep=0}, "f"', from=3-1, to=1-3]
        \arrow["{\extend{f}}", dashed, from=1-1, to=1-3]
        \arrow["\id", Rightarrow, draw=none, from=0, to=1]
      \end{tikzcd}\]
  \end{toappendix}
\end{proposition}

Following the universal-algebraic definition, in HoTT, we could use a naive higher inductive type to define the free
group, which enforces the group axioms by adding path constructors (see~\Cref{def:free-group}).
Using the induction principle, we can easily verify the universal property. However, since this definition of $F(A)$ has
lots of path constructors corresponding to each group axiom, characterising its path space is difficult.

Instead, we will think about elements of the free group as words over an alphabet of letters drawn from the generating
set \emph{and} the set of their formal inverses. If we take the disjoint union of $A$ with itself, that is, $A + A$ as
the group's underlying set, we can use $\inl/\inr$ to mark the elements -- $\inl{a}$ means $a$ and $\inr{a}$ means
$\inv{a}$. Then, we can encode the free group using the free monoid, that is, lists of $A + A$. Additionally, we need to
ensure that the inverse laws hold, so we have to coalesce adjacent occurences of $a$ and $\inv{a}$.

\begin{definition}
  \label{def:presentation}
  Let $A$ be a set, and $\List[\blank]$ the free monoid. The free group $F(A)$ on $A$ is the set-quotient of $\List[A +
      A]$ by the congruence closure of the relation $a \cons \inv{a} \cons \nil \sim \nil$ and $\inv{a} \cons a \cons \nil
    \sim \nil$.
\end{definition}

\begin{proposition}
  $F(A) \defeq \quot{\List[A + A]}{\sim^{\ast}}$ has a group structure, with the empty list $\nil$ for the neutral
  element, multiplication given by list append $\append$, and inverse given by flipping $\inl$ and $\inr$, followed by
  reversing the list. Further, $F(A)$ with $\eta_A(a) \defeq \inl(a) \cons \nil$ satisfies the universal property of
  free groups, as stated in~\Cref{prop:free-groups}.
\end{proposition}

\subsection{Group presentations}

A presentation of a group builds it by starting from the free group $F(A)$ and introducing additional equations that are
satisfied in the resulting group. For example, if we take $F(\unit) \defeq \mathbb{Z}$ and add an equation $1 + 1 = 0$,
the resulting group would be $\mathbb{Z}_2 \eqv \Aut[\Bool]$. Note that not all groups have finite (or computable)
presentations, and, a group can have any number of different presentations.

\begin{definition}
  Let $A$ be a set and $R : \List[A + A] \to \List[A + A] \to \UU$ a binary relation on $\List[A + A]$. The group
  $F(\langle A ; R \rangle)$ presented by $A$ and $R$, is given by the set-quotient of the free group $F(A)$ by the
  congruence closure of $R$.
\end{definition}

The universal property of the above definition is similar to~\Cref{prop:free-groups} except the relation has to be
preserved by the function mapping out of the generating set.

\begin{proposition}[Universal property of $F(\langle A ; R \rangle)$]
  Given a group $G$ and a map $f : A \to G$, such that $f$ extended to $F(A)$ respects $R$, there is a unique group
  homomorphism $\extend{f} : F(\langle A ; R \rangle) \to^G G$ such that $\extend{f} \comp \eta_A \htpy f$.
\end{proposition}

Before, the only way to decide the equality of two elements in a group was to evaluate and check them on the nose, but
in a group presentation, this is reduced to a \emph{word problem}, that is, deciding whether one word -- a
representative of the equivalence class of the group's elements, can be reduced to another word, using the group's
relations. However, these equations are not directed, so it is not always possible to construct a well-behaved rewriting
system. In general, the word problem for groups is known to be undecidable.\jk{Example?}\todo{Examples: empty relation,
  full relation, van Kampen of $\pi_{1}$}

% This can be thought of as word reductions in a rewriting system.

\subsubsection{Coxeter Presentation}

To present the group $\Sn$, the primitive operations we are going to use will be adjacent swaps. When dealing with
permutations on an $n + 1$-element set, there are $n$ adjacent transpositions, transposition number $k$ swapping
elements $(\el{k}, \el{k+1})$. Thus, the generating set would be $\Fin[n]$. There are three relations that we're going
to specify for this presentation -- these are the equations that these generators should satisfy. We visualise them as
braid diagrams in~\Cref{fig:coxeter-braid}.

\begin{enumerate}
  \item[\labelcref{fig:coxeter-a}] Swapping the same two elements two times in a row should be the same as doing nothing
  \item[\labelcref{fig:coxeter-b}] When swapping two distinct pairs of elements, it should not matter in which order the
    swapping happens, that is, we can slide the wires freely.
  \item[\labelcref{fig:coxeter-c}] If the next transposition in the sequence is equal to the the first one, the order of
    operations can be reversed.
\end{enumerate}

\begin{figure}
  \centering
  \begin{subfigure}[b]{0.3\textwidth}
    \centering
    \begin{tikzpicture}
      \pic[local bounding box=my braid,braid/.cd,
        number of strands = 2,
        width = 0.6cm,
        height = 0.4cm,
        border height = 0.3cm,
        thick] at (0, 0)
      {braid={ s_1, s_1}};
      \node[font=\Huge] at (1.75, 0.7) {\(\rightarrow\)};
      \pic[local bounding box=my braid,braid/.cd,
        number of strands = 2,
        width = 0.6cm,
        height = 0.4cm,
        border height = 0.3cm,
        thick] at (3, 0)
      {braid={ 1, 1}};
    \end{tikzpicture}
    \caption{$\cancel$}
    \label{fig:coxeter-a}
  \end{subfigure}
  \hfill
  \begin{subfigure}[b]{0.5\textwidth}
    \centering
    \begin{tikzpicture}
      \pic[local bounding box=my braid,braid/.cd,
        number of strands = 2,
        width = 0.6cm,
        height = 0.4cm,
        border height = 0.3cm,
        thick] at (0, 0)
      {braid={ s_1, 1}};
      \node[] at (1.1, 0.7) {\(\dots\)};
      \pic[local bounding box=my braid,braid/.cd,
        number of strands = 2,
        width = 0.6cm,
        height = 0.4cm,
        border height = 0.3cm,
        thick] at (1.5, 0)
      {braid={ 1, s_1 }};
      \node[font=\Huge] at (3, 0.7) {\(\rightarrow\)};
      \pic[local bounding box=my braid,braid/.cd,
        number of strands = 2,
        width = 0.6cm,
        height = 0.4cm,
        border height = 0.3cm,
        thick] at (4, 0)
      {braid={ 1, s_1}};
      \node[] at (5.1, 0.7) {\(\dots\)};
      \pic[local bounding box=my braid,braid/.cd,
        number of strands = 2,
        width = 0.6cm,
        height = 0.4cm,
        border height = 0.3cm,
        thick] at (5.5, 0)
      {braid={ s_1, 1}};
    \end{tikzpicture}
    \caption{$\swap$}
    \label{fig:coxeter-b}
  \end{subfigure}
  \hfill
  \begin{subfigure}[b]{\textwidth}
    \centering
    \begin{tikzpicture}
      \pic[local bounding box=my braid,braid/.cd,
        number of strands = 3,
        width = 0.6cm,
        height = 0.4cm,
        border height = 0.1cm,
        thick] at (0, 0)
      {braid={ s_2, s_1, s_2}};
      \node[font=\Huge] at (2.15, 0.7) {\(\rightarrow\)};
      \pic[local bounding box=my braid,braid/.cd,
        number of strands = 3,
        width = 0.6cm,
        height = 0.4cm,
        border height = 0.1cm,
        thick] at (3, 0)
      {braid={ s_1, s_2, s_1}};
    \end{tikzpicture}
    \caption{$\braid$}
    \label{fig:coxeter-c}
  \end{subfigure}
  \caption{Braiding diarams for Coxeter relations.}
  \label{fig:coxeter-braid}
\end{figure}
\todo{an example/motivation from book.pdf}

This construction is called a Coxeter presentation of $\Sn$. Writing it formally, we encode the rules discussed above
using a relation $\cox$ on $\List[\Fin[n]]$ (\Cref{def:cox}), and then take its congruence closure $\cox*$
(\Cref{def:coxstar}).

\begin{definition}[$\cox : {\List[\Fin[n]]} \to {\List[\Fin[n]]} \to {\UU}$]
  \label{def:cox}
  \begin{align*}
    \cancel
     & : \forall n \to (n \cons n \cons \nil) \cox \nil                                                     \\
    \swap
     & : \forall k, n \to (\suc[k] < n) \to (n \cons k \cons \nil) \cox (k \cons n \cons \nil)              \\
    \braid
     & : \forall n \to (\suc[n] \cons n \cons \suc[n] \cons \nil) \cox (n \cons \suc[n] \cons n \cons \nil)
  \end{align*}
\end{definition}

\begin{toappendix}
  \begin{definition}[$\cox* : {\List[\Fin[n]]} \to {\List[\Fin[n]]} \to {\UU}$]
    \label{def:coxstar}
    \begin{align*}
      \reflr{\cox}
       & : \forall w \to w \cox* w                                                                                                           \\
      \symr{\cox}
       & : \forall w_{1}, w_{2} \to w_{1} \cox* w_{2} \to w_{2} \cox* w_{1}                                                                  \\
      \transr{\cox}
       & : \forall w_{1}, w_{2}, w_{3} \to  w_{1} \cox* w_{2} \to w_{2} \cox* w_{3} \to w_{1} \cox* w_{3}                                    \\
      \congrf{\cox}{\append}
       & : \forall w_{1}, w_{2}, w_{3}, w_{4} \to  w_{1} \cox* w_{2} \to w_{3} \cox* w_{4} \to w_{1} \append w_{3} \cox* w_{2} \append w_{4} \\
      \relr{\cox}
       & : \forall w_{1}, w_{2} \to w_{1} \cox w_{2} \to w_{1} \cox* w_{2}
    \end{align*}
  \end{definition}
\end{toappendix}

The idea for solving the word problem for $\Sn$ is to turn these undirected relations into a rewriting
system $(\List[\Fin[n]],\cox*)$, so that, by repeatedly applying the reduction rules as long as possible, any two
$\cox*$-equal terms would eventually converge to the same normal form.

For this to work, we first need the system to have the termination property, meaning that there are no infinite
reductions. We observe that after throwing out reflexivity and symmetry, the right hand sides of the relations $\cox*$
are strictly smaller than the left hand sides, in terms of the lexicographical ordering on words in $\Fin[n]$ (which is
well-founded). Thus, by directing the relation from left to right, we would get the termination property out of the box.
Second, we need the normal forms to be unique, so that we can get a normalisation function. This will be true if the
rewriting system is confluent -- meaning that all critical pairs, that is, terms with overlapping possible reduction
rules, have to converge. For example, in our system, the pairs in~\Cref{fig:critical-pairs-converging} converge.
Unfortunately, this is not true for all critical pairs -- an  example is in~\Cref{fig:critical-pairs-non-converging},
where both endpoints are normal with respect to the $\cox*$ relation.

% \begin{figure}
% \[
%   \begin{array}{lcr}
%     \gspan[\braid][\braid]{\tau_2\tau_1\tau_2\tau_1\tau_2}{\tau_1\tau_2\tau_1\tau_1\tau_2}{\tau_2\tau_1\tau_1\tau_2\tau_1}
%      &
%     \text{or}
%      &
%     \gspan[\braid][\cancel]{\tau_2\tau_1\tau_2\tau_2}{\tau_1\tau_2\tau_1\tau_2}{\tau_2\tau_1}
%   \end{array}
% \]
% \caption{Critical pairs}
% \label{fig:critical-pairs}
% \end{figure}
%  \begin{subfigure}[]{0.45\textwidth}
%    % https://q.uiver.app/?q=WzAsNSxbMiwwLCJcXHRhdV8yXFx0YXVfMVxcdGF1XzJcXHRhdV8yIl0sWzAsMSwiXFx0YXVfMVxcdGF1XzJcXHRhdV8xXFx0YXVfMiJdLFsyLDQsIlxcdGF1XzJcXHRhdV8xIl0sWzAsMiwiXFx0YXVfMVxcdGF1XzJcXHRhdV8xXFx0YXVfMiJdLFsxLDMsIlxcdGF1XzFcXHRhdV8xXFx0YXVfMlxcdGF1XzEiXSxbMCwxLCJicmFpZCIsMix7InN0eWxlIjp7ImJvZHkiOnsibmFtZSI6InNxdWlnZ2x5In19fV0sWzAsMiwiY2FuY2VsIiwwLHsic3R5bGUiOnsiYm9keSI6eyJuYW1lIjoic3F1aWdnbHkifX19XSxbMSwzLCJicmFpZCIsMix7InN0eWxlIjp7ImJvZHkiOnsibmFtZSI6InNxdWlnZ2x5In19fV0sWzMsNCwiYnJhaWQiLDIseyJzdHlsZSI6eyJib2R5Ijp7Im5hbWUiOiJzcXVpZ2dseSJ9fX1dLFs0LDIsImNhbmNlbCIsMix7InN0eWxlIjp7ImJvZHkiOnsibmFtZSI6InNxdWlnZ2x5In19fV1d
%    \adjustbox{scale=\scalef,center}{
%      \begin{tikzcd}
%        && {\tau_2\tau_1\tau_2\tau_2} \\
%        {\tau_1\tau_2\tau_1\tau_2} \\
%        {\tau_1\tau_2\tau_1\tau_2} \\
%        & {\tau_1\tau_1\tau_2\tau_1} \\
%        && {\tau_2\tau_1}
%        \arrow["\braid"', squiggly, from=1-3, to=2-1]
%        \arrow["\cancel", squiggly, from=1-3, to=5-3]
%        \arrow["\braid"', squiggly, from=2-1, to=3-1]
%        \arrow["\braid"', squiggly, from=3-1, to=4-2]
%        \arrow["\cancel"', squiggly, from=4-2, to=5-3]
%      \end{tikzcd}
%    }
%  \end{subfigure}
%   \begin{subfigure}[]{0.45\textwidth}
%    $\gspan[\braid][\swap]{\tau_3\tau_2\tau_3\tau_1}{\tau_2\tau_3\tau_2\tau_1}{\tau_3\tau_2\tau_1\tau_3}$
%    \caption{Non-converging critical pairs}
%    \label{fig:critical-pairs-non-converging}
%  \end{subfigure}


\begin{figure}
  \centering
  \begin{subfigure}[b]{0.35\textwidth}
    % https://q.uiver.app/?q=WzAsNixbMSwwLCJcXHRhdV8yXFx0YXVfMVxcdGF1XzJcXHRhdV8xXFx0YXVfMiJdLFswLDEsIlxcdGF1XzFcXHRhdV8yXFx0YXVfMVxcdGF1XzFcXHRhdV8yIl0sWzIsMSwiXFx0YXVfMlxcdGF1XzFcXHRhdV8xXFx0YXVfMlxcdGF1XzEiXSxbMCwyLCJcXHRhdV8xXFx0YXVfMlxcdGF1XzIiXSxbMSwzLCJcXHRhdV8xIl0sWzIsMiwiXFx0YXVfMlxcdGF1XzJcXHRhdV8xIl0sWzAsMSwiYnJhaWQiLDIseyJzdHlsZSI6eyJib2R5Ijp7Im5hbWUiOiJzcXVpZ2dseSJ9fX1dLFswLDIsImJyYWlkIiwwLHsic3R5bGUiOnsiYm9keSI6eyJuYW1lIjoic3F1aWdnbHkifX19XSxbMSwzLCJjYW5jZWwiLDIseyJzdHlsZSI6eyJib2R5Ijp7Im5hbWUiOiJzcXVpZ2dseSJ9fX1dLFszLDQsImNhbmNlbCIsMix7InN0eWxlIjp7ImJvZHkiOnsibmFtZSI6InNxdWlnZ2x5In19fV0sWzIsNSwiY2FuY2VsIiwwLHsic3R5bGUiOnsiYm9keSI6eyJuYW1lIjoic3F1aWdnbHkifX19XSxbNSw0LCJjYW5jZWwiLDAseyJzdHlsZSI6eyJib2R5Ijp7Im5hbWUiOiJzcXVpZ2dseSJ9fX1dXQ==
    \adjustbox{scale=\scalef,center}{
      \begin{tikzcd}
        & {\tau_2\tau_1\tau_2\tau_1\tau_2} \\
        {\tau_1\tau_2\tau_1\tau_1\tau_2} && {\tau_2\tau_1\tau_1\tau_2\tau_1} \\
        {\tau_1\tau_2\tau_2} && {\tau_2\tau_2\tau_1} \\
        & {\tau_1}
        \arrow["\braid"', squiggly, from=1-2, to=2-1]
        \arrow["\braid", squiggly, from=1-2, to=2-3]
        \arrow["\cancel"', squiggly, from=2-1, to=3-1]
        \arrow["\cancel"', squiggly, from=3-1, to=4-2]
        \arrow["\cancel", squiggly, from=2-3, to=3-3]
        \arrow["\cancel", squiggly, from=3-3, to=4-2]
      \end{tikzcd}
    }
    \caption{A converging critical pair in $\cox*$}
    \label{fig:critical-pairs-converging}
  \end{subfigure}
  \begin{subfigure}[b]{0.55\textwidth}
    \adjustbox{scale=\scalef,center}{
    % https://q.uiver.app/?q=WzAsMyxbMSwwLCJcXHRhdV8zXFx0YXVfMlxcdGF1XzNcXHRhdV8xIl0sWzAsMiwiXFx0YXVfMlxcdGF1XzNcXHRhdV8yXFx0YXVfMSJdLFszLDEsIlxcdGF1XzNcXHRhdV8yXFx0YXVfMVxcdGF1XzMiXSxbMCwxLCJicmFpZCIsMix7InN0eWxlIjp7ImJvZHkiOnsibmFtZSI6InNxdWlnZ2x5In19fV0sWzAsMiwiYnJhaWQiLDAseyJzdHlsZSI6eyJib2R5Ijp7Im5hbWUiOiJzcXVpZ2dseSJ9fX1dLFsyLDEsIlxcbG9uZ2JyYWlkIiwwLHsic3R5bGUiOnsiYm9keSI6eyJuYW1lIjoic3F1aWdnbHkifX19XV0=
    \begin{tikzcd}
      & {\tau_3\tau_2\tau_3\tau_1} \\
      &&& {\tau_3\tau_2\tau_1\tau_3} \\
      {\tau_2\tau_3\tau_2\tau_1}
      \arrow["braid"', squiggly, from=1-2, to=3-1]
      \arrow["braid", squiggly, from=1-2, to=2-4]
      \arrow["\longbraid", squiggly, from=2-4, to=3-1]
    \end{tikzcd}
    }
    \caption{A non-converging critical pair in $\cox*$ converging in $\longcox*$}
    \label{fig:critical-pairs-non-converging}
  \end{subfigure}

  \caption{Critical Pairs}
  \label{fig:critical-pairs}
\end{figure}

\subsection{Rewriting via Coxeter}

Because of this counter-example, the relations have to be changed. In this section, we formally define a rewriting
system $(\List[\Fin[n]], \longcox*)$, partially based on the Coxeter relations, and prove that it has the desired
properties of confluence and termination. We prove that the new relation defined by this system is equivalent,
in a technical sense, to the standard Coxeter relation $\cox*$.

% The Coxeter relations are a standard notion in the theory of group presentation~\todo{citation} -- even though we change
% the relations a bit, we will not lose the connection. In fact, we will prove that the new relations are equivalent, in a
% technical sense, to the standard Coxeter relations $\cox*$.
% The system has generators corresponding to $\swap$, $\cancel$
% and $\braid$, the problem of the non-converging critical pairs discussed previously is fixed by changing $\braid$ to be
% a slightly more general relation $\longbraid$.

\review{Further, we also inline the congruence closure in $\longcox$, allowing arbitrary reductions inside the list.}

\todo{but computation is usually done by using Coxeter matrices~\cite{davisGeometryTopologyCoxeter2008}.}

First, we need to define a helper function $n \downf k$.

\begin{definition}[$\downf : (n : \Nat) \to (k : \Nat) \to {\List[\Fin[k + n]]}$]
  \begin{align*}
    n \downf \zero   & \defeq \nil                       \\
    n \downf \suc[k] & \defeq (k + n) \cons (n \downf k)
  \end{align*}
\end{definition}

The result of this function is the sequence \([k + n - 1, k + n - 2, k + n - 3, \ldots, n]\). Since we think of the
number $m$ as the transposition swapping elements $(\el{m}, \el{m+1})$, the role of this helper function
is to produce a sequence of transpositions -- a permutation -- which moves element $\el{k + n}$ by $k$ places left,
shifting all the elements in between one place right (see~\Cref{fig:downf}).

\begin{figure}
  \[
    \begin{tikzpicture}
      \pic[local bounding box=my braid,braid/.cd,
        number of strands = 5,
        width = 0.6cm,
        height = 0.4cm,
        border height = 0.1cm,
        thick]
      {braid={s_1, s_2, s_3, s_4}};
    \end{tikzpicture}
  \]
  \caption{Braiding diagram for $0 \downf 4$}
  \label{fig:downf}
\end{figure}

Then, the directed relation $\longcox$ is defined with the following generators.

\begin{definition}[$\longcox$]
  \begin{align*}
    \longcancel
     & : \forall n, l, r \to (l \append n \cons n \cons r) \longcox (l \append r)                                                                   \\
    \longswap
     & : \forall k, n, l, r \to (\suc[k] < n) \to (l \append n \cons k \cons r) \longcox (l \append k \cons n \append r)                            \\
    \longbraid
     & : \forall n, l, r \to (l \append (n \downf 2 + k) \append (1 + k + n) \cons r) \longcox (l \append (k + n) \cons (n \downf 2 + k) \append r)
  \end{align*}
\end{definition}

Constructors $\longcancel$ and $\longswap$ correspond directly to the appropriate constructors of $\cox$ and can be
visualised in the same way as before. The remaining constructor uses the helper function to exchange the order of a long
sequence of transpositions and a single transposition afterwards. For example, for $n = 0$ and $k = 3$, it allows for
the reduction $[4, 3, 2, 1, 0, 4] \longcox [3, 4, 3, 2, 1, 0]$ (see~\Cref{fig:longcox}).

\begin{figure}
  \begin{tikzpicture}
    \pic[local bounding box=my braid,braid/.cd,
      number of strands = 6,
      width = 0.6cm,
      height = 0.4cm,
      border height = 0.1cm,
      thick] at (0, 0)
    {braid={s_5, s_1, s_2, s_3, s_4, s_5}};
    \node[font=\Huge] at (4, 1.3) {\(\rightarrow\)};
    \pic[local bounding box=my braid,braid/.cd,
      number of strands = 6,
      width = 0.6cm,
      height = 0.4cm,
      border height = 0.1cm,
      thick] at (5, 0)
    {braid={s_1, s_2, s_3, s_4, s_5, s_4}};
  \end{tikzpicture}
  \caption{Braiding diagram for $\longbraid$ with $n = 0$ and $k = 3$}
  \label{fig:longcox}
\end{figure}

Note that the previous $\braid$ rule is a special case of $\longbraid$, with $k = 0$. Also, as before, the left-hand
sides of the relation are strictly larger than the right-hand sides, in terms of the lexicographic order on
$\List[\Fin[n]]$.

We define the relation $\longcox*$ to be the closure of $\longcox$, under reflexivity and (right-step extended)
transitivity (see~\Cref{def:longcox-star}).

\begin{toappendix}
  \begin{definition}[$\longcox*$]
    \label{def:longcox-star}
    \begin{align*}
      \reflr{\longcox}
       & : \forall w \to w \longcox* w                                                                               \\
      \transr{\longcox}
       & : \forall w_{1}, w_{2}, w_{3} \to  w_{1} \longcox w_{2} \to w_{2} \longcox* w_{3} \to w_{1} \longcox* w_{3}
    \end{align*}
  \end{definition}
\end{toappendix}

Despite the increased complexity of the generators, the rewriting system $(\List[\Fin[n]],\longcox*)$ has the properties
we desire. It satisfies local confluence, that is, the Church-Rosser (diamond) property, and it is terminating, so, by
Newman's lemma, it produces a unique normal form. We follow the terminology
of~\cite*{huetConfluentReductionsAbstract1980a,krausCoherenceWellFoundednessTaming2020} to state our results
formally.~\vc{check!}

\begin{proposition}
  \label{prop:nf}
  \leavevmode
  \begin{enumerate}
    \item $\longcox$ is (locally) confluent. For every span $\coxspan{w_{1}}{w_{2}}{w_{3}}$, there is a matching
          extended cospan $\coxcospan*{w_{2}}{w_{3}}{w}$.
    \item $\longcox*$ is terminating. For every $w \longcox v$, it holds that $v < w$, where $<$ is the (well-founded)
          lexicographic ordering on $\List[\Fin[n]]$.
    \item $\longcox*$ is confluent. For every extended span $\coxspan*{w_{1}}{w_{2}}{w_{3}}$, there is a matching
          extended cospan $\coxcospan*{w_{2}}{w_{3}}{w}$.
    \item For every $w$, there exists a unique normal form $v$ such that $w \longcox* v$.~\label{prop:nf-uniqueness}
  \end{enumerate}
\end{proposition}

The modified form of the Coxeter relations are unwieldy and difficult to prove properties about by induction. However,
we can make the following observation relating it to $\cox*$.

\begin{proposition}
  \label{prop:coxlongcox}
  The relations $\cox*$ and $\longcox*$ are equivalent in the following sense: for every $w$ and $v$, $w \cox* v$ iff
  there is a $u$ such that $w \longcox* u$ and $v \longcox* u$.
\end{proposition}

By~\Cref{prop:nf}~\ref{prop:nf-uniqueness}, we get a unique choice function $\normf : {\List[\Fin[n]]} \to
  {\List[\Fin[n]]}$ that produces a normal form for terms of $\List[\Fin[n]]$. We state and prove a couple of important
properties enjoyed by $\normf$.

\begin{proposition}
  \leavevmode
  \begin{enumerate}
    \item For all $l : \List[\Fin[n]]$, we have that $l \cox* \normf(l)$.
    \item $\normf$ is idempotent, that is, $\normf \comp \normf \htpy \normf$.
  \end{enumerate}
\end{proposition}

Finally, we define the type $\Sn$ as the set-quotient of $\List[\Fin[n]]$ by $\cox*$,

\begin{definition}[$\Sn$]
  \(\Sn \defeq \quot{\List(\Fin[n])}{\cox*}\)
\end{definition}

% Note that this relation $\cox*$ is not prop-valued, that is, $w \cox* v$ is not a proposition because reductions need
% not be unique. So, the quotient $\Sn$ is not effective, that is, $\quotrel : w \cox* v \to q(w) \id q(v)$ is not an
% equivalence. We could instead define equivalence classes on $\List[\Fin[n]]$ to be those terms that have the same normal
% form, using the $\normf$ function. Defining a new relation $(w \approx v) \defeq (\normf(w) \id \normf(v))$ which is
% prop-valued, we could quotient $\List[\Fin[n]]$ by $\approx$. This is an equivalent definition for $\Sn$.

Note that this relation $\cox*$ is not prop-valued, that is, $w \cox* v$ is not a proposition because reductions need
not be unique. So, the quotient $\Sn$ is not effective, that is, $\quotrel : w \cox* v \to q(w) \id q(v)$ is not an
equivalence. Using the $\normf$ function, we could instead define a new relation $\approx$ to equate those terms that
have the same normal form, $(w \approx v) \defeq (\normf(w) \id \normf(v))$. This relation is prop-valued, and we could
quotient $\List[\Fin[n]]$ by $\approx$, obtaining an equivalent definition for $\Sn$.

\begin{proposition}
  \leavevmode
  \begin{enumerate}
    \item $\normf$ splits into a section-retraction pair, that is, we have ${\List[\Fin[n]]} \xrightarrow{s} \Sn[n]
            \xrightarrow{r} {\List[\Fin[n]]}$ such that $s \comp r \htpy \normf$ and $r \comp s \htpy \idfunc_{\Sn[n]}$.
    \item \(\im{\quotinc} \eqv \Sn \eqv \im{\normf} \), where $\quotinc$ is the inclusion into the quotient.
  \end{enumerate}
\end{proposition}

Notice however, that a group presentation, as defined in~\Cref{def:presentation}, requires the relation to be on the set
of words $A + A$, where the right copy corresponds to the set of formal inverses of the generators. The constructor
$\cancel$ specifies that the inverse of each element is again the same element, using which we can show that our
definition of $\Sn$ is equivalent to the definition of a presented group, by lifting the $\cox*$ relation.

\begin{proposition}
  \leavevmode
  \begin{enumerate}
    \item There is a group structure on $\Sn$, where the identity element is $\nil$, multiplication is given by list
          append, and inverse is given by list reversal.
    \item $\Sn$ is equivalent to the group presented by generators $\Fin[n]$ with the relations given by $\cox*$
          extended to $\List(\Fin[n] + \Fin[n])$ along the codiagonal map $\nabla_{A} : A + A \to A$.
  \end{enumerate}
\end{proposition}

We set out to solve the word problem for $\Sn$. To decide if two words in $\List[\Fin[n]]$ are $\cox*$-equal, we simply
have to compute their normal forms using $\normf$. They correspond to the same permutation if and only if these normal
forms are equal.

\subsection{Lehmer Codes}~\label{subsec:lehmer}

To prove the equivalence between $\Aut[\Fin[n]]$ and $\Sn[n]$, we will need to define functions back and forth between
the two types. The terms in $\Sn$ can be identified with equivalence classes of terms in $\List[\Fin[n]]$ with respect
to the Coxeter relation $\cox*$. The easiest way to define a function out of this presentation is to define it on the
representatives. We know that these are the unique normal forms in the set-quotient given by $\quotinc \comp \normf$,
but now we will explicitly describe what these representatives look like, using an encoding called Lehmer
codes~\cite{lehmerTeachingCombinatorialTricks1960}.

Lehmer codes are known in Combinatorial Analysis~\cite{bellmanCombinatorialAnalysis1960} where they are sometimes called
"subexcedant sequences", or "factoriadics", which give the factorial number system. They are a convenient way of
representing permutations on a computer, partly because they are
bitwise-optimal~\cite{bergerTeachingOrdinalPatterns2019a}.

Formally, we define $\Lehmer[n]$ to be an $n+1$-element tuple, where the position $k \leq n$ stores an element of
$\Fin[k]$. Since the 0-th position is trivial, in practice it is ignored, and the sequence starts at
1~\cite{duboisTestsProofsCustom2018,vajnovszkiNewEulerMahonian2011}.

\begin{definition}[$\Lehmer : \Nat \to \UU$]
  \begin{align*}
    \Lehmer[\zero]   & \defeq \Fin[\suc[\zero]]                     \\
    \Lehmer[\suc[n]] & \defeq \Fin[\suc[\suc[n]]] \times \Lehmer[n]
  \end{align*}
  % \begin{aligned}
  %   \lzero & : \Lehmer[\zero]                                                     \\
  %   \lsuc  & : \forall n, r, (r \leq \suc[n]) \to \Lehmer[n] \to \Lehmer[\suc[n]]
  % \end{aligned}
\end{definition}

Given a permutation $\sigma : \Aut[\Fin[n]]$, for any element $i: \Fin[n]$, we can define the inversion count of $i$ as
the number of smaller elements appearing after it in the permutation.

\begin{definition}
  Given a permutation $\sigma : \Aut[\Fin[n]]$, the inversion count of $k: \Fin[n]$ is given by
  \[ \invcount{i} = \#\Set{j < i | \sigma(j) > \sigma(i)}. \]
\end{definition}

From knowing just the inversion counts for all the elements, one can reconstruct the starting permutation. Also, observe
that $\invcount{i} < i$, thus fitting in the $i$-th place of a Lehmer code tuple. As an example, consider the following
tabulated presentation of a permutation of $\Fin[5]$.

\[
  \sigma =
  \begin{pmatrix}
    0      & 1      & 2      & 3      & 4      \\
    \el{2} & \el{1} & \el{4} & \el{0} & \el{3} \\
  \end{pmatrix}
\]

% The inversion count for $\el{0}$ is 0 (because there are no smaller elements at all), for $\el{1}$ is 1 (because of
% $\el{0}$ appearing after), for $\el{2}$ is 2 (because of $\el{0}$ and $\el{1}$), for $\el{3}$ is 0 (because it comes
% last in the sequence), and for $\el{4}$ is 2 (because of $\el{3}$ and $\el{0}$).

The Lehmer code for the permutation $\sigma$ is then the 5-tuple
\[
  l = (\invcount{0}, \invcount{1}, \invcount{2}, \invcount{3}, \invcount{4}) = (0, 1, 2, 0, 2)
\]

To decode the permutation back from this Lehmer code, we perform an algorithm similar to \emph{insertion sort}. The
element of the Lehmer code being currently processed is highlighted in the left column of the table below. Starting from
a sorted list, the element at index $k$ has to be given $l[k]$ inversions. Because of the the invariant that all the
elements before newly processed one are smaller than it, the proper number of inversions is created by simply shifting
the element $l[k]$ places left.

\begin{center}
  \begin{tabular}{l|r}
    (\highlight{{0}}, 1, 2, 0, 2) & $[\highlightAlt{\el{0}}, \el{1}, \el{2}, \el{3}, \el{4}]$ \\
    (0, \highlight{{1}}, 2, 0, 2) & $[\highlightAlt{\el{1}}, \el{0}, \el{2}, \el{3}, \el{4}]$ \\
    (0, 1, \highlight{{2}}, 0, 2) & $[\highlightAlt{\el{2}}, \el{1}, \el{0}, \el{3}, \el{4}]$ \\
    (0, 1, 2, \highlight{{0}}, 2) & $[\el{2}, \el{1}, \el{0}, \highlightAlt{\el{3}}, \el{4}]$ \\
    (0, 1, 2, 0, \highlight{{2}}) & $[\el{2}, \el{1}, \highlightAlt{\el{4}}, \el{0}, \el{3}]$ \\
  \end{tabular}
\end{center}

Writing formally, to turn a Lehmer code into a word in $\Sn$, we define a function $\immersion$. As described above, the
number $r$ at position $k$ in the tuple describes how many inversions the element $\el{k}$ has. Thus, we need to perform
$r$ many adjacent transpositions to get to the desired position, which is given by $(\suc[n] - r) \downf r$.

\begin{definition}[$\immersion : (n : \Nat) \to {\Lehmer[n]} \to {\List[\Fin[\suc[n]]]}$]
  \begin{align*}
    \immersion(\zero, \zero)    & \defeq \nil                                              \\
    \immersion(\suc[n], (r, l)) & \defeq \immersion(n, l) \append ((\suc[n] - r) \downf r)
  \end{align*}
\end{definition}

We can show that the function $\immersion$ gives an equivalence betweeen $\Lehmer[n]$ and $\im{\normf}$.

\begin{proposition}
  \leavevmode
  \begin{enumerate}
    \item For any Lehmer code $c$, $\immersion(c)$ is a normal form with resepct to $\longcox*$, that is, $\immersion(c)$ is
          in $\im{\normf}$.
    \item Any element of $\im{\normf}$ can be constructed from a unique Lehmer code by $\immersion$, that is, the fibers
          of $\immersion: \Lehmer[n] \to {\im{\normf}}$ are contractible.
  \end{enumerate}
  Therefore, there is an equivalence between $\Lehmer[n]$ and $\im{\normf}$.
\end{proposition}

\jk{Review:}
To see that Lehmer codes under $\immersion$ are normal with respect to $\longcox*$, let us look at the example code $c =
  (4, 3, 2, 1, 0)$. The list $\immersion(c)$ is then going to be $[0, 1, 0, 2, 1, 0, 3, 2, 1, 0, 4, 3, 2, 1, 0]$. It is a
concatenation of five decreasing lists. Where could a reduction happen?

First, it can't happen inside any of the decreasing components: $\longcancel$ requires repeating elements, $\longswap$
acts when a smaller number precedes a larger one, and $\longbraid$ has a non-monotone sequence on the left. This leaves
the case of a reduction happening on a fragment that borders two subsequences. Again, $\longcancel$ requires two equal
consecutive numbers, which have to be the last one in some decreasing sequence, and the first one in the next sequence.
But the first number in a sequence is always larger than every number in the sequence before it -- which also shows why
$\longswap$ cannot happen. The remaining case of $\longbraid$ follows similarly, since it requires the number appearing
after the decreasing sequence to be equal to the first one in the sequence.

% We also established an equivalence between $\im{\normf}$ and $\Sn$, which gives the following.
\begin{corollary}
  \label{prop:sn-im-lehmer-equiv}
  For all $n : \Nat$, \( \Sn \eqv \im{\normf} \eqv \Lehmer[n] \).
\end{corollary}

\subsection{Running Lehmer codes}

Finally, it is time to complete our goal of characterising the permutation groups. Having produced a Lehmer code by
normalising words in $\Sn$, we need to run it to produce a concrete bijection of finite sets, and, given a bijection
between finite sets, we need to encode it as a Lehmer code. We will prove that these maps construct an equivalence
between the types $\Lehmer[n]$ and $\Aut[\Fin[\suc[n]]]$.~\footnote{Note that the permutations are off-by-one, because
  we ignored the 0-position in the Lehmer code.}

To do so, we need to construct some equivalences by counting the elements of $\Fin[n]$ using its decidable equality.
First, we define a helper type family $\FinExcept{n} : \Fin[n] \to \UU$ which picks out all elements in $\Fin[n]$ except
the one in the argument. Note that $\FinExcept{n}[i]$ for $i : \Fin[n]$ is a subtype of $\Fin[n]$ and is hence an
$\hSet$.

\begin{definition}
  \( \FinExcept{n}[i] \defeq \dsum{j : \Fin[n]}{i \neq j} \).
\end{definition}

We state and prove a few auxiliary lemmas about how $\FinExcept{n}$ interacts with $\Fin$.

\begin{proposition}~\label{prop:fin-finexcept}
  \leavevmode
  \begin{enumerate}
    % \item For any $k : \Fin[n]$, $\unit \sqcup \FinExcept{n}[k] \eqv \Fin[n]$. \label{prop:fin-finexcept-1}
    \item For any $k : \Fin[\suc[n]]$, $\FinExcept{\suc[n]}[k] \eqv \Fin[n]$. \label{prop:fin-finexcept-2}
    \item For any $n : \Nat$, \( \Aut[\Fin[\suc[n]]] \eqv \dsum{k : \Fin[\suc[n]]}{\FinExcept{\suc[n]}[n] \eqv
            \FinExcept{\suc[n]}[n - k]} \). \label{prop:fin-finexcept-3}
  \end{enumerate}
\end{proposition}

\begin{appendixproof}
  The first and second propositions follow from simply constructing the bijections using the decidable equality of
  $\Fin[n]$, and making sure to punch-in and punch-out the element $k$ at the right place.

  The third proposition performs some combinatorial tricks. On the left, we have the type of automorphisms of
  $\Fin[\suc[n]]$. Assume a particular $\sigma : \Fin[\suc[n]] \xrightarrow{\sim} \Fin[\suc[n]]$. Pick $k$ to be the
  inversion count of $n$, the largest element in $\Fin[\suc[n]]$. Then, the image of $n$ under $\phi$ has to be $n - k$,
  since all other elements in the set are smaller. Removing those two from the domain and codomain of $\phi$, the rest
  of the elements are fixed by $\sigma$, so we compute the bijection between the rest of the elements.

  For the other direction, if we are given a $k$ and a bijection $\pi$ between $\FinExcept{\suc[n]}[n]$ and
  $\FinExcept{\suc[n]}[n - k]$, we can extend $\pi$ to $\sigma : \Fin[\suc[n]] \eqv \Fin[\suc[n]]$ by inserting the
  element $n$ at the position $n - k$, resulting in the element $n$ having inversion count $k$.
\end{appendixproof}

Using these facts, we can now prove the main result of this section.

\begin{proposition}~\label{prop:lehmer-aut-equiv}
  For all $n:\Nat$, \( \Lehmer[n] \eqv \Aut[\Fin[\suc[n]]] \).
\end{proposition}

\begin{proof}
  For $n = \zero$, note that $\Lehmer[\zero]$ is contractible, and so is $\Aut[\Fin[\suc[\zero]]]$. For $n = \suc[m]$,
  we compute a chain of equivalences.
  \begin{gather*}
    \arraycolsep=0.5em\def\arraystretch{1.5}
    \begin{array}{rl}
           & \Lehmer[\zero]          \\
      \eqv & \unit                   \\
      \eqv & \Aut[\Fin[\suc[\zero]]]
    \end{array}
    \qquad\qquad
    \begin{array}{rlr}
           & \Lehmer[\suc[m]]                                                                                   &                                                                 \\
      \eqv & \Fin[\suc[\suc[m]]] \times \Lehmer[m]                                                              & \text{by definition}                                            \\
      \eqv & \Fin[\suc[\suc[m]]] \times \Aut[\Fin[\suc[m]]]                                                     & \text{induction hypothesis}                                     \\
      \eqv & \dsum{k : \Fin[\suc[\suc[m]]]}{\Fin[\suc[m]] \eqv \Fin[\suc[m]]}                                   & \text{$\Sigma$ over a constant family}                          \\
      \eqv & \dsum{k : \Fin[\suc[\suc[m]]]}{\FinExcept{\suc[\suc[m]]}[m] \eqv \Fin[\suc[m]]}                    & \text{by~\Cref{prop:fin-finexcept}~\Cref{prop:fin-finexcept-2}} \\
      \eqv & \dsum{k : \Fin[\suc[\suc[m]]]}{\FinExcept{\suc[\suc[m]]}[m] \eqv \FinExcept{\suc[\suc[m]]}[m - k]} & \text{by~\Cref{prop:fin-finexcept}~\Cref{prop:fin-finexcept-2}} \\
      \eqv & \Aut[\Fin[\suc[\suc[m]]]]                                                                          & \text{by~\Cref{prop:fin-finexcept}~\Cref{prop:fin-finexcept-3}}
    \end{array}
  \end{gather*}
\end{proof}

By composing~\Cref{prop:lehmer-aut-equiv} and~\Cref{prop:sn-im-lehmer-equiv}, we obtain the final equivalence.

\begin{corollary}
  \label{prop:sn-lehmer-fin-equiv}
  For all $n : \Nat$,
  \(
  \Sn \eqv \Lehmer[n] \eqv \Aut[\Fin[\suc[n]]]
  \).
\end{corollary}

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "main"
%%% fill-column: 120
%%% End:
